NeoLKernel/arch/alpha/include/asm/rwsem.h:extern struct rw_semaphore *rwsem_wake(struct rw_semaphore *);
NeoLKernel/arch/alpha/include/asm/rwsem.h:extern struct rw_semaphore *rwsem_downgrade_wake(struct rw_semaphore *sem);
NeoLKernel/arch/alpha/include/asm/rwsem.h:			rwsem_wake(sem);
NeoLKernel/arch/alpha/include/asm/rwsem.h:			rwsem_wake(sem);
NeoLKernel/arch/alpha/include/asm/rwsem.h:		rwsem_downgrade_wake(sem);
NeoLKernel/arch/alpha/include/asm/unistd.h:#define __NR_osf_mwakeup	216	/* not implemented */
NeoLKernel/arch/alpha/kernel/ptrace.c:		wake_up_process(child);
NeoLKernel/arch/alpha/kernel/ptrace.c:		wake_up_process(child);
NeoLKernel/arch/alpha/kernel/ptrace.c:		wake_up_process(child);
NeoLKernel/arch/arm/mach-mx3/pcm037_eet.c:		.wakeup	= 0,
NeoLKernel/arch/arm/mach-mx3/pcm037_eet.c:		.wakeup	= 0,
NeoLKernel/arch/arm/mach-mx3/pcm037_eet.c:		.wakeup	= 0,
NeoLKernel/arch/arm/mach-mx3/pcm037_eet.c:		.wakeup	= 0,
NeoLKernel/arch/arm/mach-mx3/pcm037_eet.c:		.wakeup	= 0,
NeoLKernel/arch/arm/mach-mx3/pcm037_eet.c:		.wakeup	= 0,
NeoLKernel/arch/arm/mach-mx3/pcm037_eet.c:		.wakeup	= 0,
NeoLKernel/arch/arm/mach-mx3/pcm037_eet.c:		.wakeup	= 0,
NeoLKernel/arch/arm/mach-mx3/pcm037_eet.c:		.wakeup	= 0,
NeoLKernel/arch/arm/mach-mx3/pcm037_eet.c:		.wakeup	= 0,
NeoLKernel/arch/arm/mach-mx3/pcm037_eet.c:		.wakeup	= 0,
NeoLKernel/arch/arm/mach-mx3/pcm037_eet.c:		.wakeup	= 0,
NeoLKernel/arch/arm/mach-mx3/pcm037_eet.c:		.wakeup	= 0,
NeoLKernel/arch/arm/mach-mx3/pcm037_eet.c:		.wakeup	= 0,
Binary file NeoLKernel/arch/arm/boot/Image matches
NeoLKernel/arch/arm/common/.cpaccess.o.cmd:  include/linux/pm_wakeup.h \
Binary file NeoLKernel/arch/arm/common/cpaccess.o matches
NeoLKernel/arch/arm/common/gic.c:	unsigned int wakeup_irqs[32];
NeoLKernel/arch/arm/common/gic.c:		/* enable the wakeup set */
NeoLKernel/arch/arm/common/gic.c:		writel(gic_data[gic_nr].wakeup_irqs[i],
NeoLKernel/arch/arm/common/gic.c:static int gic_set_wake(unsigned int irq, unsigned int on)
NeoLKernel/arch/arm/common/gic.c:	/* per-cpu interrupts cannot be wakeup interrupts */
NeoLKernel/arch/arm/common/gic.c:		gic_data->wakeup_irqs[reg_offset] |=  1 << bit_offset;
NeoLKernel/arch/arm/common/gic.c:		gic_data->wakeup_irqs[reg_offset] &=  ~(1 << bit_offset);
NeoLKernel/arch/arm/common/gic.c:static int gic_set_wake(unsigned int irq, unsigned int on)
NeoLKernel/arch/arm/common/gic.c:	.set_wake	= gic_set_wake,
NeoLKernel/arch/arm/common/sa1111.c:static int sa1111_wake_lowirq(unsigned int irq, unsigned int on)
NeoLKernel/arch/arm/common/sa1111.c:	.set_wake	= sa1111_wake_lowirq,
NeoLKernel/arch/arm/common/sa1111.c:static int sa1111_wake_highirq(unsigned int irq, unsigned int on)
NeoLKernel/arch/arm/common/sa1111.c:	.set_wake	= sa1111_wake_highirq,
NeoLKernel/arch/arm/common/sa1111.c:static void sa1111_wake(struct sa1111 *sachip)
NeoLKernel/arch/arm/common/sa1111.c:	sa1111_wake(sachip);
NeoLKernel/arch/arm/common/sa1111.c:	unsigned int	wakepol0;
NeoLKernel/arch/arm/common/sa1111.c:	unsigned int	wakepol1;
NeoLKernel/arch/arm/common/sa1111.c:	unsigned int	wakeen0;
NeoLKernel/arch/arm/common/sa1111.c:	unsigned int	wakeen1;
NeoLKernel/arch/arm/common/sa1111.c:	save->wakepol0 = sa1111_readl(base + SA1111_WAKEPOL0);
NeoLKernel/arch/arm/common/sa1111.c:	save->wakepol1 = sa1111_readl(base + SA1111_WAKEPOL1);
NeoLKernel/arch/arm/common/sa1111.c:	save->wakeen0  = sa1111_readl(base + SA1111_WAKEEN0);
NeoLKernel/arch/arm/common/sa1111.c:	save->wakeen1  = sa1111_readl(base + SA1111_WAKEEN1);
NeoLKernel/arch/arm/common/sa1111.c:	 * First of all, wake up the chip.
NeoLKernel/arch/arm/common/sa1111.c:	sa1111_wake(sachip);
NeoLKernel/arch/arm/common/sa1111.c:	sa1111_writel(save->wakepol0, base + SA1111_WAKEPOL0);
NeoLKernel/arch/arm/common/sa1111.c:	sa1111_writel(save->wakepol1, base + SA1111_WAKEPOL1);
NeoLKernel/arch/arm/common/sa1111.c:	sa1111_writel(save->wakeen0,  base + SA1111_WAKEEN0);
NeoLKernel/arch/arm/common/sa1111.c:	sa1111_writel(save->wakeen1,  base + SA1111_WAKEEN1);
NeoLKernel/arch/arm/common/vic.c:static int vic_set_wake(unsigned int irq, unsigned int on)
NeoLKernel/arch/arm/common/vic.c:#define vic_set_wake NULL
NeoLKernel/arch/arm/common/vic.c:	.set_wake = vic_set_wake,
NeoLKernel/arch/arm/include/asm/locks.h:#define __up_op(ptr,wake)			\
NeoLKernel/arch/arm/include/asm/locks.h:"	blle	" #wake				\
NeoLKernel/arch/arm/include/asm/locks.h:#define __up_op_write(ptr,wake)			\
NeoLKernel/arch/arm/include/asm/locks.h:"	blcs	" #wake				\
NeoLKernel/arch/arm/include/asm/locks.h:#define __up_op_read(ptr,wake)			\
NeoLKernel/arch/arm/include/asm/locks.h:"	bleq	" #wake				\
NeoLKernel/arch/arm/include/asm/locks.h:#define __up_op(ptr,wake)			\
NeoLKernel/arch/arm/include/asm/locks.h:"	blle	" #wake				\
NeoLKernel/arch/arm/include/asm/locks.h:#define __up_op_write(ptr,wake)			\
NeoLKernel/arch/arm/include/asm/locks.h:"	blcs	" #wake				\
NeoLKernel/arch/arm/include/asm/locks.h:#define __up_op_read(ptr,wake)			\
NeoLKernel/arch/arm/include/asm/locks.h:"	bleq	" #wake				\
NeoLKernel/arch/arm/include/asm/mach/mmc.h:        unsigned int sdiowakeup_irq;
NeoLKernel/arch/arm/include/asm/mach/serial_at91.h:	int	(*set_wake)(struct uart_port *, u_int);
NeoLKernel/arch/arm/include/asm/mach/serial_sa1100.h:	int	(*set_wake)(struct uart_port *, u_int);
NeoLKernel/arch/arm/kernel/.init_task.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/kernel/.time.o.cmd:  include/linux/pm_wakeup.h \
Binary file NeoLKernel/arch/arm/kernel/irq.o matches
Binary file NeoLKernel/arch/arm/kernel/module.o matches
NeoLKernel/arch/arm/kernel/process.c: * interrupts here to ensure we don't miss a wakeup call.
Binary file NeoLKernel/arch/arm/kernel/process.o matches
NeoLKernel/arch/arm/kernel/ptrace.c:			wake_up_process(child);
NeoLKernel/arch/arm/kernel/ptrace.c:				wake_up_process(child);
NeoLKernel/arch/arm/kernel/ptrace.c:			wake_up_process(child);
Binary file NeoLKernel/arch/arm/kernel/ptrace.o matches
Binary file NeoLKernel/arch/arm/kernel/setup.o matches
NeoLKernel/arch/arm/kernel/ecard.c:	wake_up(&ecard_wait);
Binary file NeoLKernel/arch/arm/kernel/elf.o matches
Binary file NeoLKernel/arch/arm/kernel/init_task.o matches
Binary file NeoLKernel/arch/arm/kernel/signal.o matches
Binary file NeoLKernel/arch/arm/kernel/stacktrace.o matches
Binary file NeoLKernel/arch/arm/kernel/sys_arm.o matches
Binary file NeoLKernel/arch/arm/kernel/sys_oabi-compat.o matches
Binary file NeoLKernel/arch/arm/kernel/time.o matches
Binary file NeoLKernel/arch/arm/kernel/traps.o matches
Binary file NeoLKernel/arch/arm/kernel/unwind.o matches
Binary file NeoLKernel/arch/arm/kernel/armksyms.o matches
NeoLKernel/arch/arm/kernel/asm-offsets.s:	.ascii	"last_wakeup\000"
NeoLKernel/arch/arm/kernel/asm-offsets.s:	.ascii	"avg_wakeup\000"
Binary file NeoLKernel/arch/arm/kernel/built-in.o matches
Binary file NeoLKernel/arch/arm/kernel/crash_notes.o matches
NeoLKernel/arch/arm/mach-at91/board-cpu9krea.c:		.wakeup		= 1,
NeoLKernel/arch/arm/mach-at91/board-cpu9krea.c:		.wakeup		= 1,
NeoLKernel/arch/arm/mach-at91/board-csb337.c:		.wakeup		= 1,
NeoLKernel/arch/arm/mach-at91/board-csb337.c:		.wakeup		= 1,
NeoLKernel/arch/arm/mach-at91/board-csb337.c:		.wakeup		= 1,
NeoLKernel/arch/arm/mach-at91/board-neocore926.c:		.wakeup		= 1,
NeoLKernel/arch/arm/mach-at91/board-neocore926.c:		.wakeup		= 1,
NeoLKernel/arch/arm/mach-at91/board-qil-a9260.c:		.wakeup		= 1,
NeoLKernel/arch/arm/mach-at91/board-qil-a9260.c:	/* shutdown controller, wakeup button (5 msec low) */
NeoLKernel/arch/arm/mach-at91/board-sam9260ek.c:		.wakeup		= 1,
NeoLKernel/arch/arm/mach-at91/board-sam9260ek.c:		.wakeup		= 1,
NeoLKernel/arch/arm/mach-at91/board-sam9261ek.c:		.wakeup		= 1,
NeoLKernel/arch/arm/mach-at91/board-sam9261ek.c:		.wakeup		= 1,
NeoLKernel/arch/arm/mach-at91/board-sam9261ek.c:		.wakeup		= 1,
NeoLKernel/arch/arm/mach-at91/board-sam9261ek.c:		.wakeup		= 1,
NeoLKernel/arch/arm/mach-at91/board-sam9263ek.c:		.wakeup		= 1,
NeoLKernel/arch/arm/mach-at91/board-sam9263ek.c:		.wakeup		= 1,
NeoLKernel/arch/arm/mach-at91/board-sam9g20ek.c:		.wakeup		= 1,
NeoLKernel/arch/arm/mach-at91/board-sam9g20ek.c:		.wakeup		= 1,
NeoLKernel/arch/arm/mach-at91/board-sam9m10g45ek.c:		.wakeup		= 1,
NeoLKernel/arch/arm/mach-at91/board-sam9m10g45ek.c:		.wakeup		= 1,
NeoLKernel/arch/arm/mach-at91/board-sam9rlek.c:		.wakeup		= 1,
NeoLKernel/arch/arm/mach-at91/board-sam9rlek.c:		.wakeup		= 1,
NeoLKernel/arch/arm/mach-at91/board-usb-a9260.c:		.wakeup		= 1,
NeoLKernel/arch/arm/mach-at91/board-usb-a9260.c:	/* shutdown controller, wakeup button (5 msec low) */
NeoLKernel/arch/arm/mach-at91/board-usb-a9263.c:		.wakeup		= 1,
NeoLKernel/arch/arm/mach-at91/board-usb-a9263.c:	/* shutdown controller, wakeup button (5 msec low) */
NeoLKernel/arch/arm/mach-at91/board-yl-9200.c:		.wakeup		= 1,
NeoLKernel/arch/arm/mach-at91/board-yl-9200.c:		.wakeup		= 1,
NeoLKernel/arch/arm/mach-at91/board-yl-9200.c:		.wakeup		= 1,
NeoLKernel/arch/arm/mach-at91/board-yl-9200.c:		.wakeup		= 1,
NeoLKernel/arch/arm/mach-at91/gpio.c:static u32 wakeups[MAX_GPIO_BANKS];
NeoLKernel/arch/arm/mach-at91/gpio.c:static int gpio_irq_set_wake(unsigned pin, unsigned state)
NeoLKernel/arch/arm/mach-at91/gpio.c:		wakeups[bank] |= mask;
NeoLKernel/arch/arm/mach-at91/gpio.c:		wakeups[bank] &= ~mask;
NeoLKernel/arch/arm/mach-at91/gpio.c:	set_irq_wake(gpio_chip[bank].bank->id, state);
NeoLKernel/arch/arm/mach-at91/gpio.c:		__raw_writel(wakeups[i], pio + PIO_IER);
NeoLKernel/arch/arm/mach-at91/gpio.c:		if (!wakeups[i])
NeoLKernel/arch/arm/mach-at91/gpio.c:			printk(KERN_DEBUG "GPIO-%c may wake for %08x\n", 'A'+i, wakeups[i]);
NeoLKernel/arch/arm/mach-at91/gpio.c:		if (!wakeups[i])
NeoLKernel/arch/arm/mach-at91/gpio.c:		__raw_writel(wakeups[i], pio + PIO_IDR);
NeoLKernel/arch/arm/mach-at91/gpio.c:#define gpio_irq_set_wake	NULL
NeoLKernel/arch/arm/mach-at91/gpio.c:	.set_wake	= gpio_irq_set_wake,
NeoLKernel/arch/arm/mach-at91/irq.c:static u32 wakeups;
NeoLKernel/arch/arm/mach-at91/irq.c:static int at91_aic_set_wake(unsigned irq, unsigned value)
NeoLKernel/arch/arm/mach-at91/irq.c:		wakeups |= (1 << irq);
NeoLKernel/arch/arm/mach-at91/irq.c:		wakeups &= ~(1 << irq);
NeoLKernel/arch/arm/mach-at91/irq.c:	at91_sys_write(AT91_AIC_IECR, wakeups);
NeoLKernel/arch/arm/mach-at91/irq.c:	at91_sys_write(AT91_AIC_IDCR, wakeups);
NeoLKernel/arch/arm/mach-at91/irq.c:#define at91_aic_set_wake	NULL
NeoLKernel/arch/arm/mach-at91/irq.c:	.set_wake	= at91_aic_set_wake,
NeoLKernel/arch/arm/mach-at91/Kconfig:	  functionality.  Many can't issue wakeup events unless faster
NeoLKernel/arch/arm/mach-at91/pm.c:	static char wakeup[] __initdata = "wakeup";
NeoLKernel/arch/arm/mach-at91/pm.c:	u32 reset_type, wake_type;
NeoLKernel/arch/arm/mach-at91/pm.c:	wake_type = at91_sys_read(AT91_SHDW_SR);
NeoLKernel/arch/arm/mach-at91/pm.c:		/* board-specific code enabled the wakeup sources */
NeoLKernel/arch/arm/mach-at91/pm.c:		reason = wakeup;
NeoLKernel/arch/arm/mach-at91/pm.c:		/* "wakeup signal" */
NeoLKernel/arch/arm/mach-at91/pm.c:		if (wake_type & AT91_SHDW_WAKEUP0)
NeoLKernel/arch/arm/mach-at91/pm.c:			if (wake_type & AT91_SHDW_RTTWK)	/* rtt wakeup */
NeoLKernel/arch/arm/mach-at91/pm.c:			else if (wake_type & AT91_SHDW_RTCWK)	/* rtc wakeup */
NeoLKernel/arch/arm/mach-at91/pm.c:			else if (wake_type == 0)	/* power-restored wakeup */
NeoLKernel/arch/arm/mach-at91/pm.c:			else				/* unknown wakeup */
NeoLKernel/arch/arm/mach-at91/pm.c: * in order to act as a wakeup source, and those are not available when
NeoLKernel/arch/arm/mach-at91/pm.c:	pr_debug("AT91: PM - wake mask %08x, pm state %d\n",
NeoLKernel/arch/arm/mach-at91/pm.c:			/* remember all the always-wake irqs */
NeoLKernel/arch/arm/mach-at91/pm.c:			 * turning off the main oscillator; reverse on wakeup.
NeoLKernel/arch/arm/mach-at91/pm.c:		 * marked as 'wakeup' event sources; and reduces DRAM power.
NeoLKernel/arch/arm/mach-at91/pm.c:			 * wakeup IRQ occurs and self-refresh is terminated.
NeoLKernel/arch/arm/mach-at91/pm.c:	pr_debug("AT91: PM - wakeup %08x\n",
NeoLKernel/arch/arm/mach-bcmring/dma.c:	wake_up_interruptible(&gDMA.freeChannelQ);
NeoLKernel/arch/arm/mach-davinci/gpio.c: * suspend_late/resume_resume calls hooking into results of the set_wake()
NeoLKernel/arch/arm/mach-davinci/gpio.c: * calls ... so if no gpios are wakeup events the clock can be disabled,
NeoLKernel/arch/arm/mach-ep93xx/gpio.c:							? " wakeup" : "");
NeoLKernel/arch/arm/mach-fsm/board-comet.c:	.wakeup_irq = MSM_GPIO_TO_INT(45),
NeoLKernel/arch/arm/mach-fsm/board-comet.c:	.inject_rx_on_wakeup = 1,
NeoLKernel/arch/arm/mach-fsm/board-comet.c:		.name	= "gpio_host_wake",
NeoLKernel/arch/arm/mach-fsm/board-comet.c:		.name	= "gpio_ext_wake",
NeoLKernel/arch/arm/mach-fsm/board-comet.c:		.name	= "host_wake",
NeoLKernel/arch/arm/mach-fsm/board-halibut.c:		.name	= "gpio_host_wake",
NeoLKernel/arch/arm/mach-fsm/board-halibut.c:		.name	= "gpio_ext_wake",
NeoLKernel/arch/arm/mach-fsm/board-halibut.c:		.name	= "host_wake",
NeoLKernel/arch/arm/mach-fsm/board-mahimahi-flashlight.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-fsm/board-mahimahi-microp.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-fsm/board-mahimahi-microp.c:static struct wake_lock microp_i2c_wakelock;
NeoLKernel/arch/arm/mach-fsm/board-mahimahi-microp.c:		wake_lock_timeout(&microp_i2c_wakelock, 3*HZ);
NeoLKernel/arch/arm/mach-fsm/board-mahimahi-microp.c:	wake_lock_init(&microp_i2c_wakelock, WAKE_LOCK_SUSPEND,
NeoLKernel/arch/arm/mach-fsm/board-mahimahi-microp.c:	ret = set_irq_wake(client->irq, 1);
NeoLKernel/arch/arm/mach-fsm/board-mahimahi-microp.c:		dev_err(&client->dev, "set_irq_wake failed\n");
NeoLKernel/arch/arm/mach-fsm/board-mahimahi-microp.c:	wake_lock_destroy(&microp_i2c_wakelock);
NeoLKernel/arch/arm/mach-fsm/board-mahimahi-mmc.c:		set_irq_wake(MSM_GPIO_TO_INT(MAHIMAHI_GPIO_SDMC_CD_REV0_N), 1);
NeoLKernel/arch/arm/mach-fsm/board-mahimahi.c:	.gpio_a1026_wakeup = MAHIMAHI_AUD_A1026_WAKEUP,
NeoLKernel/arch/arm/mach-fsm/board-mahimahi.c:	.rx_wakeup_irq = -1,
NeoLKernel/arch/arm/mach-fsm/board-mahimahi.c:	.inject_rx_on_wakeup = 0,
NeoLKernel/arch/arm/mach-fsm/board-mahimahi.c:	.gpio_wake = MAHIMAHI_GPIO_BT_WAKE,
NeoLKernel/arch/arm/mach-fsm/board-mahimahi.c:	.gpio_host_wake = MAHIMAHI_GPIO_BT_HOST_WAKE,
NeoLKernel/arch/arm/mach-fsm/board-mahimahi.c:		bcm_bt_lpm_pdata.gpio_wake = MAHIMAHI_CDMA_GPIO_BT_WAKE;
NeoLKernel/arch/arm/mach-fsm/board-mahimahi.c:			a1026_data.gpio_a1026_wakeup = MAHIMAHI_CDMA_XB_AUD_A1026_WAKEUP;
NeoLKernel/arch/arm/mach-fsm/msm7200a-gpio.c:static int msm_gpio_irq_set_wake(unsigned int irq, unsigned int on)
NeoLKernel/arch/arm/mach-fsm/msm7200a-gpio.c:	return set_irq_wake(msm_gpio->irq_summary, on);
NeoLKernel/arch/arm/mach-fsm/msm7200a-gpio.c:	.set_wake		= msm_gpio_irq_set_wake,
NeoLKernel/arch/arm/mach-fsm/msm8660-gpio.c: * @wake_irqs: a bitmap for tracking which interrupt lines are enabled
NeoLKernel/arch/arm/mach-fsm/msm8660-gpio.c: * as wakeup sources.  When the device is suspended, interrupts which are
NeoLKernel/arch/arm/mach-fsm/msm8660-gpio.c: * not wakeup sources are disabled.
NeoLKernel/arch/arm/mach-fsm/msm8660-gpio.c:	DECLARE_BITMAP(wake_irqs, NR_MSM_GPIOS);
NeoLKernel/arch/arm/mach-fsm/msm8660-gpio.c:static int msm_gpio_irq_set_wake(unsigned int irq, unsigned int on)
NeoLKernel/arch/arm/mach-fsm/msm8660-gpio.c:		set_bit(gpio, msm_gpio.wake_irqs);
NeoLKernel/arch/arm/mach-fsm/msm8660-gpio.c:		clear_bit(gpio, msm_gpio.wake_irqs);
NeoLKernel/arch/arm/mach-fsm/msm8660-gpio.c:	.set_wake	= msm_gpio_irq_set_wake,
NeoLKernel/arch/arm/mach-fsm/msm8660-gpio.c:	bitmap_zero(msm_gpio.wake_irqs, NR_MSM_GPIOS);
NeoLKernel/arch/arm/mach-fsm/dal.c:		wake_up_all(&event_wq);
NeoLKernel/arch/arm/mach-fsm/sdio_al.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-fsm/sdio_al.c: *  @wake_lock - Lock when can't sleep.
NeoLKernel/arch/arm/mach-fsm/sdio_al.c:	struct wake_lock wake_lock;
NeoLKernel/arch/arm/mach-fsm/sdio_al.c:		/* Release wakelock */
NeoLKernel/arch/arm/mach-fsm/sdio_al.c:		wake_unlock(&sdio_al->wake_lock);
NeoLKernel/arch/arm/mach-fsm/sdio_al.c:		wake_up(&sdio_al->wait_mbox);
NeoLKernel/arch/arm/mach-fsm/sdio_al.c: *  2. Enable wake up function if needed
NeoLKernel/arch/arm/mach-fsm/sdio_al.c:static int sdio_al_wake_up(u32 enable_wake_up_func, int is_host_claimed)
NeoLKernel/arch/arm/mach-fsm/sdio_al.c:	wake_lock(&sdio_al->wake_lock);
NeoLKernel/arch/arm/mach-fsm/sdio_al.c:	if (enable_wake_up_func) {
NeoLKernel/arch/arm/mach-fsm/sdio_al.c:		ret = sdio_al_enable_func_retry(wk_func, "wakeup func");
NeoLKernel/arch/arm/mach-fsm/sdio_al.c:	if (enable_wake_up_func)
NeoLKernel/arch/arm/mach-fsm/sdio_al.c:		sdio_al_wake_up(0, 1);
NeoLKernel/arch/arm/mach-fsm/sdio_al.c:		wake_unlock(&sdio_al->wake_lock);
NeoLKernel/arch/arm/mach-fsm/sdio_al.c:		ret = sdio_al_wake_up(1, 0);
NeoLKernel/arch/arm/mach-fsm/sdio_al.c:		ret = sdio_al_wake_up(1, 0);
NeoLKernel/arch/arm/mach-fsm/sdio_al.c:		ret = sdio_al_wake_up(1, 0);
NeoLKernel/arch/arm/mach-fsm/sdio_al.c:		ret = sdio_al_wake_up(1, 0);
NeoLKernel/arch/arm/mach-fsm/sdio_al.c:		ret = sdio_al_wake_up(1, 0);
NeoLKernel/arch/arm/mach-fsm/sdio_al.c:		ret = sdio_al_wake_up(1, 0);
NeoLKernel/arch/arm/mach-fsm/sdio_al.c:	wake_lock_init(&sdio_al->wake_lock, WAKE_LOCK_SUSPEND, MODULE_NAME);
NeoLKernel/arch/arm/mach-fsm/sdio_al.c:	wake_lock(&sdio_al->wake_lock);
NeoLKernel/arch/arm/mach-fsm/sdio_al_test.c:		wake_up(&test_ctx->wait_q);
NeoLKernel/arch/arm/mach-fsm/sdio_al_test.c:		wake_up(&test_ctx->wait_q);
NeoLKernel/arch/arm/mach-fsm/sdio_ctl.c:	wake_up(&sdio_ctl_devp[id]->read_wait_queue);
NeoLKernel/arch/arm/mach-fsm/sdio_ctl.c:	wake_up(&write_wait_queue);
NeoLKernel/arch/arm/mach-fsm/sdio_ctl.c:		wake_up(&sdio_ctl_devp[id]->open_wait_queue);
NeoLKernel/arch/arm/mach-fsm/sdio_ctl.c:		wake_up(&sdio_ctl_devp[id]->read_wait_queue);
NeoLKernel/arch/arm/mach-fsm/sdio_ctl.c:		wake_up(&write_wait_queue);
NeoLKernel/arch/arm/mach-fsm/sirc.c:static int sirc_irq_set_wake(unsigned int irq, unsigned int on);
NeoLKernel/arch/arm/mach-fsm/sirc.c:static unsigned int wake_enable;
NeoLKernel/arch/arm/mach-fsm/sirc.c:static int sirc_irq_set_wake(unsigned int irq, unsigned int on)
NeoLKernel/arch/arm/mach-fsm/sirc.c:		wake_enable |= mask;
NeoLKernel/arch/arm/mach-fsm/sirc.c:		wake_enable &= ~mask;
NeoLKernel/arch/arm/mach-fsm/sirc.c:	writel(wake_enable, sirc_regs.int_enable);
NeoLKernel/arch/arm/mach-fsm/sirc.c:	.set_wake  = sirc_irq_set_wake,
NeoLKernel/arch/arm/mach-fsm/sirc.c:	wake_enable = 0;
NeoLKernel/arch/arm/mach-fsm/sirc.c:		set_irq_wake(sirc_reg_table[i].cascade_irq, 1);
NeoLKernel/arch/arm/mach-fsm/smd.c:	r = enable_irq_wake(INT_A9_M2A_0);
NeoLKernel/arch/arm/mach-fsm/smd.c:		       "enable_irq_wake failed for INT_A9_M2A_0\n");
NeoLKernel/arch/arm/mach-fsm/smd.c:	r = enable_irq_wake(INT_A9_M2A_5);
NeoLKernel/arch/arm/mach-fsm/smd.c:		       "enable_irq_wake failed for INT_A9_M2A_5\n");
NeoLKernel/arch/arm/mach-fsm/smd.c:	r = enable_irq_wake(INT_ADSP_A11);
NeoLKernel/arch/arm/mach-fsm/smd.c:		       "enable_irq_wake failed for INT_ADSP_A11\n");
NeoLKernel/arch/arm/mach-fsm/smd.c:	r = enable_irq_wake(INT_DSPS_A11);
NeoLKernel/arch/arm/mach-fsm/smd.c:		       "enable_irq_wake failed for INT_ADSP_A11\n");
NeoLKernel/arch/arm/mach-fsm/smd_debug.c:	uint32_t irq_mask, uint32_t wakeup_reason, uint32_t pending_irqs)
NeoLKernel/arch/arm/mach-fsm/smd_debug.c:		irq_mask, pending_irqs, wakeup_reason);
NeoLKernel/arch/arm/mach-fsm/smd_nmea.c:		wake_up_interruptible(&nmea_wait_queue);
NeoLKernel/arch/arm/mach-fsm/smd_pkt.c:static void check_and_wakeup(struct smd_pkt_dev *smd_pkt_devp);
NeoLKernel/arch/arm/mach-fsm/smd_pkt.c:	wake_up_interruptible(&smd_pkt_devp->ch_wait_queue);
NeoLKernel/arch/arm/mach-fsm/smd_pkt.c:	wake_up_interruptible(&smd_pkt_devp->ch_opened_wait_queue);
NeoLKernel/arch/arm/mach-fsm/smd_pkt.c:	/* check and wakeup read threads waiting on this device */
NeoLKernel/arch/arm/mach-fsm/smd_pkt.c:	check_and_wakeup(smd_pkt_devp);
NeoLKernel/arch/arm/mach-fsm/smd_pkt.c:static void check_and_wakeup(struct smd_pkt_dev *smd_pkt_devp)
NeoLKernel/arch/arm/mach-fsm/smd_pkt.c:	wake_up_interruptible(&smd_pkt_devp->ch_wait_queue);
NeoLKernel/arch/arm/mach-fsm/smd_pkt.c:	D(KERN_ERR "%s: after wake_up\n", __func__);
NeoLKernel/arch/arm/mach-fsm/smd_pkt.c:		check_and_wakeup(smd_pkt_devp);
NeoLKernel/arch/arm/mach-fsm/smd_pkt.c:		D(KERN_ERR "%s: data after check_and_wakeup\n", __func__);
NeoLKernel/arch/arm/mach-fsm/smd_pkt.c:		wake_up_interruptible(&smd_pkt_devp->ch_opened_wait_queue);
NeoLKernel/arch/arm/mach-fsm/smd_private.h:	uint32_t aArm_wakeup_reason;
NeoLKernel/arch/arm/mach-fsm/smd_private.h:  uint32_t aArm_wakeup_reason;
NeoLKernel/arch/arm/mach-fsm/smd_private.h:	uint32_t irq_mask, uint32_t wakeup_reason, uint32_t pending_irqs);
NeoLKernel/arch/arm/mach-fsm/smd_qmi.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-fsm/smd_qmi.c:	struct wake_lock wake_lock;
NeoLKernel/arch/arm/mach-fsm/smd_qmi.c:	wake_lock_init(&ctxt->wake_lock, WAKE_LOCK_SUSPEND, ctxt->misc.name);
NeoLKernel/arch/arm/mach-fsm/smd_qmi.c:	wake_up(&qmi_wait_queue);
NeoLKernel/arch/arm/mach-fsm/smd_qmi.c:			wake_lock_timeout(&ctxt->wake_lock, HZ / 2);
NeoLKernel/arch/arm/mach-fsm/smd_qmi.c:		wake_up(&qmi_wait_queue);
NeoLKernel/arch/arm/mach-fsm/smd_qmi.c:		wake_up(&qmi_wait_queue);
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter.c:	struct wake_lock wakelock;
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter.c:			wake_up(&ept->wait_q);
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter.c:		wake_up(&r_ept->quota_wait);
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter.c:	wake_lock_init(&ept->read_q_wake_lock, WAKE_LOCK_SUSPEND, "rpc_read");
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter.c:	wake_lock_init(&ept->reply_q_wake_lock, WAKE_LOCK_SUSPEND, "rpc_reply");
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter.c:	wake_lock_destroy(&ept->read_q_wake_lock);
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter.c:	wake_lock_destroy(&ept->reply_q_wake_lock);
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter.c:		wake_up(&r_ept->quota_wait);
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter.c:			wake_up(&ept->restart_wait);
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter.c:			wake_up(&ept->wait_q);
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter.c:		wake_up(&r_ept->quota_wait);
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter.c:			wake_up(&newserver_wait);
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter.c:		wake_unlock(&xprt_info->wakelock);
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter.c:	wake_lock(&ept->read_q_wake_lock);
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter.c:	wake_up(&ept->wait_q);
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter.c:		wake_lock(&ept->reply_q_wake_lock);
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter.c:	/* if reply, release wakelock after writing to the transport */
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter.c:			wake_unlock(&ept->reply_q_wake_lock);
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter.c:	/* release read wakelock after taking reply wakelock */
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter.c:		wake_unlock(&ept->read_q_wake_lock);
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter.c:	wake_lock_init(&xprt_info->wakelock,
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter.c:		wake_lock(&xprt_info->wakelock);
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter.c:	wake_up(&xprt_info->read_wait);
NeoLKernel/arch/arm/mach-fsm/board-trout.c:	.wakeup_irq = MSM_GPIO_TO_INT(45),
NeoLKernel/arch/arm/mach-fsm/board-trout.c:	.inject_rx_on_wakeup = 1,
NeoLKernel/arch/arm/mach-fsm/board-trout.c:	/* SD card door should wake the device */
NeoLKernel/arch/arm/mach-fsm/board-trout.c:	set_irq_wake(TROUT_GPIO_TO_INT(TROUT_GPIO_SD_DOOR_N), 1);
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter.h:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter.h:	struct wake_lock read_q_wake_lock;
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter.h:	struct wake_lock reply_q_wake_lock;
NeoLKernel/arch/arm/mach-fsm/board-msm7x27.c:		.name	= "gpio_host_wake",
NeoLKernel/arch/arm/mach-fsm/board-msm7x27.c:		.name	= "gpio_ext_wake",
NeoLKernel/arch/arm/mach-fsm/board-msm7x27.c:		.name	= "host_wake",
NeoLKernel/arch/arm/mach-fsm/board-msm7x27.c:	.sdiowakeup_irq = MSM_GPIO_TO_INT(66),
NeoLKernel/arch/arm/mach-fsm/board-msm7x30.c:	/* add any special code to strobe a wakeup pin or chip reset */
NeoLKernel/arch/arm/mach-fsm/board-msm7x30.c:	.wakeup			= 1,
NeoLKernel/arch/arm/mach-fsm/board-msm7x30.c:	.wakeup			= 1,
NeoLKernel/arch/arm/mach-fsm/board-msm7x30.c:	.can_wakeup	= false,
NeoLKernel/arch/arm/mach-fsm/board-msm7x30.c:	.can_wakeup	= false,
NeoLKernel/arch/arm/mach-fsm/board-msm7x30.c:       .inject_rx_on_wakeup = 1,
NeoLKernel/arch/arm/mach-fsm/board-msm7x30.c:	.sdiowakeup_irq = MSM_GPIO_TO_INT(118),
NeoLKernel/arch/arm/mach-fsm/board-msm7x30.c:	.awake_vlevel = 0xF2,
NeoLKernel/arch/arm/mach-fsm/board-msm7x30.c:	.wakeup = 1,
NeoLKernel/arch/arm/mach-fsm/board-msm7x30.c:	msm_uart_dm1_pdata.wakeup_irq = gpio_to_irq(136);
NeoLKernel/arch/arm/mach-fsm/board-msm8x60.c:		.awake_vlevel = 0x9C,
NeoLKernel/arch/arm/mach-fsm/board-msm8x60.c:		.awake_vlevel = 0x9C,
NeoLKernel/arch/arm/mach-fsm/board-msm8x60.c:       .inject_rx_on_wakeup = 1,
NeoLKernel/arch/arm/mach-fsm/board-msm8x60.c:	.wakeup			= 1,
NeoLKernel/arch/arm/mach-fsm/board-msm8x60.c:	.wakeup			= 1,
NeoLKernel/arch/arm/mach-fsm/board-msm8x60.c:	.othc_wakeup = 1,
NeoLKernel/arch/arm/mach-fsm/board-msm8x60.c:	.tdisc_wakeup  = 1,
NeoLKernel/arch/arm/mach-fsm/board-msm8x60.c:	msm_uart_dm1_pdata.wakeup_irq = gpio_to_irq(54); /* GSBI6(2) */
NeoLKernel/arch/arm/mach-fsm/board-qsd8x50.c:		.name	= "gpio_host_wake",
NeoLKernel/arch/arm/mach-fsm/board-qsd8x50.c:		.name	= "gpio_ext_wake",
NeoLKernel/arch/arm/mach-fsm/board-qsd8x50.c:		.name	= "host_wake",
NeoLKernel/arch/arm/mach-fsm/board-qsd8x50a-st1x.c:		.wakeup		= 1
NeoLKernel/arch/arm/mach-fsm/board-qsd8x50a-st1x.c:		.name	= "gpio_host_wake",
NeoLKernel/arch/arm/mach-fsm/board-qsd8x50a-st1x.c:		.name	= "gpio_ext_wake",
NeoLKernel/arch/arm/mach-fsm/board-qsd8x50a-st1x.c:		.name	= "host_wake",
NeoLKernel/arch/arm/mach-fsm/board-sapphire-gpio.c:/*Sleep have to prepare the wake up source in advance.
NeoLKernel/arch/arm/mach-fsm/board-sapphire-gpio.c:default to disable all wakeup sources when suspend.*/
NeoLKernel/arch/arm/mach-fsm/board-sapphire-gpio.c:/*preparing enable/disable wake source before sleep*/
NeoLKernel/arch/arm/mach-fsm/board-sapphire-gpio.c:int sapphire_gpio_irq_set_wake(unsigned int irq, unsigned int on)
NeoLKernel/arch/arm/mach-fsm/board-sapphire-gpio.c:	if (on)	/*wake on -> mask the bit*/
NeoLKernel/arch/arm/mach-fsm/board-sapphire-gpio.c:	else	/*no wake -> unmask the bit*/
NeoLKernel/arch/arm/mach-fsm/board-sapphire-gpio.c:	.set_wake  = sapphire_gpio_irq_set_wake,
NeoLKernel/arch/arm/mach-fsm/board-sapphire-gpio.c:	set_irq_wake(MSM_GPIO_TO_INT(17), 1);
NeoLKernel/arch/arm/mach-fsm/board-sapphire-h2w.c:	ret = set_irq_wake(hi->irq, 1);
NeoLKernel/arch/arm/mach-fsm/board-sapphire-h2w.c:	ret = set_irq_wake(hi->irq_btn, 1);
NeoLKernel/arch/arm/mach-fsm/board-sapphire-mmc.c:	set_irq_wake(SAPPHIRE_GPIO_TO_INT(SAPPHIRE_GPIO_SDMC_CD_N), 1);
NeoLKernel/arch/arm/mach-fsm/board-sapphire.c:/* a new search button to be a wake-up source */
NeoLKernel/arch/arm/mach-fsm/board-sapphire.c:	.wakeup_irq = MSM_GPIO_TO_INT(45),
NeoLKernel/arch/arm/mach-fsm/board-sapphire.c:	.inject_rx_on_wakeup = 1,
NeoLKernel/arch/arm/mach-fsm/board-trout-gpio.c:int trout_gpio_irq_set_wake(unsigned int irq, unsigned int on)
NeoLKernel/arch/arm/mach-fsm/board-trout-gpio.c:	.set_wake  = trout_gpio_irq_set_wake,
NeoLKernel/arch/arm/mach-fsm/board-trout-gpio.c:	set_irq_wake(MSM_GPIO_TO_INT(17), 1);
NeoLKernel/arch/arm/mach-fsm/board-trout-mmc.c:	set_irq_wake(TROUT_GPIO_TO_INT(TROUT_GPIO_SDMC_CD_N), 1);
NeoLKernel/arch/arm/mach-fsm/gpio_chip.h:	unsigned int            int_enable[2]; /* 0: awake, 1: sleep */
NeoLKernel/arch/arm/mach-fsm/htc_35mm_jack.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-fsm/htc_35mm_jack.c:	struct wake_lock headset_wake_lock;
NeoLKernel/arch/arm/mach-fsm/htc_35mm_jack.c:	wake_lock_timeout(&hi->headset_wake_lock, 1.5*HZ);
NeoLKernel/arch/arm/mach-fsm/htc_35mm_jack.c:	wake_lock_timeout(&hi->headset_wake_lock, 2.5*HZ);
NeoLKernel/arch/arm/mach-fsm/htc_35mm_jack.c:	wake_lock_timeout(&hi->headset_wake_lock, 1.5*HZ);
NeoLKernel/arch/arm/mach-fsm/htc_35mm_jack.c:	wake_lock_init(&hi->headset_wake_lock, WAKE_LOCK_SUSPEND, "headset");
NeoLKernel/arch/arm/mach-fsm/htc_battery.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-fsm/htc_battery.c:static struct wake_lock vbus_wake_lock;
NeoLKernel/arch/arm/mach-fsm/htc_battery.c:		wake_lock(&vbus_wake_lock);
NeoLKernel/arch/arm/mach-fsm/htc_battery.c:		wake_lock_timeout(&vbus_wake_lock, HZ / 2);
NeoLKernel/arch/arm/mach-fsm/htc_battery.c:	wake_lock_init(&vbus_wake_lock, WAKE_LOCK_SUSPEND, "vbus_present");
NeoLKernel/arch/arm/mach-fsm/htc_headset.c:	ret = set_irq_wake(hi->irq, 1);
NeoLKernel/arch/arm/mach-fsm/htc_headset.c:	ret = set_irq_wake(hi->irq_btn, 1);
NeoLKernel/arch/arm/mach-fsm/htc_power_supply.c:static struct wake_lock dock_work_wake_lock;
NeoLKernel/arch/arm/mach-fsm/htc_power_supply.c:	wake_unlock(&dock_work_wake_lock);
NeoLKernel/arch/arm/mach-fsm/htc_power_supply.c:	wake_lock(&dock_work_wake_lock);
NeoLKernel/arch/arm/mach-fsm/htc_power_supply.c:	wake_lock_init(&dock_work_wake_lock, WAKE_LOCK_SUSPEND, "dock");
NeoLKernel/arch/arm/mach-fsm/hw3d.c:	wake_up(&hw3d_queue);
NeoLKernel/arch/arm/mach-fsm/hw3d.c:		wake_unlock(&info->wake_lock);
NeoLKernel/arch/arm/mach-fsm/hw3d.c:	wake_up(&info->revoke_done_wq);
NeoLKernel/arch/arm/mach-fsm/hw3d.c:	wake_lock(&info->wake_lock);
NeoLKernel/arch/arm/mach-fsm/hw3d.c:	wake_up(&info->revoke_wq);
NeoLKernel/arch/arm/mach-fsm/include/mach/bcm_bt_lpm.h:	unsigned int gpio_wake;   /* CPU -> BCM wakeup gpio */
NeoLKernel/arch/arm/mach-fsm/include/mach/bcm_bt_lpm.h:	unsigned int gpio_host_wake;  /* BCM -> CPU wakeup gpio */
NeoLKernel/arch/arm/mach-fsm/include/mach/camera.h:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-fsm/include/mach/camera.h:	struct wake_lock wake_lock;
NeoLKernel/arch/arm/mach-fsm/include/mach/msm_otg.h:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-fsm/include/mach/msm_otg.h:	struct wake_lock	wlock;
NeoLKernel/arch/arm/mach-fsm/include/mach/msm_serial_debugger.h:		struct device *clk_device, int signal_irq, int wakeup_irq);
NeoLKernel/arch/arm/mach-fsm/include/mach/msm_serial_debugger.h:		struct device *clk_device, int signal_irq, int wakeup_irq) {}
NeoLKernel/arch/arm/mach-fsm/include/mach/msm_serial_hs.h: * Used to configure low power wakeup */
NeoLKernel/arch/arm/mach-fsm/include/mach/msm_serial_hs.h:	int wakeup_irq;  /* wakeup irq */
NeoLKernel/arch/arm/mach-fsm/include/mach/msm_serial_hs.h:	/* bool: inject char into rx tty on wakeup */
NeoLKernel/arch/arm/mach-fsm/include/mach/msm_serial_hs.h:	unsigned char inject_rx_on_wakeup;
NeoLKernel/arch/arm/mach-fsm/include/mach/msm_serial_pdata.h: * Used to configure low power wakeup */
NeoLKernel/arch/arm/mach-fsm/include/mach/msm_serial_pdata.h:	int wakeup_irq;  /* wakeup irq */
NeoLKernel/arch/arm/mach-fsm/include/mach/msm_serial_pdata.h:	/* bool: inject char into rx tty on wakeup */
NeoLKernel/arch/arm/mach-fsm/include/mach/msm_serial_pdata.h:	unsigned char inject_rx_on_wakeup;
NeoLKernel/arch/arm/mach-fsm/include/mach/rpc_hsusb.h:int msm_fsusb_set_remote_wakeup(void);
NeoLKernel/arch/arm/mach-fsm/include/mach/rpc_hsusb.h:static inline int msm_fsusb_set_remote_wakeup(void) { return 0; }
NeoLKernel/arch/arm/mach-fsm/include/mach/msm72k_otg.h:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-fsm/include/mach/msm72k_otg.h:	struct wake_lock wlock;
NeoLKernel/arch/arm/mach-fsm/irq-vic.c:static uint32_t msm_irq_smsm_wake_enable[2];
NeoLKernel/arch/arm/mach-fsm/irq-vic.c:	/* fake wakeup interrupts */
NeoLKernel/arch/arm/mach-fsm/irq-vic.c:		msm_irq_smsm_wake_enable[0] &= ~mask;
NeoLKernel/arch/arm/mach-fsm/irq-vic.c:		msm_irq_smsm_wake_enable[0] |= mask;
NeoLKernel/arch/arm/mach-fsm/irq-vic.c:static int msm_irq_set_wake(unsigned int irq, unsigned int on)
NeoLKernel/arch/arm/mach-fsm/irq-vic.c:		printk(KERN_ERR "msm_irq_set_wake: bad wakeup irq %d\n", irq);
NeoLKernel/arch/arm/mach-fsm/irq-vic.c:		msm_irq_smsm_wake_enable[1] |= mask;
NeoLKernel/arch/arm/mach-fsm/irq-vic.c:		msm_irq_smsm_wake_enable[1] &= ~mask;
NeoLKernel/arch/arm/mach-fsm/irq-vic.c: * If modem_wake is true, return currently enabled interrupts in *irq_mask.
NeoLKernel/arch/arm/mach-fsm/irq-vic.c:void msm_irq_enter_sleep1(bool modem_wake, int from_idle, uint32_t *irq_mask)
NeoLKernel/arch/arm/mach-fsm/irq-vic.c:	if (modem_wake) {
NeoLKernel/arch/arm/mach-fsm/irq-vic.c:		*irq_mask = msm_irq_smsm_wake_enable[!from_idle];
NeoLKernel/arch/arm/mach-fsm/irq-vic.c:int msm_irq_enter_sleep2(bool modem_wake, int from_idle)
NeoLKernel/arch/arm/mach-fsm/irq-vic.c:	if (from_idle && !modem_wake)
NeoLKernel/arch/arm/mach-fsm/irq-vic.c:	WARN_ON_ONCE(!modem_wake && !from_idle);
NeoLKernel/arch/arm/mach-fsm/irq-vic.c:	if (modem_wake) {
NeoLKernel/arch/arm/mach-fsm/irq-vic.c:void msm_irq_exit_sleep1(uint32_t irq_mask, uint32_t wakeup_reason,
NeoLKernel/arch/arm/mach-fsm/irq-vic.c:			__func__, irq_mask, pending_irqs, wakeup_reason);
NeoLKernel/arch/arm/mach-fsm/irq-vic.c:void msm_irq_exit_sleep2(uint32_t irq_mask, uint32_t wakeup_reason,
NeoLKernel/arch/arm/mach-fsm/irq-vic.c:			__func__, irq_mask, pending, wakeup_reason);
NeoLKernel/arch/arm/mach-fsm/irq-vic.c:void msm_irq_exit_sleep3(uint32_t irq_mask, uint32_t wakeup_reason,
NeoLKernel/arch/arm/mach-fsm/irq-vic.c:			__func__, irq_mask, pending_irqs, wakeup_reason,
NeoLKernel/arch/arm/mach-fsm/irq-vic.c:	.set_wake  = msm_irq_set_wake,
NeoLKernel/arch/arm/mach-fsm/irq.c:static uint32_t msm_irq_smsm_wake_enable[2];
NeoLKernel/arch/arm/mach-fsm/irq.c:	/* fake wakeup interrupts */
NeoLKernel/arch/arm/mach-fsm/irq.c:		msm_irq_smsm_wake_enable[0] &= ~mask;
NeoLKernel/arch/arm/mach-fsm/irq.c:		msm_irq_smsm_wake_enable[0] |= mask;
NeoLKernel/arch/arm/mach-fsm/irq.c:static int msm_irq_set_wake(unsigned int irq, unsigned int on)
NeoLKernel/arch/arm/mach-fsm/irq.c:		printk(KERN_ERR "msm_irq_set_wake: bad wakeup irq %d\n", irq);
NeoLKernel/arch/arm/mach-fsm/irq.c:		msm_irq_smsm_wake_enable[1] |= mask;
NeoLKernel/arch/arm/mach-fsm/irq.c:		msm_irq_smsm_wake_enable[1] &= ~mask;
NeoLKernel/arch/arm/mach-fsm/irq.c:/* If arm9_wake is set: pass control to the other core.
NeoLKernel/arch/arm/mach-fsm/irq.c: * If from_idle is not set: disable non-wakeup interrupts.
NeoLKernel/arch/arm/mach-fsm/irq.c:void msm_irq_enter_sleep1(bool arm9_wake, int from_idle)
NeoLKernel/arch/arm/mach-fsm/irq.c:	if (!arm9_wake || !smsm_int_info)
NeoLKernel/arch/arm/mach-fsm/irq.c:	smsm_int_info->interrupt_mask = msm_irq_smsm_wake_enable[!from_idle];
NeoLKernel/arch/arm/mach-fsm/irq.c:int msm_irq_enter_sleep2(bool arm9_wake, int from_idle)
NeoLKernel/arch/arm/mach-fsm/irq.c:	if (from_idle && !arm9_wake)
NeoLKernel/arch/arm/mach-fsm/irq.c:	WARN_ON_ONCE(!arm9_wake && !from_idle);
NeoLKernel/arch/arm/mach-fsm/irq.c:	if (arm9_wake) {
NeoLKernel/arch/arm/mach-fsm/irq.c:		       smsm_int_info->wakeup_reason,
NeoLKernel/arch/arm/mach-fsm/irq.c:		       smsm_int_info->wakeup_reason,
NeoLKernel/arch/arm/mach-fsm/irq.c:		       smsm_int_info->wakeup_reason, readl(VIC_IRQ_STATUS0),
NeoLKernel/arch/arm/mach-fsm/irq.c:	.set_wake  = msm_irq_set_wake,
NeoLKernel/arch/arm/mach-fsm/irq.c:		pr_err("set_wakeup_mask NO INT_INFO (%d)\n", INT_INFO_SMSM_ID);
NeoLKernel/arch/arm/mach-fsm/irq.h:void msm_irq_enter_sleep1(bool arm9_wake, int from_idle, uint32_t *irq_mask);
NeoLKernel/arch/arm/mach-fsm/irq.h:int msm_irq_enter_sleep2(bool arm9_wake, int from_idle);
NeoLKernel/arch/arm/mach-fsm/irq.h:	(uint32_t irq_mask, uint32_t wakeup_reason, uint32_t pending_irqs);
NeoLKernel/arch/arm/mach-fsm/irq.h:	(uint32_t irq_mask, uint32_t wakeup_reason, uint32_t pending);
NeoLKernel/arch/arm/mach-fsm/irq.h:	(uint32_t irq_mask, uint32_t wakeup_reason, uint32_t pending_irqs);
NeoLKernel/arch/arm/mach-fsm/ping_mdm_rpc_client.c:		wake_up(&data_cb_test_wait);
NeoLKernel/arch/arm/mach-fsm/ping_mdm_rpc_client.c:		wake_up(&reg_test_wait);
NeoLKernel/arch/arm/mach-fsm/platsmp.c:	/* Use smp_cross_call() to send a soft interrupt to wake up
NeoLKernel/arch/arm/mach-fsm/pm-8x60.c:			/* OK, proper wakeup, we're done */
NeoLKernel/arch/arm/mach-fsm/pm-8x60.c:	pr_notice("%s(): cpu %u normal wakeup\n", __func__, cpu);
NeoLKernel/arch/arm/mach-fsm/pm.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-fsm/pm.c:	uint32_t aArm_wakeup_reason;
NeoLKernel/arch/arm/mach-fsm/pm.c:				msm_pm_sma.int_info->aArm_wakeup_reason,
NeoLKernel/arch/arm/mach-fsm/pm.c:				msm_pm_sma.int_info->aArm_wakeup_reason,
NeoLKernel/arch/arm/mach-fsm/pm.c:		msm_pm_sma.int_info->aArm_wakeup_reason,
NeoLKernel/arch/arm/mach-fsm/pm.c:				msm_pm_sma.int_info->aArm_wakeup_reason,
NeoLKernel/arch/arm/mach-fsm/pm.c:		msm_pm_sma.int_info->aArm_wakeup_reason,
NeoLKernel/arch/arm/mach-fsm/pm.c:		msm_pm_sma.int_info->aArm_wakeup_reason,
NeoLKernel/arch/arm/mach-fsm/pm.c:		!has_wake_lock(WAKE_LOCK_IDLE) &&
NeoLKernel/arch/arm/mach-fsm/pm2.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-fsm/pm2.c:				msm_pm_smem_data->wakeup_reason, \
NeoLKernel/arch/arm/mach-fsm/pm2.c:	uint32_t wakeup_reason;
NeoLKernel/arch/arm/mach-fsm/pm2.c:		msm_pm_smem_data->wakeup_reason,
NeoLKernel/arch/arm/mach-fsm/pm2.c:		msm_pm_smem_data->wakeup_reason,
NeoLKernel/arch/arm/mach-fsm/pm2.c:		msm_pm_smem_data->wakeup_reason,
NeoLKernel/arch/arm/mach-fsm/pm2.c:		has_wake_lock(WAKE_LOCK_IDLE) ||
NeoLKernel/arch/arm/mach-fsm/pm2.c:	/* The wakeup_reason field is overloaded during initialization time
NeoLKernel/arch/arm/mach-fsm/pm2.c:	msm_pm_smem_data->wakeup_reason = 1;
NeoLKernel/arch/arm/mach-fsm/qdsp5/adsp.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-fsm/qdsp5/adsp.c:static struct wake_lock adsp_wake_lock;
NeoLKernel/arch/arm/mach-fsm/qdsp5/adsp.c:	wake_lock(&adsp_wake_lock);
NeoLKernel/arch/arm/mach-fsm/qdsp5/adsp.c:	wake_unlock(&adsp_wake_lock);
NeoLKernel/arch/arm/mach-fsm/qdsp5/adsp.c:		wake_up(&adsp_info.init_info_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/adsp.c:		wake_up(&module->state_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/adsp.c:		wake_up(&module->state_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/adsp.c:		wake_up(&module->state_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/adsp.c:	wake_lock_init(&adsp_wake_lock, WAKE_LOCK_SUSPEND, "adsp");
NeoLKernel/arch/arm/mach-fsm/qdsp5/adsp_driver.c:		wake_up(&adev->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/adsp_driver.c:	wake_up(&adev->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_aac.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_aac.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_aac.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_aac.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_aac.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_aac.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_aac.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_aac.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_aac.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_aac.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_aac.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_aac.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_aac.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_aac.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrnb.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrnb.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrnb.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrnb.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrnb.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrnb.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrnb.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrnb.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrnb.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrnb.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrnb.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrnb.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrnb.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrnb.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrnb_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrnb_in.c:	wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrnb_in.c:			/* Make sure we're stopped and we wake any threads
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrnb_in.c:			wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrwb.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrwb.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrwb.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrwb.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrwb.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrwb.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrwb.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrwb.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrwb.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrwb.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrwb.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrwb.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrwb.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_amrwb.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_evrc.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_evrc.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_evrc.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_evrc.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_evrc.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_evrc.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_evrc.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_evrc.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_evrc.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_evrc.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_evrc.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_evrc.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_evrc.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_evrc.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_in.c:			/* Make sure we're stopped and we wake any threads
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_in.c:			wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_mp3.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_mp3.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_mp3.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_mp3.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_mp3.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_mp3.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_mp3.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_mp3.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_mp3.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_mp3.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_mp3.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_mp3.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_mp3.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_mp3.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_mp3.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_out.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_out.c:	struct wake_lock wakelock;
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_out.c:	struct wake_lock idlelock;
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_out.c:	wake_lock(&audio->wakelock);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_out.c:	wake_lock(&audio->idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_out.c:	wake_unlock(&audio->wakelock);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_out.c:	wake_unlock(&audio->idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_out.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_out.c:			wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_out.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_out.c:			/* Make sure we're stopped and we wake any threads
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_out.c:			wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_out.c:	wake_lock_init(&the_audio.wakelock, WAKE_LOCK_SUSPEND, "audio_pcm");
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_out.c:	wake_lock_init(&the_audio.idlelock, WAKE_LOCK_IDLE, "audio_pcm_idle");
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_pcm.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_pcm.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_pcm.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_pcm.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_pcm.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_pcm.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_pcm.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_pcm.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_pcm.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_pcm.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_pcm.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_pcm.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_qcelp.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_qcelp.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_qcelp.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_qcelp.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_qcelp.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_qcelp.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_qcelp.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_qcelp.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_qcelp.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_qcelp.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_qcelp.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_qcelp.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_qcelp.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_qcelp.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_voicememo.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_voicememo.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_voicememo.c:				wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_voicememo.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_voicememo.c:			wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_voicememo.c:						wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_wma.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_wma.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_wma.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_wma.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_wma.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_wma.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_wma.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_wma.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_wma.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_wma.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_wma.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_wma.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_wma.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_wma.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_wmapro.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_wmapro.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_wmapro.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_wmapro.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_wmapro.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_wmapro.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_wmapro.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_wmapro.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_wmapro.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_wmapro.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_wmapro.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_wmapro.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_wmapro.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audio_wmapro.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audmgr.c:		wake_up(&am->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audmgr.c:		wake_up(&am->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audmgr.c:		wake_up(&am->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/audpp.c:			wake_up(&audpp->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5/snd_adie.c:	wake_up(&adie_client[id].wq);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_pcm.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_pcm.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_pcm.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_pcm.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_pcm.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_pcm.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_pcm.c:		wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_pcm.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_pcm.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_pcm.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_pcm.c:	wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_pcm.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_pcm.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_pcm.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/adsp.c:		wake_up(&adsp_info.init_info_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/adsp.c:		wake_up(&module->state_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/adsp.c:		wake_up(&module->state_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/adsp.c:		wake_up(&module->state_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/adsp_driver.c:		wake_up(&adev->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/adsp_driver.c:	wake_up(&adev->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/afe.c:		wake_up(&afe->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_a2dp_in.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_a2dp_in.c:		wake_up(&audio->wait_enable);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_a2dp_in.c:		wake_up(&audio->wait_enable);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_a2dp_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_a2dp_in.c:	wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_a2dp_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_a2dp_in.c:			/* Make sure we're stopped and we wake any threads
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_a2dp_in.c:			wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_aac.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_aac.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_aac.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_aac.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_aac.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_aac.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_aac.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_aac.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_aac.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_aac.c:		wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_aac.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_aac.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_aac.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_aac.c:	wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_aac.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_aac.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_aac.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_aac.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_aac_in.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_aac_in.c:		wake_up(&audio->wait_enable);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_aac_in.c:		wake_up(&audio->wait_enable);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_aac_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_aac_in.c:	wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_aac_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_aac_in.c:			/* Make sure we're stopped and we wake any threads
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_aac_in.c:			wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_acdb.c:	wake_up(&acdb_data.wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_acdb.c:	wake_up(&acdb_data.wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_acdb.c:	wake_up(&acdb_data.wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_adpcm.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_adpcm.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_adpcm.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_adpcm.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_adpcm.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_adpcm.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_adpcm.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_adpcm.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_adpcm.c:		wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_adpcm.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_adpcm.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_adpcm.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_adpcm.c:	wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_adpcm.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_adpcm.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_adpcm.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrnb.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrnb.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrnb.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrnb.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrnb.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrnb.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrnb.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrnb.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrnb.c:		wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrnb.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrnb.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrnb.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrnb.c:	wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrnb.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrnb.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrnb.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrnb_in.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrnb_in.c:		wake_up(&audio->wait_enable);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrnb_in.c:		wake_up(&audio->wait_enable);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrnb_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrnb_in.c:	wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrnb_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrnb_in.c:			/* Make sure we're stopped and we wake any threads
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrnb_in.c:			wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrwb.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrwb.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrwb.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrwb.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrwb.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrwb.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrwb.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrwb.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrwb.c:		wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrwb.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrwb.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrwb.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrwb.c:	wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrwb.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrwb.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_amrwb.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_dev_ctl.c:	wake_up(&audio_dev_ctrl.wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_dev_ctl.c:			wake_up(&audio_dev_ctrl.wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_evrc.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_evrc.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_evrc.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_evrc.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_evrc.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_evrc.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_evrc.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_evrc.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_evrc.c:		wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_evrc.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_evrc.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_evrc.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_evrc.c:	wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_evrc.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_evrc.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_evrc.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_evrc_in.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_evrc_in.c:		wake_up(&audio->wait_enable);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_evrc_in.c:		wake_up(&audio->wait_enable);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_evrc_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_evrc_in.c:	wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_evrc_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_evrc_in.c:			/* Make sure we're stopped and we wake any threads
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_evrc_in.c:			wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_lpa.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_lpa.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_lpa.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_lpa.c:				wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_lpa.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_lpa.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_lpa.c:		wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_lpa.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_lpa.c:		wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_lpa.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_lpa.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_lpa.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_mp3.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_mp3.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_mp3.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_mp3.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_mp3.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_mp3.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_mp3.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_mp3.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_mp3.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_mp3.c:		wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_mp3.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_mp3.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_mp3.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_mp3.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_mp3.c:	wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_mp3.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_mp3.c:			wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_mp3.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_mp3.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_out.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_out.c:	struct wake_lock wakelock;
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_out.c:	struct wake_lock idlelock;
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_out.c:	wake_lock(&audio->wakelock);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_out.c:	wake_lock(&audio->idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_out.c:	wake_unlock(&audio->wakelock);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_out.c:	wake_unlock(&audio->idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_out.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_out.c:			wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_out.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_out.c:			/* Make sure we're stopped and we wake any threads
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_out.c:			wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_out.c:	wake_lock_init(&the_audio.wakelock, WAKE_LOCK_SUSPEND, "audio_pcm");
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_out.c:	wake_lock_init(&the_audio.idlelock, WAKE_LOCK_IDLE, "audio_pcm_idle");
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_pcm_in.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_pcm_in.c:		wake_up(&audio->wait_enable);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_pcm_in.c:		wake_up(&audio->wait_enable);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_pcm_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_pcm_in.c:	wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_pcm_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_pcm_in.c:			/* Make sure we're stopped and we wake any threads
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_pcm_in.c:			wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_qcelp.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_qcelp.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_qcelp.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_qcelp.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_qcelp.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_qcelp.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_qcelp.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_qcelp.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_qcelp.c:		wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_qcelp.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_qcelp.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_qcelp.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_qcelp.c:	wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_qcelp.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_qcelp.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_qcelp.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_qcelp_in.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_qcelp_in.c:		wake_up(&audio->wait_enable);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_qcelp_in.c:		wake_up(&audio->wait_enable);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_qcelp_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_qcelp_in.c:	wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_qcelp_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_qcelp_in.c:			/* Make sure we're stopped and we wake any threads
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_qcelp_in.c:			wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wma.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wma.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wma.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wma.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wma.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wma.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wma.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wma.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wma.c:		wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wma.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wma.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wma.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wma.c:	wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wma.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wma.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wma.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wmapro.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wmapro.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wmapro.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wmapro.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wmapro.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wmapro.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wmapro.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wmapro.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wmapro.c:		wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wmapro.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wmapro.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wmapro.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wmapro.c:	wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wmapro.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wmapro.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audio_wmapro.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audpp.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audpp.c:static struct wake_lock audpp_wake_lock;
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audpp.c:	wake_lock(&audpp_wake_lock);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audpp.c:	wake_unlock(&audpp_wake_lock);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audpp.c:			wake_up(&audpp->event_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audpp.c:	wake_lock_init(&audpp_wake_lock, WAKE_LOCK_SUSPEND, "audpp");
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audpreproc.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audpreproc.c:static struct wake_lock audpre_wake_lock;
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audpreproc.c:	wake_lock(&audpre_wake_lock);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audpreproc.c:	wake_unlock(&audpre_wake_lock);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audpreproc.c:	static int wakelock_init;
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audpreproc.c:	if (!wakelock_init) {
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audpreproc.c:		wake_lock_init(&audpre_wake_lock, WAKE_LOCK_SUSPEND, "audpre");
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/audpreproc.c:		wakelock_init = 1;
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/snddev_icodec.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/snddev_icodec.c:	struct wake_lock rx_idlelock;
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/snddev_icodec.c:	struct wake_lock tx_idlelock;
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/snddev_icodec.c:	wake_lock(&drv->rx_idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/snddev_icodec.c:	wake_unlock(&drv->rx_idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/snddev_icodec.c:	wake_unlock(&drv->rx_idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/snddev_icodec.c:	wake_lock(&drv->tx_idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/snddev_icodec.c:	wake_unlock(&drv->tx_idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/snddev_icodec.c:	wake_unlock(&drv->tx_idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/snddev_icodec.c:	wake_lock(&drv->rx_idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/snddev_icodec.c:	wake_unlock(&drv->rx_idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/snddev_icodec.c:	wake_lock(&drv->tx_idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/snddev_icodec.c:	wake_unlock(&drv->tx_idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/snddev_icodec.c:	wake_lock_init(&icodec_drv->tx_idlelock, WAKE_LOCK_IDLE,
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/snddev_icodec.c:	wake_lock_init(&icodec_drv->rx_idlelock, WAKE_LOCK_IDLE,
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/voice.c:				wake_up(&v->dev_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/voice.c:				wake_up(&v->dev_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/voice.c:				wake_up(&v->dev_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/voice.c:				wake_up(&v->dev_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/voice.c:				wake_up(&v->dev_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/voice.c:				wake_up(&v->dev_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/voice.c:				wake_up(&v->dev_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/voice.c:				wake_up(&v->dev_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/voice.c:		wake_up(&v->dev_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/voice.c:		wake_up(&v->voc_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/voice.c:		wake_up(&v->dev_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp5v2/voice.c:			wake_up(&v->voc_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp6/aac_in.c:		/*wake up client, if any*/
NeoLKernel/arch/arm/mach-fsm/qdsp6/aac_in.c:		wake_up(&fc->fc_wq);
NeoLKernel/arch/arm/mach-fsm/qdsp6/audiov2/q6audio.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-fsm/qdsp6/audiov2/q6audio.c:static struct wake_lock idlelock;
NeoLKernel/arch/arm/mach-fsm/qdsp6/audiov2/q6audio.c:		wake_lock(&idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp6/audiov2/q6audio.c:		wake_unlock(&idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp6/audiov2/q6audio.c:			wake_up(&ac->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp6/audiov2/q6audio.c:		wake_up(&ac->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp6/audiov2/q6audio.c:		wake_up(&ac->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp6/audiov2/q6audio.c:	wake_lock_init(&idlelock, WAKE_LOCK_IDLE, "audio_pcm_idle");
NeoLKernel/arch/arm/mach-fsm/qdsp6/dal.c:			wake_up(&client->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp6/dsp_debug.c:		wake_up(&dsp_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp6/dsp_debug.c:		wake_up(&dsp_wait);
NeoLKernel/arch/arm/mach-fsm/qdsp6/evrc_in.c:		/*wake up client, if any*/
NeoLKernel/arch/arm/mach-fsm/qdsp6/evrc_in.c:		wake_up(&fc->fc_wq);
NeoLKernel/arch/arm/mach-fsm/qdsp6/msm_q6vdec.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-fsm/qdsp6/msm_q6vdec.c:static struct wake_lock wakelock;
NeoLKernel/arch/arm/mach-fsm/qdsp6/msm_q6vdec.c:static struct wake_lock idlelock;
NeoLKernel/arch/arm/mach-fsm/qdsp6/msm_q6vdec.c:		wake_lock(&idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp6/msm_q6vdec.c:		wake_lock(&wakelock);
NeoLKernel/arch/arm/mach-fsm/qdsp6/msm_q6vdec.c:		wake_unlock(&idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp6/msm_q6vdec.c:		wake_unlock(&wakelock);
NeoLKernel/arch/arm/mach-fsm/qdsp6/msm_q6vdec.c:		wake_up(&vd->vdec_msg_evt);
NeoLKernel/arch/arm/mach-fsm/qdsp6/msm_q6vdec.c:	wake_up(&vd->vdec_msg_evt);
NeoLKernel/arch/arm/mach-fsm/qdsp6/msm_q6vdec.c:	wake_up_all(&vd->vdec_msg_evt);
NeoLKernel/arch/arm/mach-fsm/qdsp6/msm_q6vdec.c:	wake_lock_init(&idlelock, WAKE_LOCK_IDLE, "vdec_idle");
NeoLKernel/arch/arm/mach-fsm/qdsp6/msm_q6vdec.c:	wake_lock_init(&wakelock, WAKE_LOCK_SUSPEND, "vdec_suspend");
NeoLKernel/arch/arm/mach-fsm/qdsp6/msm_q6venc.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-fsm/qdsp6/msm_q6venc.c:static struct wake_lock wakelock;
NeoLKernel/arch/arm/mach-fsm/qdsp6/msm_q6venc.c:static struct wake_lock idlelock;
NeoLKernel/arch/arm/mach-fsm/qdsp6/msm_q6venc.c:		wake_lock(&idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp6/msm_q6venc.c:		wake_lock(&wakelock);
NeoLKernel/arch/arm/mach-fsm/qdsp6/msm_q6venc.c:		wake_unlock(&idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp6/msm_q6venc.c:		wake_unlock(&wakelock);
NeoLKernel/arch/arm/mach-fsm/qdsp6/msm_q6venc.c:		wake_up(&dvenc->venc_msg_evt);
NeoLKernel/arch/arm/mach-fsm/qdsp6/msm_q6venc.c:	wake_up(&dvenc->venc_msg_evt);
NeoLKernel/arch/arm/mach-fsm/qdsp6/msm_q6venc.c:	wake_up_all(&dvenc->venc_msg_evt);
NeoLKernel/arch/arm/mach-fsm/qdsp6/msm_q6venc.c:	wake_lock_init(&idlelock, WAKE_LOCK_IDLE, "venc_idle");
NeoLKernel/arch/arm/mach-fsm/qdsp6/msm_q6venc.c:	wake_lock_init(&wakelock, WAKE_LOCK_SUSPEND, "venc_suspend");
NeoLKernel/arch/arm/mach-fsm/qdsp6/q6audio.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-fsm/qdsp6/q6audio.c:static struct wake_lock wakelock;
NeoLKernel/arch/arm/mach-fsm/qdsp6/q6audio.c:static struct wake_lock idlelock;
NeoLKernel/arch/arm/mach-fsm/qdsp6/q6audio.c:		wake_lock(&wakelock);
NeoLKernel/arch/arm/mach-fsm/qdsp6/q6audio.c:		wake_lock(&idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp6/q6audio.c:		wake_unlock(&idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp6/q6audio.c:		wake_unlock(&wakelock);
NeoLKernel/arch/arm/mach-fsm/qdsp6/q6audio.c:			wake_up(&ac->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp6/q6audio.c:		wake_up(&ac->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp6/q6audio.c:		wake_up(&ac->wait);
NeoLKernel/arch/arm/mach-fsm/qdsp6/q6audio.c:	wake_lock_init(&idlelock, WAKE_LOCK_IDLE, "audio_pcm_idle");
NeoLKernel/arch/arm/mach-fsm/qdsp6/q6audio.c:	wake_lock_init(&wakelock, WAKE_LOCK_SUSPEND, "audio_pcm_suspend");
NeoLKernel/arch/arm/mach-fsm/qdsp6/qcelp_in.c:		/*wake up client, if any*/
NeoLKernel/arch/arm/mach-fsm/qdsp6/qcelp_in.c:		wake_up(&fc->fc_wq);
NeoLKernel/arch/arm/mach-fsm/qdsp6v2/audio_dev_ctl.c:	wake_up(&audio_dev_ctrl.wait);
NeoLKernel/arch/arm/mach-fsm/qdsp6v2/audio_dev_ctl.c:			wake_up(&audio_dev_ctrl.wait);
NeoLKernel/arch/arm/mach-fsm/qdsp6v2/snddev_icodec.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-fsm/qdsp6v2/snddev_icodec.c:	struct wake_lock rx_idlelock;
NeoLKernel/arch/arm/mach-fsm/qdsp6v2/snddev_icodec.c:	struct wake_lock tx_idlelock;
NeoLKernel/arch/arm/mach-fsm/qdsp6v2/snddev_icodec.c:	wake_lock(&drv->rx_idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp6v2/snddev_icodec.c:	wake_unlock(&drv->rx_idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp6v2/snddev_icodec.c:	wake_unlock(&drv->rx_idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp6v2/snddev_icodec.c:	wake_lock(&drv->tx_idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp6v2/snddev_icodec.c:	wake_unlock(&drv->tx_idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp6v2/snddev_icodec.c:	wake_unlock(&drv->tx_idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp6v2/snddev_icodec.c:	wake_lock(&drv->rx_idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp6v2/snddev_icodec.c:	wake_unlock(&drv->rx_idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp6v2/snddev_icodec.c:	wake_lock(&drv->tx_idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp6v2/snddev_icodec.c:	wake_unlock(&drv->tx_idlelock);
NeoLKernel/arch/arm/mach-fsm/qdsp6v2/snddev_icodec.c:	wake_lock_init(&icodec_drv->tx_idlelock, WAKE_LOCK_IDLE,
NeoLKernel/arch/arm/mach-fsm/qdsp6v2/snddev_icodec.c:	wake_lock_init(&icodec_drv->rx_idlelock, WAKE_LOCK_IDLE,
NeoLKernel/arch/arm/mach-fsm/rmt_storage_client.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-fsm/rmt_storage_client.c:	struct wake_lock wlock;
NeoLKernel/arch/arm/mach-fsm/rmt_storage_client.c:		wake_lock(&_rmc->wlock);
NeoLKernel/arch/arm/mach-fsm/rmt_storage_client.c:		wake_lock(&_rmc->wlock);
NeoLKernel/arch/arm/mach-fsm/rmt_storage_client.c:	wake_up(&rmc->event_q);
NeoLKernel/arch/arm/mach-fsm/rmt_storage_client.c:				wake_unlock(&rmc->wlock);
NeoLKernel/arch/arm/mach-fsm/rmt_storage_client.c:			wake_unlock(&rmc->wlock);
NeoLKernel/arch/arm/mach-fsm/rmt_storage_client.c:	wake_lock_init(&rmc->wlock, WAKE_LOCK_SUSPEND, "rmt_storage");
NeoLKernel/arch/arm/mach-fsm/rmt_storage_client.c:	wake_lock_destroy(&rmc->wlock);
NeoLKernel/arch/arm/mach-fsm/rpcrouter_sdio_xprt.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-fsm/rpcrouter_sdio_xprt.c:		wake_up(&write_avail_wait_q);
NeoLKernel/arch/arm/mach-fsm/rpc_fsusb.c:int  msm_fsusb_set_remote_wakeup(void)
NeoLKernel/arch/arm/mach-fsm/rpc_fsusb.c:EXPORT_SYMBOL(msm_fsusb_set_remote_wakeup);
NeoLKernel/arch/arm/mach-fsm/gpio.c:static int msm_gpio_irq_set_wake(unsigned int irq, unsigned int on)
NeoLKernel/arch/arm/mach-fsm/gpio.c:	.set_wake  = msm_gpio_irq_set_wake,
NeoLKernel/arch/arm/mach-fsm/gpio.c:	set_irq_wake(INT_GPIO_GROUP1, 1);
NeoLKernel/arch/arm/mach-fsm/gpio.c:	set_irq_wake(INT_GPIO_GROUP2, 2);
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter_clients.c:			wake_up(&client->reply_wait);
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter_clients.c:				wake_up(&client->cb_wait);
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter_clients.c:		wake_up(&client->cb_wait);
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter_servers.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter_servers.c:static struct wake_lock rpc_servers_wake_lock;
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter_servers.c:		wake_unlock(&rpc_servers_wake_lock);
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter_servers.c:		wake_lock(&rpc_servers_wake_lock);
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter_servers.c:	wake_lock_init(&rpc_servers_wake_lock, WAKE_LOCK_SUSPEND, "rpc_server");
NeoLKernel/arch/arm/mach-fsm/smd_rpcrouter_xdr.c:	wake_up(&xdr->in_buf_wait_q);
NeoLKernel/arch/arm/mach-fsm/smd_tty.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-fsm/smd_tty.c:	struct wake_lock wake_lock;
NeoLKernel/arch/arm/mach-fsm/smd_tty.c:		wake_lock_timeout(&info->wake_lock, HZ / 2);
NeoLKernel/arch/arm/mach-fsm/smd_tty.c:	tty_wakeup(tty);
NeoLKernel/arch/arm/mach-fsm/smd_tty.c:		wake_lock_init(&info->wake_lock, WAKE_LOCK_SUSPEND, name);
NeoLKernel/arch/arm/mach-fsm/smd_tty.c:		wake_lock_destroy(&info->wake_lock);
NeoLKernel/arch/arm/mach-fsm/smem_log.c:struct sym wakeup_syms[] = {
NeoLKernel/arch/arm/mach-fsm/smem_log.c:struct sym wakeup_int_syms[] = {
NeoLKernel/arch/arm/mach-fsm/smem_log.c:	{ wakeup_syms, ARRAY_SIZE(wakeup_syms) },
NeoLKernel/arch/arm/mach-fsm/smem_log.c:	{ wakeup_int_syms, ARRAY_SIZE(wakeup_int_syms) },
NeoLKernel/arch/arm/mach-fsm/spm.c:	uint8_t awake_vlevel;
NeoLKernel/arch/arm/mach-fsm/spm.c:	uint32_t awake_vlevel, uint32_t mid_vlevel, uint32_t sleep_vlevel)
NeoLKernel/arch/arm/mach-fsm/spm.c:		(mid_vlevel << 16) | (awake_vlevel << 8) | (sleep_vlevel);
NeoLKernel/arch/arm/mach-fsm/spm.c:		msm_spm_set_pmic_ctl(dev, dev->awake_vlevel,
NeoLKernel/arch/arm/mach-fsm/spm.c:		msm_spm_set_pmic_ctl(dev, dev->awake_vlevel,
NeoLKernel/arch/arm/mach-fsm/spm.c:	dev->awake_vlevel = vlevel;
NeoLKernel/arch/arm/mach-fsm/spm.c:		dev->awake_vlevel = data[cpu].awake_vlevel;
NeoLKernel/arch/arm/mach-fsm/spm.h:	uint8_t awake_vlevel;
NeoLKernel/arch/arm/mach-gemini/include/mach/system.h:	 * will never wakeup... Acctualy it is not very good to enable
NeoLKernel/arch/arm/mach-ixp4xx/include/mach/ixp4xx-regs.h:#define UDCCS0_DRWF	(1 << 3)	/* Device remote wakeup feature */
NeoLKernel/arch/arm/mach-lh7a40x/arch-lpd7a40x.c:#define CPLD_CONTROL_AWKP		(1<<2) /* Auto-wakeup disabled  */
NeoLKernel/arch/arm/mach-msm/.acpuclock-7x30.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.acpuclock-7x30.o.cmd:    $(wildcard include/config/att/wakeup.h) \
NeoLKernel/arch/arm/mach-msm/.board-semc_zeus-rfkill.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.board-semc_zeus-wifi.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.board-semc_zeus.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.board-semc_zeus.o.cmd:  include/linux/wakelock.h \
NeoLKernel/arch/arm/mach-msm/.board-semc_zeus.o.cmd:    $(wildcard include/config/has/wakelock.h) \
NeoLKernel/arch/arm/mach-msm/.board-semc_zeus.o.cmd:    $(wildcard include/config/wakelock/stat.h) \
NeoLKernel/arch/arm/mach-msm/.board-semc_zeus.o.cmd:    $(wildcard include/config/att/wakeup.h) \
NeoLKernel/arch/arm/mach-msm/.cpufreq.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.devices-msm7x30.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.devices-msm7x30.o.cmd:    $(wildcard include/config/att/wakeup.h) \
NeoLKernel/arch/arm/mach-msm/.dma.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.dma_test.o.cmd:  include/linux/pm_wakeup.h \
Binary file NeoLKernel/arch/arm/mach-msm/keypad-surf-ffa.o matches
NeoLKernel/arch/arm/mach-msm/keypad-urushi.c:	.wakeup			= 1,
NeoLKernel/arch/arm/mach-msm/keypad-zeus.c:static struct gpio_event_input_info keypad_pmic_gpio_nwake_info = {
NeoLKernel/arch/arm/mach-msm/keypad-zeus.c:	.keymap = keypad_zeus_pmic_gpio_map_nwake,
NeoLKernel/arch/arm/mach-msm/keypad-zeus.c:	.keymap_size = ARRAY_SIZE(keypad_zeus_pmic_gpio_map_nwake),
NeoLKernel/arch/arm/mach-msm/keypad-zeus.c:static struct gpio_event_input_info keypad_pmic_gpio_wake_info = {
NeoLKernel/arch/arm/mach-msm/keypad-zeus.c:	.keymap = keypad_zeus_pmic_gpio_map_wake,
NeoLKernel/arch/arm/mach-msm/keypad-zeus.c:	.keymap_size = ARRAY_SIZE(keypad_zeus_pmic_gpio_map_wake),
NeoLKernel/arch/arm/mach-msm/keypad-zeus.c:	&keypad_pmic_gpio_wake_info.info,
NeoLKernel/arch/arm/mach-msm/keypad-zeus.c:	&keypad_pmic_gpio_nwake_info.info,
NeoLKernel/arch/arm/mach-msm/keypad-zeus.c:	for (i = 0; i < ARRAY_SIZE(keypad_zeus_pmic_gpio_map_nwake); ++i) {
NeoLKernel/arch/arm/mach-msm/keypad-zeus.c:				keypad_zeus_pmic_gpio_map_nwake[i].gpio));
NeoLKernel/arch/arm/mach-msm/keypad-zeus.c:	for (i = 0; i < ARRAY_SIZE(keypad_zeus_pmic_gpio_map_wake); ++i) {
NeoLKernel/arch/arm/mach-msm/keypad-zeus.c:				keypad_zeus_pmic_gpio_map_wake[i].gpio));
NeoLKernel/arch/arm/mach-msm/keypad-zeus.h:static struct gpio_event_direct_entry keypad_zeus_pmic_gpio_map_nwake[] = {
NeoLKernel/arch/arm/mach-msm/keypad-zeus.h:static struct gpio_event_direct_entry keypad_zeus_pmic_gpio_map_wake[] = {
Binary file NeoLKernel/arch/arm/mach-msm/keypad-zeus.o matches
Binary file NeoLKernel/arch/arm/mach-msm/memory.o matches
Binary file NeoLKernel/arch/arm/mach-msm/rpc_pmapp.o matches
Binary file NeoLKernel/arch/arm/mach-msm/rpc_server_time_remote.o matches
NeoLKernel/arch/arm/mach-msm/sdio_al.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/sdio_al.c: *  @wake_lock - Lock when can't sleep.
NeoLKernel/arch/arm/mach-msm/sdio_al.c:	struct wake_lock wake_lock;
NeoLKernel/arch/arm/mach-msm/sdio_al.c:static int sdio_al_wake_up(u32 enable_wake_up_func);
NeoLKernel/arch/arm/mach-msm/sdio_al.c:		/* Release wakelock */
NeoLKernel/arch/arm/mach-msm/sdio_al.c:		wake_unlock(&sdio_al->wake_lock);
NeoLKernel/arch/arm/mach-msm/sdio_al.c:			ret = sdio_al_wake_up(1);
NeoLKernel/arch/arm/mach-msm/sdio_al.c:		wake_up(&sdio_al->wait_mbox);
NeoLKernel/arch/arm/mach-msm/sdio_al.c: *  2. Enable wake up function if needed
NeoLKernel/arch/arm/mach-msm/sdio_al.c:static int sdio_al_wake_up(u32 enable_wake_up_func)
NeoLKernel/arch/arm/mach-msm/sdio_al.c:	wake_lock(&sdio_al->wake_lock);
NeoLKernel/arch/arm/mach-msm/sdio_al.c:	if (enable_wake_up_func)
NeoLKernel/arch/arm/mach-msm/sdio_al.c:		pr_info(MODULE_NAME ": already awake, no need to wake up\n");
NeoLKernel/arch/arm/mach-msm/sdio_al.c:	if (enable_wake_up_func) {
NeoLKernel/arch/arm/mach-msm/sdio_al.c:		ret = sdio_al_enable_func_retry(wk_func, "wakeup func");
NeoLKernel/arch/arm/mach-msm/sdio_al.c:	if (enable_wake_up_func)
NeoLKernel/arch/arm/mach-msm/sdio_al.c:		sdio_al_wake_up(0);
NeoLKernel/arch/arm/mach-msm/sdio_al.c:		wake_unlock(&sdio_al->wake_lock);
NeoLKernel/arch/arm/mach-msm/sdio_al.c:	ret = sdio_al_wake_up(1);
NeoLKernel/arch/arm/mach-msm/sdio_al.c:		ret = sdio_al_wake_up(1);
NeoLKernel/arch/arm/mach-msm/sdio_al.c:	ret = sdio_al_wake_up(1);
NeoLKernel/arch/arm/mach-msm/sdio_al.c:		ret = sdio_al_wake_up(1);
NeoLKernel/arch/arm/mach-msm/sdio_al.c:	ret = sdio_al_wake_up(1);
NeoLKernel/arch/arm/mach-msm/sdio_al.c:	wake_lock_init(&sdio_al->wake_lock, WAKE_LOCK_SUSPEND, MODULE_NAME);
NeoLKernel/arch/arm/mach-msm/sdio_al.c:	wake_lock(&sdio_al->wake_lock);
Binary file NeoLKernel/arch/arm/mach-msm/sdio_al.o matches
NeoLKernel/arch/arm/mach-msm/sdio_al_test.c:		wake_up(&test_ctx->wait_q);
NeoLKernel/arch/arm/mach-msm/sdio_al_test.c:		wake_up(&test_ctx->wait_q);
NeoLKernel/arch/arm/mach-msm/sdio_ctl.c:	wake_up(&sdio_ctl_devp[id]->read_wait_queue);
NeoLKernel/arch/arm/mach-msm/sdio_ctl.c:	wake_up(&write_wait_queue);
NeoLKernel/arch/arm/mach-msm/sdio_ctl.c:		wake_up(&sdio_ctl_devp[id]->open_wait_queue);
NeoLKernel/arch/arm/mach-msm/sdio_ctl.c:		wake_up(&sdio_ctl_devp[id]->read_wait_queue);
NeoLKernel/arch/arm/mach-msm/sdio_ctl.c:		wake_up(&write_wait_queue);
Binary file NeoLKernel/arch/arm/mach-msm/sdio_ctl.o matches
Binary file NeoLKernel/arch/arm/mach-msm/semc_battery_data.o matches
NeoLKernel/arch/arm/mach-msm/.pmic.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.pmic.o.cmd:  include/linux/wakelock.h \
NeoLKernel/arch/arm/mach-msm/.pmic.o.cmd:    $(wildcard include/config/has/wakelock.h) \
NeoLKernel/arch/arm/mach-msm/.pmic.o.cmd:    $(wildcard include/config/wakelock/stat.h) \
NeoLKernel/arch/arm/mach-msm/board-mahimahi-flashlight.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/board-qsd8x50a-st1x.c:		.wakeup		= 1
NeoLKernel/arch/arm/mach-msm/board-qsd8x50a-st1x.c:		.name	= "gpio_host_wake",
NeoLKernel/arch/arm/mach-msm/board-qsd8x50a-st1x.c:		.name	= "gpio_ext_wake",
NeoLKernel/arch/arm/mach-msm/board-qsd8x50a-st1x.c:		.name	= "host_wake",
NeoLKernel/arch/arm/mach-msm/board-semc_zeus.c:	.wakeup = 1,
NeoLKernel/arch/arm/mach-msm/board-semc_zeus.c:	.wake = 1,
NeoLKernel/arch/arm/mach-msm/board-semc_zeus.c:	.inject_rx_on_wakeup = 0,
NeoLKernel/arch/arm/mach-msm/board-semc_zeus.c:	.gpio_wake = BT_GPIO_WAKE,
NeoLKernel/arch/arm/mach-msm/board-semc_zeus.c:	.gpio_host_wake = BT_GPIO_HOST_WAKE,
NeoLKernel/arch/arm/mach-msm/board-semc_zeus.c:	.sdiowakeup_irq = MSM_GPIO_TO_INT(118),
NeoLKernel/arch/arm/mach-msm/board-semc_zeus.c:	.awake_vlevel = 0xF2,
NeoLKernel/arch/arm/mach-msm/htc_35mm_jack.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/htc_35mm_jack.c:	struct wake_lock headset_wake_lock;
NeoLKernel/arch/arm/mach-msm/htc_35mm_jack.c:	wake_lock_timeout(&hi->headset_wake_lock, 1.5*HZ);
NeoLKernel/arch/arm/mach-msm/htc_35mm_jack.c:	wake_lock_timeout(&hi->headset_wake_lock, 2.5*HZ);
NeoLKernel/arch/arm/mach-msm/htc_35mm_jack.c:	wake_lock_timeout(&hi->headset_wake_lock, 1.5*HZ);
NeoLKernel/arch/arm/mach-msm/htc_35mm_jack.c:	wake_lock_init(&hi->headset_wake_lock, WAKE_LOCK_SUSPEND, "headset");
NeoLKernel/arch/arm/mach-msm/htc_battery.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/htc_battery.c:static struct wake_lock vbus_wake_lock;
NeoLKernel/arch/arm/mach-msm/htc_battery.c:		wake_lock(&vbus_wake_lock);
NeoLKernel/arch/arm/mach-msm/htc_battery.c:		wake_lock_timeout(&vbus_wake_lock, HZ / 2);
NeoLKernel/arch/arm/mach-msm/htc_battery.c:	wake_lock_init(&vbus_wake_lock, WAKE_LOCK_SUSPEND, "vbus_present");
NeoLKernel/arch/arm/mach-msm/htc_headset.c:	ret = set_irq_wake(hi->irq, 1);
NeoLKernel/arch/arm/mach-msm/htc_headset.c:	ret = set_irq_wake(hi->irq_btn, 1);
NeoLKernel/arch/arm/mach-msm/htc_power_supply.c:static struct wake_lock dock_work_wake_lock;
NeoLKernel/arch/arm/mach-msm/htc_power_supply.c:	wake_unlock(&dock_work_wake_lock);
NeoLKernel/arch/arm/mach-msm/htc_power_supply.c:	wake_lock(&dock_work_wake_lock);
NeoLKernel/arch/arm/mach-msm/htc_power_supply.c:	wake_lock_init(&dock_work_wake_lock, WAKE_LOCK_SUSPEND, "dock");
NeoLKernel/arch/arm/mach-msm/hw3d.c:	wake_up(&hw3d_queue);
NeoLKernel/arch/arm/mach-msm/hw3d.c:		wake_unlock(&info->wake_lock);
NeoLKernel/arch/arm/mach-msm/hw3d.c:	wake_up(&info->revoke_done_wq);
NeoLKernel/arch/arm/mach-msm/hw3d.c:	wake_lock(&info->wake_lock);
NeoLKernel/arch/arm/mach-msm/hw3d.c:	wake_up(&info->revoke_wq);
NeoLKernel/arch/arm/mach-msm/board-sapphire-gpio.c:/*Sleep have to prepare the wake up source in advance.
NeoLKernel/arch/arm/mach-msm/board-sapphire-gpio.c:default to disable all wakeup sources when suspend.*/
NeoLKernel/arch/arm/mach-msm/board-sapphire-gpio.c:/*preparing enable/disable wake source before sleep*/
NeoLKernel/arch/arm/mach-msm/board-sapphire-gpio.c:int sapphire_gpio_irq_set_wake(unsigned int irq, unsigned int on)
NeoLKernel/arch/arm/mach-msm/board-sapphire-gpio.c:	if (on)	/*wake on -> mask the bit*/
NeoLKernel/arch/arm/mach-msm/board-sapphire-gpio.c:	else	/*no wake -> unmask the bit*/
NeoLKernel/arch/arm/mach-msm/board-sapphire-gpio.c:	.set_wake  = sapphire_gpio_irq_set_wake,
NeoLKernel/arch/arm/mach-msm/board-sapphire-gpio.c:	set_irq_wake(MSM_GPIO_TO_INT(17), 1);
NeoLKernel/arch/arm/mach-msm/board-sapphire-h2w.c:	ret = set_irq_wake(hi->irq, 1);
NeoLKernel/arch/arm/mach-msm/board-sapphire-h2w.c:	ret = set_irq_wake(hi->irq_btn, 1);
NeoLKernel/arch/arm/mach-msm/board-sapphire-mmc.c:	set_irq_wake(SAPPHIRE_GPIO_TO_INT(SAPPHIRE_GPIO_SDMC_CD_N), 1);
NeoLKernel/arch/arm/mach-msm/board-sapphire.c:/* a new search button to be a wake-up source */
NeoLKernel/arch/arm/mach-msm/board-sapphire.c:	.wakeup_irq = MSM_GPIO_TO_INT(45),
NeoLKernel/arch/arm/mach-msm/board-sapphire.c:	.inject_rx_on_wakeup = 1,
NeoLKernel/arch/arm/mach-msm/board-semc_mogami-touch.h:extern int cyttsp_wakeup(void);
NeoLKernel/arch/arm/mach-msm/board-semc_mogami.c:int cyttsp_wakeup(void)
NeoLKernel/arch/arm/mach-msm/board-semc_mogami.c:	printk(KERN_INFO "%s: wakeup\n", __func__);
NeoLKernel/arch/arm/mach-msm/board-semc_mogami.c:	.is_irq_wakeup  = 1,
NeoLKernel/arch/arm/mach-msm/board-semc_mogami.c:	.inject_rx_on_wakeup = 1,
NeoLKernel/arch/arm/mach-msm/board-semc_mogami.c:	.sdiowakeup_irq = MSM_GPIO_TO_INT(118),
NeoLKernel/arch/arm/mach-msm/board-semc_mogami.c:	.awake_vlevel = 0xF2,
NeoLKernel/arch/arm/mach-msm/board-semc_mogami.c:	msm_uart_dm1_pdata.wakeup_irq = gpio_to_irq(136);
Binary file NeoLKernel/arch/arm/mach-msm/board-semc_zeus-rfkill.o matches
Binary file NeoLKernel/arch/arm/mach-msm/board-semc_zeus-wifi.o matches
Binary file NeoLKernel/arch/arm/mach-msm/nand_partitions.o matches
Binary file NeoLKernel/arch/arm/mach-msm/oem_rapi_client.o matches
Binary file NeoLKernel/arch/arm/mach-msm/ping_apps_server.o matches
NeoLKernel/arch/arm/mach-msm/ping_mdm_rpc_client.c:		wake_up(&data_cb_test_wait);
NeoLKernel/arch/arm/mach-msm/ping_mdm_rpc_client.c:		wake_up(&reg_test_wait);
Binary file NeoLKernel/arch/arm/mach-msm/ping_mdm_rpc_client.o matches
NeoLKernel/arch/arm/mach-msm/platsmp.c:	/* Use smp_cross_call() to send a soft interrupt to wake up
NeoLKernel/arch/arm/mach-msm/pm-8x60.c:			/* OK, proper wakeup, we're done */
NeoLKernel/arch/arm/mach-msm/pm-8x60.c:	pr_notice("CPU%u: %s: normal wakeup\n", cpu, __func__);
NeoLKernel/arch/arm/mach-msm/pm.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/pm.c:	uint32_t aArm_wakeup_reason;
NeoLKernel/arch/arm/mach-msm/pm.c:				msm_pm_sma.int_info->aArm_wakeup_reason,
NeoLKernel/arch/arm/mach-msm/pm.c:				msm_pm_sma.int_info->aArm_wakeup_reason,
NeoLKernel/arch/arm/mach-msm/pm.c:		msm_pm_sma.int_info->aArm_wakeup_reason,
NeoLKernel/arch/arm/mach-msm/pm.c:				msm_pm_sma.int_info->aArm_wakeup_reason,
NeoLKernel/arch/arm/mach-msm/pm.c:		msm_pm_sma.int_info->aArm_wakeup_reason,
NeoLKernel/arch/arm/mach-msm/pm.c:		msm_pm_sma.int_info->aArm_wakeup_reason,
NeoLKernel/arch/arm/mach-msm/pm.c:		!has_wake_lock(WAKE_LOCK_IDLE) &&
NeoLKernel/arch/arm/mach-msm/pm2.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/pm2.c:				msm_pm_smem_data->wakeup_reason, \
NeoLKernel/arch/arm/mach-msm/pm2.c:	uint32_t wakeup_reason;
NeoLKernel/arch/arm/mach-msm/pm2.c:		msm_pm_smem_data->wakeup_reason,
NeoLKernel/arch/arm/mach-msm/pm2.c:		msm_pm_smem_data->wakeup_reason,
NeoLKernel/arch/arm/mach-msm/pm2.c:		msm_pm_smem_data->wakeup_reason,
NeoLKernel/arch/arm/mach-msm/pm2.c:		has_wake_lock(WAKE_LOCK_IDLE) ||
NeoLKernel/arch/arm/mach-msm/pm2.c:	/* The wakeup_reason field is overloaded during initialization time
NeoLKernel/arch/arm/mach-msm/pm2.c:	msm_pm_smem_data->wakeup_reason = 1;
Binary file NeoLKernel/arch/arm/mach-msm/pm2.o matches
Binary file NeoLKernel/arch/arm/mach-msm/smd_rpcrouter_device.o matches
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter_servers.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter_servers.c:static struct wake_lock rpc_servers_wake_lock;
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter_servers.c:		wake_unlock(&rpc_servers_wake_lock);
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter_servers.c:		wake_lock(&rpc_servers_wake_lock);
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter_servers.c:	wake_lock_init(&rpc_servers_wake_lock, WAKE_LOCK_SUSPEND, "rpc_server");
Binary file NeoLKernel/arch/arm/mach-msm/smd_rpcrouter_servers.o matches
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter_xdr.c:	wake_up(&xdr->in_buf_wait_q);
Binary file NeoLKernel/arch/arm/mach-msm/smd_rpcrouter_xdr.o matches
NeoLKernel/arch/arm/mach-msm/smd_tty.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/smd_tty.c:	struct wake_lock wake_lock;
NeoLKernel/arch/arm/mach-msm/smd_tty.c:		wake_lock_timeout(&info->wake_lock, HZ / 2);
NeoLKernel/arch/arm/mach-msm/smd_tty.c:	tty_wakeup(tty);
NeoLKernel/arch/arm/mach-msm/smd_tty.c:		wake_lock_init(&info->wake_lock, WAKE_LOCK_SUSPEND, name);
NeoLKernel/arch/arm/mach-msm/smd_tty.c:		wake_lock_destroy(&info->wake_lock);
Binary file NeoLKernel/arch/arm/mach-msm/smd_tty.o matches
NeoLKernel/arch/arm/mach-msm/smem_log.c:struct sym wakeup_syms[] = {
NeoLKernel/arch/arm/mach-msm/smem_log.c:struct sym wakeup_int_syms[] = {
NeoLKernel/arch/arm/mach-msm/smem_log.c:	{ wakeup_syms, ARRAY_SIZE(wakeup_syms) },
NeoLKernel/arch/arm/mach-msm/smem_log.c:	{ wakeup_int_syms, ARRAY_SIZE(wakeup_int_syms) },
Binary file NeoLKernel/arch/arm/mach-msm/smem_log.o matches
NeoLKernel/arch/arm/mach-msm/spm.c:	uint8_t awake_vlevel;
NeoLKernel/arch/arm/mach-msm/spm.c:	uint32_t awake_vlevel, uint32_t mid_vlevel, uint32_t sleep_vlevel)
NeoLKernel/arch/arm/mach-msm/spm.c:		(mid_vlevel << 16) | (awake_vlevel << 8) | (sleep_vlevel);
NeoLKernel/arch/arm/mach-msm/spm.c:		msm_spm_set_pmic_ctl(dev, dev->awake_vlevel,
NeoLKernel/arch/arm/mach-msm/spm.c:		msm_spm_set_pmic_ctl(dev, dev->awake_vlevel,
NeoLKernel/arch/arm/mach-msm/spm.c:	dev->awake_vlevel = vlevel;
NeoLKernel/arch/arm/mach-msm/spm.c:		dev->awake_vlevel = data[cpu].awake_vlevel;
NeoLKernel/arch/arm/mach-msm/spm.h:	uint8_t awake_vlevel;
Binary file NeoLKernel/arch/arm/mach-msm/spm.o matches
Binary file NeoLKernel/arch/arm/mach-msm/timer.o matches
NeoLKernel/arch/arm/mach-msm/touch-coconut.c:	.wakeup = cyttsp_wakeup,
NeoLKernel/arch/arm/mach-msm/touch-iyokan.c:	.wakeup = cyttsp_wakeup,
NeoLKernel/arch/arm/mach-msm/touch-mango.c:	.wakeup = cyttsp_wakeup,
NeoLKernel/arch/arm/mach-msm/touch-satsuma.c:	.wakeup = cyttsp_wakeup,
NeoLKernel/arch/arm/mach-msm/touch-smultron.c:	.wakeup = cyttsp_wakeup,
Binary file NeoLKernel/arch/arm/mach-msm/vibrator-mogami.o matches
Binary file NeoLKernel/arch/arm/mach-msm/vreg.o matches
Binary file NeoLKernel/arch/arm/mach-msm/devices-msm7x30.o matches
Binary file NeoLKernel/arch/arm/mach-msm/dma.o matches
Binary file NeoLKernel/arch/arm/mach-msm/dma_test.o matches
NeoLKernel/arch/arm/mach-msm/include/mach/bcm_bt_lpm.h:	unsigned int gpio_wake;   /* CPU -> BCM wakeup gpio */
NeoLKernel/arch/arm/mach-msm/include/mach/bcm_bt_lpm.h:	unsigned int gpio_host_wake;  /* BCM -> CPU wakeup gpio */
NeoLKernel/arch/arm/mach-msm/include/mach/camera.h:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/include/mach/camera.h:	struct wake_lock suspend_lock;
NeoLKernel/arch/arm/mach-msm/include/mach/camera.h:	struct wake_lock wake_lock;
NeoLKernel/arch/arm/mach-msm/include/mach/msm_otg.h:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/include/mach/msm_otg.h:	struct wake_lock	wlock;
NeoLKernel/arch/arm/mach-msm/include/mach/msm_rpcrouter.h:void msm_rpc_read_wakeup(struct msm_rpc_endpoint *ept);
NeoLKernel/arch/arm/mach-msm/include/mach/msm_serial_debugger.h:		struct device *clk_device, int signal_irq, int wakeup_irq);
NeoLKernel/arch/arm/mach-msm/include/mach/msm_serial_debugger.h:		struct device *clk_device, int signal_irq, int wakeup_irq) {}
NeoLKernel/arch/arm/mach-msm/include/mach/msm_serial_hs.h: * Used to configure low power wakeup */
NeoLKernel/arch/arm/mach-msm/include/mach/msm_serial_hs.h:	int wakeup_irq;  /* wakeup irq */
NeoLKernel/arch/arm/mach-msm/include/mach/msm_serial_hs.h:	/* bool: inject char into rx tty on wakeup */
NeoLKernel/arch/arm/mach-msm/include/mach/msm_serial_hs.h:	unsigned char inject_rx_on_wakeup;
NeoLKernel/arch/arm/mach-msm/include/mach/msm_serial_pdata.h: * Used to configure low power wakeup */
NeoLKernel/arch/arm/mach-msm/include/mach/msm_serial_pdata.h:	int wakeup_irq;  /* wakeup irq */
NeoLKernel/arch/arm/mach-msm/include/mach/msm_serial_pdata.h:	/* bool: inject char into rx tty on wakeup */
NeoLKernel/arch/arm/mach-msm/include/mach/msm_serial_pdata.h:	unsigned char inject_rx_on_wakeup;
NeoLKernel/arch/arm/mach-msm/include/mach/rpc_hsusb.h:int msm_fsusb_set_remote_wakeup(void);
NeoLKernel/arch/arm/mach-msm/include/mach/rpc_hsusb.h:static inline int msm_fsusb_set_remote_wakeup(void) { return 0; }
NeoLKernel/arch/arm/mach-msm/include/mach/msm72k_otg.h:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/include/mach/msm72k_otg.h:	struct wake_lock wlock;
Binary file NeoLKernel/arch/arm/mach-msm/io.o matches
NeoLKernel/arch/arm/mach-msm/irq-vic.c:static uint32_t msm_irq_smsm_wake_enable[2];
NeoLKernel/arch/arm/mach-msm/irq-vic.c:	/* fake wakeup interrupts */
NeoLKernel/arch/arm/mach-msm/irq-vic.c:			msm_irq_smsm_wake_enable[0] &= ~mask;
NeoLKernel/arch/arm/mach-msm/irq-vic.c:		msm_irq_smsm_wake_enable[0] &= ~mask;
NeoLKernel/arch/arm/mach-msm/irq-vic.c:		msm_irq_smsm_wake_enable[0] |= mask;
NeoLKernel/arch/arm/mach-msm/irq-vic.c:static int msm_irq_set_wake(unsigned int irq, unsigned int on)
NeoLKernel/arch/arm/mach-msm/irq-vic.c:		printk(KERN_ERR "msm_irq_set_wake: bad wakeup irq %d\n", irq);
NeoLKernel/arch/arm/mach-msm/irq-vic.c:		msm_irq_smsm_wake_enable[1] |= mask;
NeoLKernel/arch/arm/mach-msm/irq-vic.c:		msm_irq_smsm_wake_enable[1] &= ~mask;
NeoLKernel/arch/arm/mach-msm/irq-vic.c: * If modem_wake is true, return currently enabled interrupts in *irq_mask.
NeoLKernel/arch/arm/mach-msm/irq-vic.c:void msm_irq_enter_sleep1(bool modem_wake, int from_idle, uint32_t *irq_mask)
NeoLKernel/arch/arm/mach-msm/irq-vic.c:	if (modem_wake) {
NeoLKernel/arch/arm/mach-msm/irq-vic.c:		*irq_mask = msm_irq_smsm_wake_enable[!from_idle];
NeoLKernel/arch/arm/mach-msm/irq-vic.c:int msm_irq_enter_sleep2(bool modem_wake, int from_idle)
NeoLKernel/arch/arm/mach-msm/irq-vic.c:	if (from_idle && !modem_wake)
NeoLKernel/arch/arm/mach-msm/irq-vic.c:	WARN_ON_ONCE(!modem_wake && !from_idle);
NeoLKernel/arch/arm/mach-msm/irq-vic.c:	if (modem_wake) {
NeoLKernel/arch/arm/mach-msm/irq-vic.c:void msm_irq_exit_sleep1(uint32_t irq_mask, uint32_t wakeup_reason,
NeoLKernel/arch/arm/mach-msm/irq-vic.c:			__func__, irq_mask, pending_irqs, wakeup_reason);
NeoLKernel/arch/arm/mach-msm/irq-vic.c:void msm_irq_exit_sleep2(uint32_t irq_mask, uint32_t wakeup_reason,
NeoLKernel/arch/arm/mach-msm/irq-vic.c:			__func__, irq_mask, pending, wakeup_reason);
NeoLKernel/arch/arm/mach-msm/irq-vic.c:void msm_irq_exit_sleep3(uint32_t irq_mask, uint32_t wakeup_reason,
NeoLKernel/arch/arm/mach-msm/irq-vic.c:			__func__, irq_mask, pending_irqs, wakeup_reason,
NeoLKernel/arch/arm/mach-msm/irq-vic.c:	.set_wake  = msm_irq_set_wake,
Binary file NeoLKernel/arch/arm/mach-msm/irq-vic.o matches
NeoLKernel/arch/arm/mach-msm/irq.c:static uint32_t msm_irq_smsm_wake_enable[2];
NeoLKernel/arch/arm/mach-msm/irq.c:	/* fake wakeup interrupts */
NeoLKernel/arch/arm/mach-msm/irq.c:		msm_irq_smsm_wake_enable[0] &= ~mask;
NeoLKernel/arch/arm/mach-msm/irq.c:		msm_irq_smsm_wake_enable[0] |= mask;
NeoLKernel/arch/arm/mach-msm/irq.c:static int msm_irq_set_wake(unsigned int irq, unsigned int on)
NeoLKernel/arch/arm/mach-msm/irq.c:		printk(KERN_ERR "msm_irq_set_wake: bad wakeup irq %d\n", irq);
NeoLKernel/arch/arm/mach-msm/irq.c:		msm_irq_smsm_wake_enable[1] |= mask;
NeoLKernel/arch/arm/mach-msm/irq.c:		msm_irq_smsm_wake_enable[1] &= ~mask;
NeoLKernel/arch/arm/mach-msm/irq.c:/* If arm9_wake is set: pass control to the other core.
NeoLKernel/arch/arm/mach-msm/irq.c: * If from_idle is not set: disable non-wakeup interrupts.
NeoLKernel/arch/arm/mach-msm/irq.c:void msm_irq_enter_sleep1(bool arm9_wake, int from_idle)
NeoLKernel/arch/arm/mach-msm/irq.c:	if (!arm9_wake || !smsm_int_info)
NeoLKernel/arch/arm/mach-msm/irq.c:	smsm_int_info->interrupt_mask = msm_irq_smsm_wake_enable[!from_idle];
NeoLKernel/arch/arm/mach-msm/irq.c:int msm_irq_enter_sleep2(bool arm9_wake, int from_idle)
NeoLKernel/arch/arm/mach-msm/irq.c:	if (from_idle && !arm9_wake)
NeoLKernel/arch/arm/mach-msm/irq.c:	WARN_ON_ONCE(!arm9_wake && !from_idle);
NeoLKernel/arch/arm/mach-msm/irq.c:	if (arm9_wake) {
NeoLKernel/arch/arm/mach-msm/irq.c:		       smsm_int_info->wakeup_reason,
NeoLKernel/arch/arm/mach-msm/irq.c:		       smsm_int_info->wakeup_reason,
NeoLKernel/arch/arm/mach-msm/irq.c:		       smsm_int_info->wakeup_reason, readl(VIC_IRQ_STATUS0),
NeoLKernel/arch/arm/mach-msm/irq.c:	.set_wake  = msm_irq_set_wake,
NeoLKernel/arch/arm/mach-msm/irq.c:		pr_err("set_wakeup_mask NO INT_INFO (%d)\n", INT_INFO_SMSM_ID);
NeoLKernel/arch/arm/mach-msm/irq.h:void msm_irq_enter_sleep1(bool arm9_wake, int from_idle, uint32_t *irq_mask);
NeoLKernel/arch/arm/mach-msm/irq.h:int msm_irq_enter_sleep2(bool arm9_wake, int from_idle);
NeoLKernel/arch/arm/mach-msm/irq.h:	(uint32_t irq_mask, uint32_t wakeup_reason, uint32_t pending_irqs);
NeoLKernel/arch/arm/mach-msm/irq.h:	(uint32_t irq_mask, uint32_t wakeup_reason, uint32_t pending);
NeoLKernel/arch/arm/mach-msm/irq.h:	(uint32_t irq_mask, uint32_t wakeup_reason, uint32_t pending_irqs);
NeoLKernel/arch/arm/mach-msm/keypad-anzu.c:	.wakeup			= 1,
NeoLKernel/arch/arm/mach-msm/keypad-coconut.c:	.wakeup			= 1,
NeoLKernel/arch/arm/mach-msm/keypad-haida.c:	.wakeup			= 1,
NeoLKernel/arch/arm/mach-msm/keypad-hallon.c:	.wakeup			= 1,
NeoLKernel/arch/arm/mach-msm/keypad-iyokan.c:	.wakeup			= 1,
NeoLKernel/arch/arm/mach-msm/keypad-mango.c:	.wakeup			= 1,
NeoLKernel/arch/arm/mach-msm/keypad-mogami_cdb.c:	.wakeup			= 1,
NeoLKernel/arch/arm/mach-msm/keypad-pmic-mogami.c:	int wake;
NeoLKernel/arch/arm/mach-msm/keypad-pmic-mogami.c:		if (!dt->keys[i].wake)
NeoLKernel/arch/arm/mach-msm/keypad-pmic-mogami.c:		if (!dt->keys[i].wake)
NeoLKernel/arch/arm/mach-msm/keypad-pmic-mogami.c:		dt->keys[i].wake = pdata->keymap[i].wake;
NeoLKernel/arch/arm/mach-msm/keypad-pmic-mogami.c:		if (!dt->keys[i].wake)
NeoLKernel/arch/arm/mach-msm/keypad-pmic-mogami.c:			enable_irq_wake(dt->keys[i].irq);
NeoLKernel/arch/arm/mach-msm/keypad-pmic-mogami.h:	int wake;
NeoLKernel/arch/arm/mach-msm/keypad-satsuma.c:	.wakeup			= 1,
NeoLKernel/arch/arm/mach-msm/keypad-smultron.c:	.wakeup			= 1,
Binary file NeoLKernel/arch/arm/mach-msm/pmic.o matches
Binary file NeoLKernel/arch/arm/mach-msm/pmic8058-gpio.o matches
Binary file NeoLKernel/arch/arm/mach-msm/pmic8058-mpp.o matches
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrwb.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrwb.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrwb.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrwb.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrwb.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrwb.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrwb.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrwb.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrwb.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrwb.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrwb.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrwb.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrwb.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrwb.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/adsp.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/qdsp5/adsp.c:static struct wake_lock adsp_wake_lock;
NeoLKernel/arch/arm/mach-msm/qdsp5/adsp.c:	wake_lock(&adsp_wake_lock);
NeoLKernel/arch/arm/mach-msm/qdsp5/adsp.c:	wake_unlock(&adsp_wake_lock);
NeoLKernel/arch/arm/mach-msm/qdsp5/adsp.c:		wake_up(&adsp_info.init_info_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/adsp.c:		wake_up(&module->state_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/adsp.c:		wake_up(&module->state_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/adsp.c:		wake_up(&module->state_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/adsp.c:	wake_lock_init(&adsp_wake_lock, WAKE_LOCK_SUSPEND, "adsp");
NeoLKernel/arch/arm/mach-msm/qdsp5/adsp_driver.c:		wake_up(&adev->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/adsp_driver.c:	wake_up(&adev->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/adsp_rm.c:		wake_up(&rmclient[client_idx].wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_aac.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_aac.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_aac.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_aac.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_aac.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_aac.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_aac.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_aac.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_aac.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_aac.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_aac.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_aac.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_aac.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_aac.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrnb.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrnb.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrnb.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrnb.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrnb.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrnb.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrnb.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrnb.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrnb.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrnb.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrnb.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrnb.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrnb.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrnb.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrnb_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrnb_in.c:	wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrnb_in.c:			/* Make sure we're stopped and we wake any threads
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_amrnb_in.c:			wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_evrc.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_evrc.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_evrc.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_evrc.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_evrc.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_evrc.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_evrc.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_evrc.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_evrc.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_evrc.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_evrc.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_evrc.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_evrc.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_evrc.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_in.c:			/* Make sure we're stopped and we wake any threads
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_in.c:			wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_mp3.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_mp3.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_mp3.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_mp3.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_mp3.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_mp3.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_mp3.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_mp3.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_mp3.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_mp3.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_mp3.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_mp3.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_mp3.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_mp3.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_mp3.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_out.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_out.c:	struct wake_lock wakelock;
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_out.c:	struct wake_lock idlelock;
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_out.c:	wake_lock(&audio->wakelock);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_out.c:	wake_lock(&audio->idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_out.c:	wake_unlock(&audio->wakelock);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_out.c:	wake_unlock(&audio->idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_out.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_out.c:			wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_out.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_out.c:			/* Make sure we're stopped and we wake any threads
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_out.c:			wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_out.c:	wake_lock_init(&the_audio.wakelock, WAKE_LOCK_SUSPEND, "audio_pcm");
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_out.c:	wake_lock_init(&the_audio.idlelock, WAKE_LOCK_IDLE, "audio_pcm_idle");
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_pcm.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_pcm.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_pcm.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_pcm.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_pcm.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_pcm.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_pcm.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_pcm.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_pcm.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_pcm.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_pcm.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_pcm.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_qcelp.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_qcelp.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_qcelp.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_qcelp.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_qcelp.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_qcelp.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_qcelp.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_qcelp.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_qcelp.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_qcelp.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_qcelp.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_qcelp.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_qcelp.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_qcelp.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_voicememo.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_voicememo.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_voicememo.c:				wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_voicememo.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_voicememo.c:			wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_voicememo.c:						wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_wma.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_wma.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_wma.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_wma.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_wma.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_wma.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_wma.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_wma.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_wma.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_wma.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_wma.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_wma.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_wma.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_wma.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_wmapro.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_wmapro.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_wmapro.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_wmapro.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_wmapro.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_wmapro.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_wmapro.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_wmapro.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_wmapro.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_wmapro.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_wmapro.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_wmapro.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_wmapro.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audio_wmapro.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audmgr.c:		wake_up(&am->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audmgr.c:		wake_up(&am->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audmgr.c:		wake_up(&am->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/audpp.c:			wake_up(&audpp->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5/snd_adie.c:	wake_up(&adie_client[id].wq);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.adsp.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.adsp_driver.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.adsp_info.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audio_a2dp_in.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audio_aac.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audio_aac_in.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audio_acdb.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audio_adpcm.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audio_amrnb.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audio_amrnb_in.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audio_amrwb.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audio_evrc.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audio_evrc_in.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audio_fm.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audio_interct.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audio_lpa.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audio_mp3.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audio_mvs.o.cmd:  include/linux/wakelock.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audio_mvs.o.cmd:    $(wildcard include/config/has/wakelock.h) \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audio_mvs.o.cmd:    $(wildcard include/config/wakelock/stat.h) \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audio_mvs.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audio_out.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audio_out.o.cmd:  include/linux/wakelock.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audio_out.o.cmd:    $(wildcard include/config/has/wakelock.h) \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audio_out.o.cmd:    $(wildcard include/config/wakelock/stat.h) \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audio_pcm.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audio_pcm_in.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audio_qcelp.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audio_qcelp_in.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audio_wma.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audio_wmapro.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audpp.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audpp.o.cmd:  include/linux/wakelock.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audpp.o.cmd:    $(wildcard include/config/has/wakelock.h) \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audpp.o.cmd:    $(wildcard include/config/wakelock/stat.h) \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audpp.o.cmd:    $(wildcard include/config/att/wakeup.h) \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audpreproc.o.cmd:  include/linux/wakelock.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audpreproc.o.cmd:    $(wildcard include/config/has/wakelock.h) \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.audpreproc.o.cmd:    $(wildcard include/config/wakelock/stat.h) \
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_pcm.o matches
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_pcm_in.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_pcm_in.c:		wake_up(&audio->wait_enable);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_pcm_in.c:		wake_up(&audio->wait_enable);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_pcm_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_pcm_in.c:	wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_pcm_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_pcm_in.c:			/* Make sure we're stopped and we wake any threads
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_pcm_in.c:			wake_up(&audio->wait);
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_pcm_in.o matches
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_qcelp.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_qcelp.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_qcelp.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_qcelp.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_qcelp.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_qcelp.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_qcelp.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_qcelp.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_qcelp.c:		wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_qcelp.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_qcelp.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_qcelp.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_qcelp.c:	wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_qcelp.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_qcelp.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_qcelp.c:	wake_up(&audio->event_wait);
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_qcelp.o matches
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_qcelp_in.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_qcelp_in.c:		wake_up(&audio->wait_enable);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_qcelp_in.c:		wake_up(&audio->wait_enable);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_qcelp_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_qcelp_in.c:	wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_qcelp_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_qcelp_in.c:			/* Make sure we're stopped and we wake any threads
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_qcelp_in.c:			wake_up(&audio->wait);
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_qcelp_in.o matches
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wma.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wma.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wma.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wma.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wma.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wma.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wma.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wma.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wma.c:		wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wma.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wma.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wma.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wma.c:	wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wma.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wma.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wma.c:	wake_up(&audio->event_wait);
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wma.o matches
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wmapro.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wmapro.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wmapro.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wmapro.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wmapro.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wmapro.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wmapro.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wmapro.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wmapro.c:		wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wmapro.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wmapro.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wmapro.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wmapro.c:	wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wmapro.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wmapro.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wmapro.c:	wake_up(&audio->event_wait);
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_wmapro.o matches
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audpp.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audpp.c:static struct wake_lock audpp_wake_lock;
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audpp.c:	wake_lock(&audpp_wake_lock);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audpp.c:	wake_unlock(&audpp_wake_lock);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audpp.c:			wake_up(&audpp->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audpp.c:	wake_lock_init(&audpp_wake_lock, WAKE_LOCK_SUSPEND, "audpp");
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/audpp.o matches
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audpreproc.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audpreproc.c:static struct wake_lock audpre_wake_lock;
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audpreproc.c:static struct wake_lock audpre_idle_wake_lock;
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audpreproc.c:	wake_lock(&audpre_wake_lock);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audpreproc.c:	wake_lock(&audpre_idle_wake_lock);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audpreproc.c:	wake_unlock(&audpre_wake_lock);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audpreproc.c:	wake_unlock(&audpre_idle_wake_lock);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audpreproc.c:	static int wakelock_init;
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audpreproc.c:	if (!wakelock_init) {
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audpreproc.c:		wake_lock_init(&audpre_wake_lock, WAKE_LOCK_SUSPEND, "audpre");
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audpreproc.c:		wake_lock_init(&audpre_idle_wake_lock, WAKE_LOCK_IDLE,
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audpreproc.c:		wakelock_init = 1;
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/audpreproc.o matches
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/aux_pcm.o matches
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/built-in.o matches
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/lpa.o matches
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac_in.o matches
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_acdb.c:	wake_up(&acdb_data.wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_acdb.c:	wake_up(&acdb_data.wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_acdb.c:	wake_up(&acdb_data.wait);
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_acdb.o matches
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_adpcm.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_adpcm.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_adpcm.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_adpcm.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_adpcm.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_adpcm.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_adpcm.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_adpcm.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_adpcm.c:		wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_adpcm.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_adpcm.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_adpcm.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_adpcm.c:	wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_adpcm.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_adpcm.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_adpcm.c:	wake_up(&audio->event_wait);
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_adpcm.o matches
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrnb.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrnb.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrnb.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrnb.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrnb.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrnb.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrnb.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrnb.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrnb.c:		wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrnb.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrnb.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrnb.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrnb.c:	wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrnb.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrnb.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrnb.c:	wake_up(&audio->event_wait);
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrnb.o matches
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrnb_in.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrnb_in.c:		wake_up(&audio->wait_enable);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrnb_in.c:		wake_up(&audio->wait_enable);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrnb_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrnb_in.c:	wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrnb_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrnb_in.c:			/* Make sure we're stopped and we wake any threads
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrnb_in.c:			wake_up(&audio->wait);
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrnb_in.o matches
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrwb.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrwb.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrwb.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrwb.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrwb.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrwb.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrwb.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrwb.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrwb.c:		wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrwb.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrwb.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrwb.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrwb.c:	wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrwb.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrwb.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrwb.c:	wake_up(&audio->event_wait);
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_amrwb.o matches
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_dev_ctl.c:	wake_up(&audio_dev_ctrl.wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_dev_ctl.c:			wake_up(&audio_dev_ctrl.wait);
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_dev_ctl.o matches
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_evrc.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_evrc.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_evrc.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_evrc.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_evrc.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_evrc.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_evrc.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_evrc.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_evrc.c:		wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_evrc.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_evrc.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_evrc.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_evrc.c:	wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_evrc.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_evrc.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_evrc.c:	wake_up(&audio->event_wait);
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_evrc.o matches
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_evrc_in.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_evrc_in.c:		wake_up(&audio->wait_enable);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_evrc_in.c:		wake_up(&audio->wait_enable);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_evrc_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_evrc_in.c:	wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_evrc_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_evrc_in.c:			/* Make sure we're stopped and we wake any threads
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_evrc_in.c:			wake_up(&audio->wait);
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_evrc_in.o matches
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_fm.o matches
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_interct.o matches
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_lpa.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_lpa.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_lpa.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_lpa.c:				wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_lpa.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_lpa.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_lpa.c:		wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_lpa.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_lpa.c:		wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_lpa.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_lpa.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_lpa.c:	wake_up(&audio->event_wait);
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_lpa.o matches
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mp3.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mp3.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mp3.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mp3.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mp3.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mp3.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mp3.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mp3.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mp3.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mp3.c:		wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mp3.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mp3.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mp3.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mp3.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mp3.c:	wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mp3.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mp3.c:			wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mp3.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mp3.c:	wake_up(&audio->event_wait);
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mp3.o matches
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mvs.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mvs.c:	struct wake_lock suspend_lock;
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mvs.c:	struct wake_lock idle_lock;
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mvs.c:	wake_lock(&audio->suspend_lock);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mvs.c:	wake_lock(&audio->idle_lock);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mvs.c:			wake_up(&audio->out_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mvs.c:	wake_unlock(&audio->suspend_lock);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mvs.c:	wake_unlock(&audio->idle_lock);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mvs.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mvs.c:					wake_up(&audio->mode_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mvs.c:		wake_up(&audio->out_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mvs.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mvs.c:	wake_lock_init(&audio_mvs_info.suspend_lock,
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mvs.c:	wake_lock_init(&audio_mvs_info.idle_lock,
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_mvs.o matches
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_out.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_out.c:	struct wake_lock wakelock;
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_out.c:	struct wake_lock idlelock;
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_out.c:	wake_lock(&audio->wakelock);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_out.c:	wake_lock(&audio->idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_out.c:	wake_unlock(&audio->wakelock);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_out.c:	wake_unlock(&audio->idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_out.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_out.c:			wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_out.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_out.c:			/* Make sure we're stopped and we wake any threads
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_out.c:			wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_out.c:	wake_lock_init(&the_audio.wakelock, WAKE_LOCK_SUSPEND, "audio_pcm");
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_out.c:	wake_lock_init(&the_audio.idlelock, WAKE_LOCK_IDLE, "audio_pcm_idle");
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_out.o matches
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.lpa.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.mi2s.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.snddev_data_marimba.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.snddev_data_marimba.o.cmd:    $(wildcard include/config/att/wakeup.h) \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.snddev_ecodec.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.snddev_icodec.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.snddev_icodec.o.cmd:  include/linux/wakelock.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.snddev_icodec.o.cmd:    $(wildcard include/config/has/wakelock.h) \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.snddev_icodec.o.cmd:    $(wildcard include/config/wakelock/stat.h) \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.snddev_mi2s.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.snddev_virtual.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/adsp.c:		wake_up(&adsp_info.init_info_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/adsp.c:		wake_up(&module->state_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/adsp.c:		wake_up(&module->state_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/adsp.c:		wake_up(&module->state_wait);
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/adsp.o matches
NeoLKernel/arch/arm/mach-msm/qdsp5v2/adsp_driver.c:		wake_up(&adev->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/adsp_driver.c:	wake_up(&adev->event_wait);
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/adsp_driver.o matches
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/adsp_info.o matches
NeoLKernel/arch/arm/mach-msm/qdsp5v2/afe.c:		wake_up(&afe->wait);
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/afe.o matches
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_a2dp_in.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_a2dp_in.c:		wake_up(&audio->wait_enable);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_a2dp_in.c:		wake_up(&audio->wait_enable);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_a2dp_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_a2dp_in.c:	wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_a2dp_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_a2dp_in.c:			/* Make sure we're stopped and we wake any threads
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_a2dp_in.c:			wake_up(&audio->wait);
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_a2dp_in.o matches
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac.c:		wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac.c:	wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac.c:	wake_up(&audio->event_wait);
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac.o matches
NeoLKernel/arch/arm/mach-msm/qdsp5v2/.aux_pcm.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac_in.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac_in.c:		wake_up(&audio->wait_enable);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac_in.c:				wake_up(&audio->wait_enable);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac_in.c:		wake_up(&audio->wait_enable);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac_in.c:			wake_up(&audio->wait_enable);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac_in.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac_in.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac_in.c:	wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac_in.c:	wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac_in.c:		wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac_in.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac_in.c:	wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac_in.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_aac_in.c:	MM_DBG("waked on by some event audio->wflush = %d\n", audio->wflush);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_pcm.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_pcm.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_pcm.c:					wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_pcm.c:				wake_up(&audio->wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_pcm.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_pcm.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_pcm.c:		wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_pcm.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_pcm.c:			wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_pcm.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_pcm.c:	wake_up(&audio->avsync_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_pcm.c:		wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_pcm.c:	wake_up(&audio->event_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/audio_pcm.c:	wake_up(&audio->event_wait);
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/mi2s.o matches
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/snddev_data_marimba.o matches
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/snddev_ecodec.o matches
NeoLKernel/arch/arm/mach-msm/qdsp5v2/snddev_icodec.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/qdsp5v2/snddev_icodec.c:	struct wake_lock rx_idlelock;
NeoLKernel/arch/arm/mach-msm/qdsp5v2/snddev_icodec.c:	struct wake_lock tx_idlelock;
NeoLKernel/arch/arm/mach-msm/qdsp5v2/snddev_icodec.c:	wake_lock(&drv->rx_idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/snddev_icodec.c:	wake_unlock(&drv->rx_idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/snddev_icodec.c:	wake_unlock(&drv->rx_idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/snddev_icodec.c:	wake_lock(&drv->tx_idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/snddev_icodec.c:	wake_unlock(&drv->tx_idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/snddev_icodec.c:	wake_unlock(&drv->tx_idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/snddev_icodec.c:	wake_lock(&drv->rx_idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/snddev_icodec.c:	wake_unlock(&drv->rx_idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/snddev_icodec.c:	wake_lock(&drv->tx_idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/snddev_icodec.c:	wake_unlock(&drv->tx_idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/snddev_icodec.c:	wake_lock_init(&icodec_drv->tx_idlelock, WAKE_LOCK_IDLE,
NeoLKernel/arch/arm/mach-msm/qdsp5v2/snddev_icodec.c:	wake_lock_init(&icodec_drv->rx_idlelock, WAKE_LOCK_IDLE,
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/snddev_icodec.o matches
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/snddev_mi2s.o matches
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/snddev_virtual.o matches
NeoLKernel/arch/arm/mach-msm/qdsp5v2/voice.c:				wake_up(&v->dev_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/voice.c:				wake_up(&v->dev_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/voice.c:				wake_up(&v->dev_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/voice.c:				wake_up(&v->dev_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/voice.c:				wake_up(&v->dev_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/voice.c:				wake_up(&v->dev_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/voice.c:				wake_up(&v->dev_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/voice.c:				wake_up(&v->dev_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/voice.c:				wake_up(&v->dev_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/voice.c:		wake_up(&v->dev_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/voice.c:		wake_up(&v->voc_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/voice.c:		wake_up(&v->dev_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/voice.c:		wake_up(&v->voc_wait);
NeoLKernel/arch/arm/mach-msm/qdsp5v2/voice.c:			wake_up(&v->voc_wait);
Binary file NeoLKernel/arch/arm/mach-msm/qdsp5v2/voice.o matches
NeoLKernel/arch/arm/mach-msm/qdsp6/aac_in.c:		/*wake up client, if any*/
NeoLKernel/arch/arm/mach-msm/qdsp6/aac_in.c:		wake_up(&fc->fc_wq);
NeoLKernel/arch/arm/mach-msm/qdsp6/audiov2/q6audio.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/qdsp6/audiov2/q6audio.c:static struct wake_lock idlelock;
NeoLKernel/arch/arm/mach-msm/qdsp6/audiov2/q6audio.c:		wake_lock(&idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp6/audiov2/q6audio.c:		wake_unlock(&idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp6/audiov2/q6audio.c:			wake_up(&ac->wait);
NeoLKernel/arch/arm/mach-msm/qdsp6/audiov2/q6audio.c:		wake_up(&ac->wait);
NeoLKernel/arch/arm/mach-msm/qdsp6/audiov2/q6audio.c:		wake_up(&ac->wait);
NeoLKernel/arch/arm/mach-msm/qdsp6/audiov2/q6audio.c:	wake_lock_init(&idlelock, WAKE_LOCK_IDLE, "audio_pcm_idle");
NeoLKernel/arch/arm/mach-msm/qdsp6/dal.c:			wake_up(&client->wait);
NeoLKernel/arch/arm/mach-msm/qdsp6/dsp_debug.c:		wake_up(&dsp_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6/dsp_debug.c:		wake_up(&dsp_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6/evrc_in.c:		/*wake up client, if any*/
NeoLKernel/arch/arm/mach-msm/qdsp6/evrc_in.c:		wake_up(&fc->fc_wq);
NeoLKernel/arch/arm/mach-msm/qdsp6/msm_q6vdec.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/qdsp6/msm_q6vdec.c:static struct wake_lock wakelock;
NeoLKernel/arch/arm/mach-msm/qdsp6/msm_q6vdec.c:static struct wake_lock idlelock;
NeoLKernel/arch/arm/mach-msm/qdsp6/msm_q6vdec.c:		wake_lock(&idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp6/msm_q6vdec.c:		wake_lock(&wakelock);
NeoLKernel/arch/arm/mach-msm/qdsp6/msm_q6vdec.c:		wake_unlock(&idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp6/msm_q6vdec.c:		wake_unlock(&wakelock);
NeoLKernel/arch/arm/mach-msm/qdsp6/msm_q6vdec.c:		wake_up(&vd->vdec_msg_evt);
NeoLKernel/arch/arm/mach-msm/qdsp6/msm_q6vdec.c:	wake_up(&vd->vdec_msg_evt);
NeoLKernel/arch/arm/mach-msm/qdsp6/msm_q6vdec.c:	wake_up_all(&vd->vdec_msg_evt);
NeoLKernel/arch/arm/mach-msm/qdsp6/msm_q6vdec.c:	wake_lock_init(&idlelock, WAKE_LOCK_IDLE, "vdec_idle");
NeoLKernel/arch/arm/mach-msm/qdsp6/msm_q6vdec.c:	wake_lock_init(&wakelock, WAKE_LOCK_SUSPEND, "vdec_suspend");
NeoLKernel/arch/arm/mach-msm/qdsp6/msm_q6venc.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/qdsp6/msm_q6venc.c:static struct wake_lock wakelock;
NeoLKernel/arch/arm/mach-msm/qdsp6/msm_q6venc.c:static struct wake_lock idlelock;
NeoLKernel/arch/arm/mach-msm/qdsp6/msm_q6venc.c:		wake_lock(&idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp6/msm_q6venc.c:		wake_lock(&wakelock);
NeoLKernel/arch/arm/mach-msm/qdsp6/msm_q6venc.c:		wake_unlock(&idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp6/msm_q6venc.c:		wake_unlock(&wakelock);
NeoLKernel/arch/arm/mach-msm/qdsp6/msm_q6venc.c:		wake_up(&dvenc->venc_msg_evt);
NeoLKernel/arch/arm/mach-msm/qdsp6/msm_q6venc.c:	wake_up(&dvenc->venc_msg_evt);
NeoLKernel/arch/arm/mach-msm/qdsp6/msm_q6venc.c:	wake_up_all(&dvenc->venc_msg_evt);
NeoLKernel/arch/arm/mach-msm/qdsp6/msm_q6venc.c:	wake_lock_init(&idlelock, WAKE_LOCK_IDLE, "venc_idle");
NeoLKernel/arch/arm/mach-msm/qdsp6/msm_q6venc.c:	wake_lock_init(&wakelock, WAKE_LOCK_SUSPEND, "venc_suspend");
NeoLKernel/arch/arm/mach-msm/qdsp6/q6audio.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/qdsp6/q6audio.c:static struct wake_lock wakelock;
NeoLKernel/arch/arm/mach-msm/qdsp6/q6audio.c:static struct wake_lock idlelock;
NeoLKernel/arch/arm/mach-msm/qdsp6/q6audio.c:		wake_lock(&wakelock);
NeoLKernel/arch/arm/mach-msm/qdsp6/q6audio.c:		wake_lock(&idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp6/q6audio.c:		wake_unlock(&idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp6/q6audio.c:		wake_unlock(&wakelock);
NeoLKernel/arch/arm/mach-msm/qdsp6/q6audio.c:			wake_up(&ac->wait);
NeoLKernel/arch/arm/mach-msm/qdsp6/q6audio.c:		wake_up(&ac->wait);
NeoLKernel/arch/arm/mach-msm/qdsp6/q6audio.c:		wake_up(&ac->wait);
NeoLKernel/arch/arm/mach-msm/qdsp6/q6audio.c:	wake_lock_init(&idlelock, WAKE_LOCK_IDLE, "audio_pcm_idle");
NeoLKernel/arch/arm/mach-msm/qdsp6/q6audio.c:	wake_lock_init(&wakelock, WAKE_LOCK_SUSPEND, "audio_pcm_suspend");
NeoLKernel/arch/arm/mach-msm/qdsp6/qcelp_in.c:		/*wake up client, if any*/
NeoLKernel/arch/arm/mach-msm/qdsp6/qcelp_in.c:		wake_up(&fc->fc_wq);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/aac_in.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/aac_in.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/aac_in.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/aac_in.c:		wake_up(&audio->cmd_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/aac_in.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/aac_in.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/aac_in.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/aac_in.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/aac_in.c:		/* Make sure we're stopped and we wake any threads
NeoLKernel/arch/arm/mach-msm/qdsp6v2/aac_in.c:		wake_up(&audio->cmd_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/amrnb_in.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/amrnb_in.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/amrnb_in.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/amrnb_in.c:		wake_up(&audio->cmd_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/amrnb_in.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/amrnb_in.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/amrnb_in.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/amrnb_in.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/amrnb_in.c:		/* Make sure we're stopped and we wake any threads
NeoLKernel/arch/arm/mach-msm/qdsp6v2/amrnb_in.c:		wake_up(&audio->cmd_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/apr_tal.c:			wake_up(&apr_ch->wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/apr_tal.c:		wake_up(&apr_ch->wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/apr_tal.c:		wake_up(&apr_svc_ch[APR_DL_SMD][dest][clnt].dest);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/apr_tal.c:		wake_up(&apr_svc_ch[APR_DL_SMD][dest][clnt].dest);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/audio_dev_ctl.c:	wake_up(&audio_dev_ctrl.wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/audio_dev_ctl.c:			wake_up(&audio_dev_ctrl.wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/evrc_in.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/evrc_in.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/evrc_in.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/evrc_in.c:		wake_up(&audio->cmd_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/evrc_in.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/evrc_in.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/evrc_in.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/evrc_in.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/evrc_in.c:		/* Make sure we're stopped and we wake any threads
NeoLKernel/arch/arm/mach-msm/qdsp6v2/evrc_in.c:		wake_up(&audio->cmd_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/pcm_in.c:	wake_up(&pcm->wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/pcm_in.c:		wake_up(&pcm->wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/pcm_out.c:		wake_up(&pcm->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/pcm_out.c:		wake_up(&pcm->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/q6adm.c:				wake_up(&this_adm.wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/q6adm.c:			wake_up(&this_adm.wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/q6afe.c:				wake_up(&this_afe.wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/q6asm.c:				wake_up(&this_mmap.cmd_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/q6asm.c:				wake_up(&ac->cmd_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/q6asm.c:			wake_up(&ac->cmd_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/q6voice.c:				wake_up(&v->mvm_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/q6voice.c:				wake_up(&v->mvm_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/q6voice.c:				wake_up(&v->mvm_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/q6voice.c:				wake_up(&v->mvm_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/q6voice.c:				wake_up(&v->mvm_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/q6voice.c:				wake_up(&v->mvm_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/q6voice.c:				wake_up(&v->cvs_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/q6voice.c:				wake_up(&v->cvs_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/q6voice.c:				wake_up(&v->cvs_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/q6voice.c:				wake_up(&v->cvp_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/q6voice.c:				wake_up(&v->cvp_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/q6voice.c:				wake_up(&v->cvp_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/q6voice.c:				wake_up(&v->cvp_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/q6voice.c:				wake_up(&v->cvp_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/qcelp_in.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/qcelp_in.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/qcelp_in.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/qcelp_in.c:		wake_up(&audio->cmd_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/qcelp_in.c:		wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/qcelp_in.c:		wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/qcelp_in.c:	wake_up(&audio->read_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/qcelp_in.c:	wake_up(&audio->write_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/qcelp_in.c:		/* Make sure we're stopped and we wake any threads
NeoLKernel/arch/arm/mach-msm/qdsp6v2/qcelp_in.c:		wake_up(&audio->cmd_wait);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/snddev_icodec.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/qdsp6v2/snddev_icodec.c:	struct wake_lock rx_idlelock;
NeoLKernel/arch/arm/mach-msm/qdsp6v2/snddev_icodec.c:	struct wake_lock tx_idlelock;
NeoLKernel/arch/arm/mach-msm/qdsp6v2/snddev_icodec.c:	wake_lock(&drv->rx_idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/snddev_icodec.c:	wake_unlock(&drv->rx_idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/snddev_icodec.c:	wake_unlock(&drv->rx_idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/snddev_icodec.c:	wake_lock(&drv->tx_idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/snddev_icodec.c:	wake_unlock(&drv->tx_idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/snddev_icodec.c:	wake_unlock(&drv->tx_idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/snddev_icodec.c:	wake_lock(&drv->rx_idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/snddev_icodec.c:	wake_unlock(&drv->rx_idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/snddev_icodec.c:	wake_lock(&drv->tx_idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/snddev_icodec.c:	wake_unlock(&drv->tx_idlelock);
NeoLKernel/arch/arm/mach-msm/qdsp6v2/snddev_icodec.c:	wake_lock_init(&icodec_drv->tx_idlelock, WAKE_LOCK_IDLE,
NeoLKernel/arch/arm/mach-msm/qdsp6v2/snddev_icodec.c:	wake_lock_init(&icodec_drv->rx_idlelock, WAKE_LOCK_IDLE,
Binary file NeoLKernel/arch/arm/mach-msm/board-semc_zeus.o matches
NeoLKernel/arch/arm/mach-msm/board-trout-gpio.c:int trout_gpio_irq_set_wake(unsigned int irq, unsigned int on)
NeoLKernel/arch/arm/mach-msm/board-trout-gpio.c:	.set_wake  = trout_gpio_irq_set_wake,
NeoLKernel/arch/arm/mach-msm/board-trout-gpio.c:	set_irq_wake(MSM_GPIO_TO_INT(17), 1);
NeoLKernel/arch/arm/mach-msm/board-trout-mmc.c:	set_irq_wake(TROUT_GPIO_TO_INT(TROUT_GPIO_SDMC_CD_N), 1);
NeoLKernel/arch/arm/mach-msm/board-trout.c:	.wakeup_irq = MSM_GPIO_TO_INT(45),
NeoLKernel/arch/arm/mach-msm/board-trout.c:	.inject_rx_on_wakeup = 1,
NeoLKernel/arch/arm/mach-msm/board-trout.c:	/* SD card door should wake the device */
NeoLKernel/arch/arm/mach-msm/board-trout.c:	set_irq_wake(TROUT_GPIO_TO_INT(TROUT_GPIO_SD_DOOR_N), 1);
Binary file NeoLKernel/arch/arm/mach-msm/built-in.o matches
NeoLKernel/arch/arm/mach-msm/board-mahimahi-microp.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/board-mahimahi-microp.c:static struct wake_lock microp_i2c_wakelock;
NeoLKernel/arch/arm/mach-msm/board-mahimahi-microp.c:		wake_lock_timeout(&microp_i2c_wakelock, 3*HZ);
NeoLKernel/arch/arm/mach-msm/board-mahimahi-microp.c:	wake_lock_init(&microp_i2c_wakelock, WAKE_LOCK_SUSPEND,
NeoLKernel/arch/arm/mach-msm/board-mahimahi-microp.c:	ret = set_irq_wake(client->irq, 1);
NeoLKernel/arch/arm/mach-msm/board-mahimahi-microp.c:		dev_err(&client->dev, "set_irq_wake failed\n");
NeoLKernel/arch/arm/mach-msm/board-mahimahi-microp.c:	wake_lock_destroy(&microp_i2c_wakelock);
NeoLKernel/arch/arm/mach-msm/board-mahimahi-mmc.c:		set_irq_wake(MSM_GPIO_TO_INT(MAHIMAHI_GPIO_SDMC_CD_REV0_N), 1);
NeoLKernel/arch/arm/mach-msm/board-mahimahi.c:	.gpio_a1026_wakeup = MAHIMAHI_AUD_A1026_WAKEUP,
NeoLKernel/arch/arm/mach-msm/board-mahimahi.c:	.rx_wakeup_irq = -1,
NeoLKernel/arch/arm/mach-msm/board-mahimahi.c:	.inject_rx_on_wakeup = 0,
NeoLKernel/arch/arm/mach-msm/board-mahimahi.c:	.gpio_wake = MAHIMAHI_GPIO_BT_WAKE,
NeoLKernel/arch/arm/mach-msm/board-mahimahi.c:	.gpio_host_wake = MAHIMAHI_GPIO_BT_HOST_WAKE,
NeoLKernel/arch/arm/mach-msm/board-mahimahi.c:		bcm_bt_lpm_pdata.gpio_wake = MAHIMAHI_CDMA_GPIO_BT_WAKE;
NeoLKernel/arch/arm/mach-msm/board-mahimahi.c:			a1026_data.gpio_a1026_wakeup = MAHIMAHI_CDMA_XB_AUD_A1026_WAKEUP;
NeoLKernel/arch/arm/mach-msm/board-msm7x27.c:		.name	= "gpio_host_wake",
NeoLKernel/arch/arm/mach-msm/board-msm7x27.c:		.name	= "gpio_ext_wake",
NeoLKernel/arch/arm/mach-msm/board-msm7x27.c:		.name	= "host_wake",
NeoLKernel/arch/arm/mach-msm/board-msm7x27.c:	.sdiowakeup_irq = MSM_GPIO_TO_INT(66),
NeoLKernel/arch/arm/mach-msm/board-msm7x30.c:	/* add any special code to strobe a wakeup pin or chip reset */
NeoLKernel/arch/arm/mach-msm/board-msm7x30.c:	.wakeup			= 1,
NeoLKernel/arch/arm/mach-msm/board-msm7x30.c:	.wakeup			= 1,
NeoLKernel/arch/arm/mach-msm/board-msm7x30.c:	.can_wakeup	= false,
NeoLKernel/arch/arm/mach-msm/board-msm7x30.c:	.can_wakeup	= false,
NeoLKernel/arch/arm/mach-msm/board-msm7x30.c:       .inject_rx_on_wakeup = 1,
NeoLKernel/arch/arm/mach-msm/board-msm7x30.c:	.sdiowakeup_irq = MSM_GPIO_TO_INT(118),
NeoLKernel/arch/arm/mach-msm/board-msm7x30.c:	.awake_vlevel = 0xF2,
NeoLKernel/arch/arm/mach-msm/board-msm7x30.c:	.wakeup = 1,
NeoLKernel/arch/arm/mach-msm/board-msm7x30.c:	msm_uart_dm1_pdata.wakeup_irq = gpio_to_irq(136);
NeoLKernel/arch/arm/mach-msm/board-msm8x60.c:		.awake_vlevel = 0x9C,
NeoLKernel/arch/arm/mach-msm/board-msm8x60.c:		.awake_vlevel = 0x9C,
NeoLKernel/arch/arm/mach-msm/board-msm8x60.c:       .inject_rx_on_wakeup = 1,
NeoLKernel/arch/arm/mach-msm/board-msm8x60.c:	.wakeup			= 1,
NeoLKernel/arch/arm/mach-msm/board-msm8x60.c:	.wakeup			= 1,
NeoLKernel/arch/arm/mach-msm/board-msm8x60.c:	.othc_wakeup = 1,
NeoLKernel/arch/arm/mach-msm/board-msm8x60.c:	.tdisc_wakeup  = 1,
NeoLKernel/arch/arm/mach-msm/board-msm8x60.c:	msm_uart_dm1_pdata.wakeup_irq = gpio_to_irq(54); /* GSBI6(2) */
NeoLKernel/arch/arm/mach-msm/board-qsd8x50.c:		.name	= "gpio_host_wake",
NeoLKernel/arch/arm/mach-msm/board-qsd8x50.c:		.name	= "gpio_ext_wake",
NeoLKernel/arch/arm/mach-msm/board-qsd8x50.c:		.name	= "host_wake",
NeoLKernel/arch/arm/mach-msm/msm8660-gpio.c: * @wake_irqs: a bitmap for tracking which interrupt lines are enabled
NeoLKernel/arch/arm/mach-msm/msm8660-gpio.c: * as wakeup sources.  When the device is suspended, interrupts which are
NeoLKernel/arch/arm/mach-msm/msm8660-gpio.c: * not wakeup sources are disabled.
NeoLKernel/arch/arm/mach-msm/msm8660-gpio.c:	DECLARE_BITMAP(wake_irqs, NR_MSM_GPIOS);
NeoLKernel/arch/arm/mach-msm/msm8660-gpio.c:static int msm_gpio_irq_set_wake(unsigned int irq, unsigned int on)
NeoLKernel/arch/arm/mach-msm/msm8660-gpio.c:		if (bitmap_empty(msm_gpio.wake_irqs, NR_MSM_GPIOS))
NeoLKernel/arch/arm/mach-msm/msm8660-gpio.c:			set_irq_wake(TLMM_SCSS_SUMMARY_IRQ, 1);
NeoLKernel/arch/arm/mach-msm/msm8660-gpio.c:		set_bit(gpio, msm_gpio.wake_irqs);
NeoLKernel/arch/arm/mach-msm/msm8660-gpio.c:		clear_bit(gpio, msm_gpio.wake_irqs);
NeoLKernel/arch/arm/mach-msm/msm8660-gpio.c:		if (bitmap_empty(msm_gpio.wake_irqs, NR_MSM_GPIOS))
NeoLKernel/arch/arm/mach-msm/msm8660-gpio.c:			set_irq_wake(TLMM_SCSS_SUMMARY_IRQ, 0);
NeoLKernel/arch/arm/mach-msm/msm8660-gpio.c:	.set_wake	= msm_gpio_irq_set_wake,
NeoLKernel/arch/arm/mach-msm/msm8660-gpio.c:	bitmap_zero(msm_gpio.wake_irqs, NR_MSM_GPIOS);
NeoLKernel/arch/arm/mach-msm/msm8660-gpio.c:		if (!test_bit(i, msm_gpio.wake_irqs))
Binary file NeoLKernel/arch/arm/mach-msm/acpuclock-7x30.o matches
NeoLKernel/arch/arm/mach-msm/board-comet.c:	.wakeup_irq = MSM_GPIO_TO_INT(45),
NeoLKernel/arch/arm/mach-msm/board-comet.c:	.inject_rx_on_wakeup = 1,
NeoLKernel/arch/arm/mach-msm/board-comet.c:		.name	= "gpio_host_wake",
NeoLKernel/arch/arm/mach-msm/board-comet.c:		.name	= "gpio_ext_wake",
NeoLKernel/arch/arm/mach-msm/board-comet.c:		.name	= "host_wake",
NeoLKernel/arch/arm/mach-msm/board-halibut.c:		.name	= "gpio_host_wake",
NeoLKernel/arch/arm/mach-msm/board-halibut.c:		.name	= "gpio_ext_wake",
NeoLKernel/arch/arm/mach-msm/board-halibut.c:		.name	= "host_wake",
NeoLKernel/arch/arm/mach-msm/.pmic8058-gpio.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.pmic8058-mpp.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.rmt_storage_client.o.cmd:  include/linux/wakelock.h \
NeoLKernel/arch/arm/mach-msm/.rmt_storage_client.o.cmd:    $(wildcard include/config/has/wakelock.h) \
NeoLKernel/arch/arm/mach-msm/.rmt_storage_client.o.cmd:    $(wildcard include/config/wakelock/stat.h) \
NeoLKernel/arch/arm/mach-msm/.rmt_storage_client.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.rpcrouter_sdio_xprt.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.rpcrouter_sdio_xprt.o.cmd:  include/linux/wakelock.h \
NeoLKernel/arch/arm/mach-msm/.rpcrouter_sdio_xprt.o.cmd:    $(wildcard include/config/has/wakelock.h) \
NeoLKernel/arch/arm/mach-msm/.rpcrouter_sdio_xprt.o.cmd:    $(wildcard include/config/wakelock/stat.h) \
NeoLKernel/arch/arm/mach-msm/.rpcrouter_smd_xprt.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.rpcrouter_smd_xprt.o.cmd:  include/linux/wakelock.h \
NeoLKernel/arch/arm/mach-msm/.rpcrouter_smd_xprt.o.cmd:    $(wildcard include/config/has/wakelock.h) \
NeoLKernel/arch/arm/mach-msm/.rpcrouter_smd_xprt.o.cmd:    $(wildcard include/config/wakelock/stat.h) \
NeoLKernel/arch/arm/mach-msm/.rpc_dog_keepalive.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.rpc_fsusb.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.rpc_fsusb.o.cmd:  include/linux/wakelock.h \
NeoLKernel/arch/arm/mach-msm/.rpc_fsusb.o.cmd:    $(wildcard include/config/has/wakelock.h) \
NeoLKernel/arch/arm/mach-msm/.rpc_fsusb.o.cmd:    $(wildcard include/config/wakelock/stat.h) \
NeoLKernel/arch/arm/mach-msm/.rpc_fsusb.o.cmd:    $(wildcard include/config/att/wakeup.h) \
NeoLKernel/arch/arm/mach-msm/.rpc_hsusb.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.rpc_hsusb.o.cmd:  include/linux/wakelock.h \
NeoLKernel/arch/arm/mach-msm/.rpc_hsusb.o.cmd:    $(wildcard include/config/has/wakelock.h) \
NeoLKernel/arch/arm/mach-msm/.rpc_hsusb.o.cmd:    $(wildcard include/config/wakelock/stat.h) \
NeoLKernel/arch/arm/mach-msm/.rpc_pmapp.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.rpc_pmapp.o.cmd:    $(wildcard include/config/att/wakeup.h) \
NeoLKernel/arch/arm/mach-msm/.rpc_server_dog_keepalive.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.rpc_server_time_remote.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.sdio_al.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.sdio_al.o.cmd:  include/linux/wakelock.h \
NeoLKernel/arch/arm/mach-msm/.sdio_al.o.cmd:    $(wildcard include/config/has/wakelock.h) \
NeoLKernel/arch/arm/mach-msm/.sdio_al.o.cmd:    $(wildcard include/config/wakelock/stat.h) \
NeoLKernel/arch/arm/mach-msm/.sdio_ctl.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.semc_battery_data.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.semc_battery_data.o.cmd:  include/linux/wakelock.h \
NeoLKernel/arch/arm/mach-msm/.semc_battery_data.o.cmd:    $(wildcard include/config/has/wakelock.h) \
NeoLKernel/arch/arm/mach-msm/.semc_battery_data.o.cmd:    $(wildcard include/config/wakelock/stat.h) \
NeoLKernel/arch/arm/mach-msm/.semc_rpc_server_handset.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.semc_rpc_server_handset.o.cmd:    $(wildcard include/config/att/wakeup.h) \
NeoLKernel/arch/arm/mach-msm/.simple_remote_msm7x30_pf.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.smd.o.cmd:  include/linux/pm_wakeup.h \
Binary file NeoLKernel/arch/arm/mach-msm/semc_rpc_server_handset.o matches
NeoLKernel/arch/arm/mach-msm/simple_remote_msm7x30_pf.c:	 * a "unmatched irq_wake" print in the kernel log when shutting
NeoLKernel/arch/arm/mach-msm/simple_remote_msm7x30_pf.c:	err = enable_irq_wake(irq);
NeoLKernel/arch/arm/mach-msm/simple_remote_msm7x30_pf.c:			 "Failed to enable wakeup on interrupt\n");
NeoLKernel/arch/arm/mach-msm/simple_remote_msm7x30_pf.c:		disable_irq_wake(irq);
Binary file NeoLKernel/arch/arm/mach-msm/simple_remote_msm7x30_pf.o matches
NeoLKernel/arch/arm/mach-msm/sirc.c:static int sirc_irq_set_wake(unsigned int irq, unsigned int on);
NeoLKernel/arch/arm/mach-msm/sirc.c:static unsigned int wake_enable;
NeoLKernel/arch/arm/mach-msm/sirc.c:static int sirc_irq_set_wake(unsigned int irq, unsigned int on)
NeoLKernel/arch/arm/mach-msm/sirc.c:		wake_enable |= mask;
NeoLKernel/arch/arm/mach-msm/sirc.c:		wake_enable &= ~mask;
NeoLKernel/arch/arm/mach-msm/sirc.c:	writel(wake_enable, sirc_regs.int_enable);
NeoLKernel/arch/arm/mach-msm/sirc.c:	.set_wake  = sirc_irq_set_wake,
NeoLKernel/arch/arm/mach-msm/sirc.c:	wake_enable = 0;
NeoLKernel/arch/arm/mach-msm/sirc.c:		set_irq_wake(sirc_reg_table[i].cascade_irq, 1);
NeoLKernel/arch/arm/mach-msm/smd.c:	r = enable_irq_wake(INT_A9_M2A_0);
NeoLKernel/arch/arm/mach-msm/smd.c:		       "enable_irq_wake failed for INT_A9_M2A_0\n");
NeoLKernel/arch/arm/mach-msm/smd.c:	r = enable_irq_wake(INT_A9_M2A_5);
NeoLKernel/arch/arm/mach-msm/smd.c:		       "enable_irq_wake failed for INT_A9_M2A_5\n");
NeoLKernel/arch/arm/mach-msm/smd.c:	r = enable_irq_wake(INT_ADSP_A11);
NeoLKernel/arch/arm/mach-msm/smd.c:		       "enable_irq_wake failed for INT_ADSP_A11\n");
NeoLKernel/arch/arm/mach-msm/smd.c:	r = enable_irq_wake(INT_DSPS_A11);
NeoLKernel/arch/arm/mach-msm/smd.c:		       "enable_irq_wake failed for INT_ADSP_A11\n");
Binary file NeoLKernel/arch/arm/mach-msm/smd.o matches
NeoLKernel/arch/arm/mach-msm/smd_debug.c:	uint32_t irq_mask, uint32_t wakeup_reason, uint32_t pending_irqs)
NeoLKernel/arch/arm/mach-msm/smd_debug.c:		irq_mask, pending_irqs, wakeup_reason);
Binary file NeoLKernel/arch/arm/mach-msm/smd_debug.o matches
NeoLKernel/arch/arm/mach-msm/smd_nmea.c:		wake_up_interruptible(&nmea_wait_queue);
Binary file NeoLKernel/arch/arm/mach-msm/smd_nmea.o matches
NeoLKernel/arch/arm/mach-msm/smd_pkt.c:static void check_and_wakeup(struct smd_pkt_dev *smd_pkt_devp);
NeoLKernel/arch/arm/mach-msm/smd_pkt.c:	wake_up_interruptible(&smd_pkt_devp->ch_wait_queue);
NeoLKernel/arch/arm/mach-msm/smd_pkt.c:	wake_up_interruptible(&smd_pkt_devp->ch_opened_wait_queue);
NeoLKernel/arch/arm/mach-msm/smd_pkt.c:	/* check and wakeup read threads waiting on this device */
NeoLKernel/arch/arm/mach-msm/smd_pkt.c:	check_and_wakeup(smd_pkt_devp);
NeoLKernel/arch/arm/mach-msm/smd_pkt.c:static void check_and_wakeup(struct smd_pkt_dev *smd_pkt_devp)
NeoLKernel/arch/arm/mach-msm/smd_pkt.c:	wake_up_interruptible(&smd_pkt_devp->ch_wait_queue);
NeoLKernel/arch/arm/mach-msm/smd_pkt.c:	D(KERN_ERR "%s: after wake_up\n", __func__);
NeoLKernel/arch/arm/mach-msm/smd_pkt.c:		check_and_wakeup(smd_pkt_devp);
NeoLKernel/arch/arm/mach-msm/smd_pkt.c:		D(KERN_ERR "%s: data after check_and_wakeup\n", __func__);
NeoLKernel/arch/arm/mach-msm/smd_pkt.c:		wake_up_interruptible(&smd_pkt_devp->ch_opened_wait_queue);
Binary file NeoLKernel/arch/arm/mach-msm/smd_pkt.o matches
NeoLKernel/arch/arm/mach-msm/smd_private.h:	uint32_t aArm_wakeup_reason;
NeoLKernel/arch/arm/mach-msm/smd_private.h:  uint32_t aArm_wakeup_reason;
NeoLKernel/arch/arm/mach-msm/smd_private.h:	uint32_t irq_mask, uint32_t wakeup_reason, uint32_t pending_irqs);
NeoLKernel/arch/arm/mach-msm/smd_qmi.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/smd_qmi.c:	struct wake_lock wake_lock;
NeoLKernel/arch/arm/mach-msm/smd_qmi.c:	wake_lock_init(&ctxt->wake_lock, WAKE_LOCK_SUSPEND, ctxt->misc.name);
NeoLKernel/arch/arm/mach-msm/smd_qmi.c:	wake_up(&qmi_wait_queue);
NeoLKernel/arch/arm/mach-msm/smd_qmi.c:			wake_lock_timeout(&ctxt->wake_lock, HZ / 2);
NeoLKernel/arch/arm/mach-msm/smd_qmi.c:		wake_up(&qmi_wait_queue);
NeoLKernel/arch/arm/mach-msm/smd_qmi.c:		wake_up(&qmi_wait_queue);
Binary file NeoLKernel/arch/arm/mach-msm/smd_qmi.o matches
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:	struct wake_lock wakelock;
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:			wake_up(&ept->wait_q);
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:		wake_up(&r_ept->quota_wait);
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:	wake_lock_init(&ept->read_q_wake_lock, WAKE_LOCK_SUSPEND, "rpc_read");
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:	wake_lock_init(&ept->reply_q_wake_lock, WAKE_LOCK_SUSPEND, "rpc_reply");
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:	wake_lock_destroy(&ept->read_q_wake_lock);
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:	wake_lock_destroy(&ept->reply_q_wake_lock);
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:		wake_up(&r_ept->quota_wait);
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:			wake_up(&ept->restart_wait);
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:			wake_up(&ept->wait_q);
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:		wake_up(&r_ept->quota_wait);
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:			wake_up(&newserver_wait);
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:		wake_unlock(&xprt_info->wakelock);
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:	wake_lock_timeout(&ept->read_q_wake_lock, HZ*10);
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:	wake_up(&ept->wait_q);
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:void msm_rpc_read_wakeup(struct msm_rpc_endpoint *ept)
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:	ept->forced_wakeup = 1;
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:	wake_up(&ept->wait_q);
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:		wake_lock(&ept->reply_q_wake_lock);
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:	/* if reply, release wakelock after writing to the transport */
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:			wake_unlock(&ept->reply_q_wake_lock);
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:						   ept->forced_wakeup));
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:				 ept->forced_wakeup),
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:					      ept->forced_wakeup));
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:				 ept->forced_wakeup),
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:	if (ept->forced_wakeup) {
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:		ept->forced_wakeup = 0;
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:	/* release read wakelock after taking reply wakelock */
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:		wake_unlock(&ept->read_q_wake_lock);
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:	wake_lock_init(&xprt_info->wakelock,
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:		wake_lock(&xprt_info->wakelock);
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.c:	wake_up(&xprt_info->read_wait);
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.h:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.h:	struct wake_lock read_q_wake_lock;
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.h:	uint32_t forced_wakeup;
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.h:	struct wake_lock reply_q_wake_lock;
Binary file NeoLKernel/arch/arm/mach-msm/smd_rpcrouter.o matches
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter_clients.c:			wake_up(&client->reply_wait);
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter_clients.c:				wake_up(&client->cb_wait);
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter_clients.c:		msm_rpc_read_wakeup(client->ept);
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter_clients.c:		msm_rpc_read_wakeup(client->ept);
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter_clients.c:		wake_up(&client->cb_wait);
NeoLKernel/arch/arm/mach-msm/smd_rpcrouter_clients.c:	msm_rpc_read_wakeup(client->ept);
Binary file NeoLKernel/arch/arm/mach-msm/smd_rpcrouter_clients.o matches
NeoLKernel/arch/arm/mach-msm/.smd_nmea.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.smd_pkt.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.smd_qmi.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.smd_qmi.o.cmd:  include/linux/wakelock.h \
NeoLKernel/arch/arm/mach-msm/.smd_qmi.o.cmd:    $(wildcard include/config/has/wakelock.h) \
NeoLKernel/arch/arm/mach-msm/.smd_qmi.o.cmd:    $(wildcard include/config/wakelock/stat.h) \
NeoLKernel/arch/arm/mach-msm/.smd_rpcrouter.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.smd_rpcrouter.o.cmd:  include/linux/wakelock.h \
NeoLKernel/arch/arm/mach-msm/.smd_rpcrouter.o.cmd:    $(wildcard include/config/has/wakelock.h) \
NeoLKernel/arch/arm/mach-msm/.smd_rpcrouter.o.cmd:    $(wildcard include/config/wakelock/stat.h) \
NeoLKernel/arch/arm/mach-msm/.smd_rpcrouter_clients.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.smd_rpcrouter_clients.o.cmd:  include/linux/wakelock.h \
NeoLKernel/arch/arm/mach-msm/.smd_rpcrouter_clients.o.cmd:    $(wildcard include/config/has/wakelock.h) \
NeoLKernel/arch/arm/mach-msm/.smd_rpcrouter_clients.o.cmd:    $(wildcard include/config/wakelock/stat.h) \
NeoLKernel/arch/arm/mach-msm/.smd_rpcrouter_device.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.smd_rpcrouter_device.o.cmd:  include/linux/wakelock.h \
NeoLKernel/arch/arm/mach-msm/.smd_rpcrouter_device.o.cmd:    $(wildcard include/config/has/wakelock.h) \
NeoLKernel/arch/arm/mach-msm/.smd_rpcrouter_device.o.cmd:    $(wildcard include/config/wakelock/stat.h) \
NeoLKernel/arch/arm/mach-msm/.smd_rpcrouter_servers.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.smd_rpcrouter_servers.o.cmd:  include/linux/wakelock.h \
NeoLKernel/arch/arm/mach-msm/.smd_rpcrouter_servers.o.cmd:    $(wildcard include/config/has/wakelock.h) \
NeoLKernel/arch/arm/mach-msm/.smd_rpcrouter_servers.o.cmd:    $(wildcard include/config/wakelock/stat.h) \
NeoLKernel/arch/arm/mach-msm/.smd_rpcrouter_xdr.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.smd_tty.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.smd_tty.o.cmd:  include/linux/wakelock.h \
NeoLKernel/arch/arm/mach-msm/.smd_tty.o.cmd:    $(wildcard include/config/has/wakelock.h) \
NeoLKernel/arch/arm/mach-msm/.smd_tty.o.cmd:    $(wildcard include/config/wakelock/stat.h) \
NeoLKernel/arch/arm/mach-msm/.vibrator-mogami.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.vreg.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.io.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.io.o.cmd:    $(wildcard include/config/att/wakeup.h) \
NeoLKernel/arch/arm/mach-msm/.keypad-surf-ffa.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.keypad-zeus.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.mpp.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.nand_partitions.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.nand_partitions.o.cmd:    $(wildcard include/config/att/wakeup.h) \
NeoLKernel/arch/arm/mach-msm/.oem_rapi_client.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.ping_apps_server.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.ping_mdm_rpc_client.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/.pm2.o.cmd:    $(wildcard include/config/has/wakelock.h) \
NeoLKernel/arch/arm/mach-msm/.pm2.o.cmd:  include/linux/wakelock.h \
NeoLKernel/arch/arm/mach-msm/.pm2.o.cmd:    $(wildcard include/config/wakelock/stat.h) \
NeoLKernel/arch/arm/mach-msm/.pm2.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mach-msm/dal.c:		wake_up_all(&event_wq);
Binary file NeoLKernel/arch/arm/mach-msm/dal.o matches
NeoLKernel/arch/arm/mach-msm/gpio.c:	unsigned int            int_enable[2]; /* 0: awake, 1: sleep */
NeoLKernel/arch/arm/mach-msm/gpio.c:static int msm_gpio_irq_set_wake(unsigned int irq, unsigned int on)
NeoLKernel/arch/arm/mach-msm/gpio.c:	.set_wake  = msm_gpio_irq_set_wake,
NeoLKernel/arch/arm/mach-msm/gpio.c:	set_irq_wake(INT_GPIO_GROUP1, 1);
NeoLKernel/arch/arm/mach-msm/gpio.c:	set_irq_wake(INT_GPIO_GROUP2, 2);
Binary file NeoLKernel/arch/arm/mach-msm/gpio.o matches
NeoLKernel/arch/arm/mach-msm/rmt_storage_client.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/rmt_storage_client.c:	struct wake_lock wlock;
NeoLKernel/arch/arm/mach-msm/rmt_storage_client.c:		wake_lock(&_rmc->wlock);
NeoLKernel/arch/arm/mach-msm/rmt_storage_client.c:		wake_lock(&_rmc->wlock);
NeoLKernel/arch/arm/mach-msm/rmt_storage_client.c:		wake_lock(&_rmc->wlock);
NeoLKernel/arch/arm/mach-msm/rmt_storage_client.c:	wake_up(&rmc->event_q);
NeoLKernel/arch/arm/mach-msm/rmt_storage_client.c:				wake_unlock(&rmc->wlock);
NeoLKernel/arch/arm/mach-msm/rmt_storage_client.c:			wake_unlock(&rmc->wlock);
NeoLKernel/arch/arm/mach-msm/rmt_storage_client.c:	wake_lock_init(&rmc->wlock, WAKE_LOCK_SUSPEND, "rmt_storage");
NeoLKernel/arch/arm/mach-msm/rmt_storage_client.c:	wake_lock_destroy(&rmc->wlock);
Binary file NeoLKernel/arch/arm/mach-msm/rmt_storage_client.o matches
NeoLKernel/arch/arm/mach-msm/rpcrouter_sdio_xprt.c:#include <linux/wakelock.h>
NeoLKernel/arch/arm/mach-msm/rpcrouter_sdio_xprt.c:		wake_up(&write_avail_wait_q);
Binary file NeoLKernel/arch/arm/mach-msm/rpcrouter_sdio_xprt.o matches
Binary file NeoLKernel/arch/arm/mach-msm/rpcrouter_smd_xprt.o matches
Binary file NeoLKernel/arch/arm/mach-msm/rpc_dog_keepalive.o matches
NeoLKernel/arch/arm/mach-msm/rpc_fsusb.c:int  msm_fsusb_set_remote_wakeup(void)
NeoLKernel/arch/arm/mach-msm/rpc_fsusb.c:EXPORT_SYMBOL(msm_fsusb_set_remote_wakeup);
Binary file NeoLKernel/arch/arm/mach-msm/rpc_fsusb.o matches
Binary file NeoLKernel/arch/arm/mach-msm/rpc_hsusb.o matches
NeoLKernel/arch/arm/mach-omap1/board-osk.c:osk_mistral_wake_interrupt(int irq, void *ignored)
NeoLKernel/arch/arm/mach-omap1/board-osk.c:	/* the sideways button (SW1) is for use as a "wakeup" button
NeoLKernel/arch/arm/mach-omap1/board-osk.c:	 * NOTE:  The Mistral board has the wakeup button (SW1) wired
NeoLKernel/arch/arm/mach-omap1/board-osk.c:	 * To allow this button to wake up the omap, work around this
NeoLKernel/arch/arm/mach-omap1/board-osk.c:	if (gpio_request(OMAP_MPUIO(2), "wakeup") == 0) {
NeoLKernel/arch/arm/mach-omap1/board-osk.c:		 * button for more than wakeup from system sleep.
NeoLKernel/arch/arm/mach-omap1/board-osk.c:				&osk_mistral_wake_interrupt,
NeoLKernel/arch/arm/mach-omap1/board-osk.c:				IRQF_SHARED, "mistral_wakeup",
NeoLKernel/arch/arm/mach-omap1/board-osk.c:				&osk_mistral_wake_interrupt);
NeoLKernel/arch/arm/mach-omap1/board-osk.c:			printk(KERN_ERR "OSK+Mistral: no wakeup irq, %d?\n",
NeoLKernel/arch/arm/mach-omap1/board-osk.c:			enable_irq_wake(irq);
NeoLKernel/arch/arm/mach-omap1/board-osk.c:		printk(KERN_ERR "OSK+Mistral: wakeup button is awol\n");
NeoLKernel/arch/arm/mach-omap1/board-osk.c:	 * board, like the touchscreen, EEPROM, and wakeup (!) switch.
NeoLKernel/arch/arm/mach-omap1/irq.c:	unsigned long wake_enable;
NeoLKernel/arch/arm/mach-omap1/irq.c:static int omap_wake_irq(unsigned int irq, unsigned int enable)
NeoLKernel/arch/arm/mach-omap1/irq.c:		irq_banks[bank].wake_enable |= IRQ_BIT(irq);
NeoLKernel/arch/arm/mach-omap1/irq.c:		irq_banks[bank].wake_enable &= ~IRQ_BIT(irq);
NeoLKernel/arch/arm/mach-omap1/irq.c:	.set_wake	= omap_wake_irq,
NeoLKernel/arch/arm/mach-omap1/pm.c: * Configuration of the wakeup event is board specific. For the
NeoLKernel/arch/arm/mach-omap1/pm.c:static void omap_pm_wakeup_setup(void)
NeoLKernel/arch/arm/mach-omap1/pm.c:	u32 level1_wake = 0;
NeoLKernel/arch/arm/mach-omap1/pm.c:	u32 level2_wake = OMAP_IRQ_BIT(INT_UART2);
NeoLKernel/arch/arm/mach-omap1/pm.c:	 * and the L2 wakeup interrupts: keypad and UART2. Note that the
NeoLKernel/arch/arm/mach-omap1/pm.c:	 * drivers must still separately call omap_set_gpio_wakeup() to
NeoLKernel/arch/arm/mach-omap1/pm.c:	 * wake up to a GPIO interrupt.
NeoLKernel/arch/arm/mach-omap1/pm.c:		level1_wake = OMAP_IRQ_BIT(INT_730_GPIO_BANK1) |
NeoLKernel/arch/arm/mach-omap1/pm.c:		level1_wake = OMAP_IRQ_BIT(INT_GPIO_BANK1) |
NeoLKernel/arch/arm/mach-omap1/pm.c:		level1_wake = OMAP_IRQ_BIT(INT_GPIO_BANK1) |
NeoLKernel/arch/arm/mach-omap1/pm.c:	omap_writel(~level1_wake, OMAP_IH1_MIR);
NeoLKernel/arch/arm/mach-omap1/pm.c:		omap_writel(~level2_wake, OMAP_IH2_0_MIR);
NeoLKernel/arch/arm/mach-omap1/pm.c:		level2_wake |= OMAP_IRQ_BIT(INT_KEYBOARD);
NeoLKernel/arch/arm/mach-omap1/pm.c:		omap_writel(~level2_wake,  OMAP_IH2_MIR);
NeoLKernel/arch/arm/mach-omap1/pm.c:		level2_wake |= OMAP_IRQ_BIT(INT_KEYBOARD);
NeoLKernel/arch/arm/mach-omap1/pm.c:		omap_writel(~level2_wake, OMAP_IH2_0_MIR);
NeoLKernel/arch/arm/mach-omap1/pm.c:		/* INT_1610_WAKE_UP_REQ is needed for GPIO wakeup... */
NeoLKernel/arch/arm/mach-omap1/pm.c:	omap_serial_wake_trigger(1);
NeoLKernel/arch/arm/mach-omap1/pm.c:	omap_pm_wakeup_setup();
NeoLKernel/arch/arm/mach-omap1/pm.c:	 * them when it wakes up and it will return.
NeoLKernel/arch/arm/mach-omap1/pm.c:	 * until wake up.
NeoLKernel/arch/arm/mach-omap1/pm.c:	omap_serial_wake_trigger(0);
NeoLKernel/arch/arm/mach-omap1/pm.c: *	This is called after we wake back up (or if entering the sleep state
NeoLKernel/arch/arm/mach-omap1/pm.c:static irqreturn_t omap_wakeup_interrupt(int irq, void *dev)
NeoLKernel/arch/arm/mach-omap1/pm.c:static struct irqaction omap_wakeup_irq = {
NeoLKernel/arch/arm/mach-omap1/pm.c:	.name		= "peripheral wakeup",
NeoLKernel/arch/arm/mach-omap1/pm.c:	.handler	= omap_wakeup_interrupt
NeoLKernel/arch/arm/mach-omap1/pm.c:	 * We copy the assembler sleep/wakeup routines to SRAM.
NeoLKernel/arch/arm/mach-omap1/pm.c:	 * memory the MPU can see when it wakes up.
NeoLKernel/arch/arm/mach-omap1/pm.c:		setup_irq(INT_730_WAKE_UP_REQ, &omap_wakeup_irq);
NeoLKernel/arch/arm/mach-omap1/pm.c:		setup_irq(INT_1610_WAKE_UP_REQ, &omap_wakeup_irq);
NeoLKernel/arch/arm/mach-omap1/pm.h:extern void omap_serial_wake_trigger(int enable);
NeoLKernel/arch/arm/mach-omap1/pm.h:#define omap_serial_wakeup_init()	{}
NeoLKernel/arch/arm/mach-omap1/pm.h:#define omap_serial_wake_trigger(x)	{}
NeoLKernel/arch/arm/mach-omap1/serial.c:static irqreturn_t omap_serial_wake_interrupt(int irq, void *dev_id)
NeoLKernel/arch/arm/mach-omap1/serial.c:	/* Need to do something with serial port right after wake-up? */
NeoLKernel/arch/arm/mach-omap1/serial.c:void omap_serial_wake_trigger(int enable)
NeoLKernel/arch/arm/mach-omap1/serial.c:static void __init omap_serial_set_port_wakeup(int gpio_nr)
NeoLKernel/arch/arm/mach-omap1/serial.c:	ret = gpio_request(gpio_nr, "UART wake");
NeoLKernel/arch/arm/mach-omap1/serial.c:		printk(KERN_ERR "Could not request UART wake GPIO: %i\n",
NeoLKernel/arch/arm/mach-omap1/serial.c:	ret = request_irq(gpio_to_irq(gpio_nr), &omap_serial_wake_interrupt,
NeoLKernel/arch/arm/mach-omap1/serial.c:			  IRQF_TRIGGER_RISING, "serial wakeup", NULL);
NeoLKernel/arch/arm/mach-omap1/serial.c:		printk(KERN_ERR "No interrupt for UART wake GPIO: %i\n",
NeoLKernel/arch/arm/mach-omap1/serial.c:	enable_irq_wake(gpio_to_irq(gpio_nr));
NeoLKernel/arch/arm/mach-omap1/serial.c:static int __init omap_serial_wakeup_init(void)
NeoLKernel/arch/arm/mach-omap1/serial.c:		omap_serial_set_port_wakeup(37);
NeoLKernel/arch/arm/mach-omap1/serial.c:		omap_serial_set_port_wakeup(18);
NeoLKernel/arch/arm/mach-omap1/serial.c:		omap_serial_set_port_wakeup(49);
NeoLKernel/arch/arm/mach-omap1/serial.c:late_initcall(omap_serial_wakeup_init);
NeoLKernel/arch/arm/mach-omap1/sleep.S: * Low-level OMAP730/1510/1610 sleep/wakeUp support
NeoLKernel/arch/arm/mach-omap1/sleep.S: *	 wakes up it continues execution at the point it went to sleep.
NeoLKernel/arch/arm/mach-omap1/sleep.S: * Let's wait for the next wake up event to wake us up. r0 can't be
NeoLKernel/arch/arm/mach-omap1/sleep.S: * Let's wait for the next wake up event to wake us up. r0 can't be
NeoLKernel/arch/arm/mach-omap1/sleep.S: * Let's wait for the next wake up event to wake us up. r0 can't be
NeoLKernel/arch/arm/mach-omap2/board-3430sdp.c:static void enable_board_wakeup_source(void)
NeoLKernel/arch/arm/mach-omap2/board-3430sdp.c:	enable_board_wakeup_source();
NeoLKernel/arch/arm/mach-omap2/board-omap3beagle.c:		.wakeup			= 1,
NeoLKernel/arch/arm/mach-omap2/board-rx51-peripherals.c:static struct twl4030_ins wakeup_seq[] __initdata = {
NeoLKernel/arch/arm/mach-omap2/board-rx51-peripherals.c:static struct twl4030_script wakeup_script __initdata = {
NeoLKernel/arch/arm/mach-omap2/board-rx51-peripherals.c:	.script	= wakeup_seq,
NeoLKernel/arch/arm/mach-omap2/board-rx51-peripherals.c:	.size	= ARRAY_SIZE(wakeup_seq),
NeoLKernel/arch/arm/mach-omap2/board-rx51-peripherals.c:static struct twl4030_ins wakeup_p3_seq[] __initdata = {
NeoLKernel/arch/arm/mach-omap2/board-rx51-peripherals.c:static struct twl4030_script wakeup_p3_script __initdata = {
NeoLKernel/arch/arm/mach-omap2/board-rx51-peripherals.c:	.script	= wakeup_p3_seq,
NeoLKernel/arch/arm/mach-omap2/board-rx51-peripherals.c:	.size	= ARRAY_SIZE(wakeup_p3_seq),
NeoLKernel/arch/arm/mach-omap2/board-rx51-peripherals.c:	/* wakeup12 script should be loaded before sleep script, otherwise a
NeoLKernel/arch/arm/mach-omap2/board-rx51-peripherals.c:	   board might hit retention before loading of wakeup script is
NeoLKernel/arch/arm/mach-omap2/board-rx51-peripherals.c:	&wakeup_script,
NeoLKernel/arch/arm/mach-omap2/board-rx51-peripherals.c:	&wakeup_p3_script,
NeoLKernel/arch/arm/mach-omap2/omap-smp.c:static void __init wakeup_secondary(void)
NeoLKernel/arch/arm/mach-omap2/omap-smp.c:	 * Send a 'sev' to wake the secondary core from WFE.
NeoLKernel/arch/arm/mach-omap2/omap-smp.c:		 * Initialise the SCU and wake up the secondary core using
NeoLKernel/arch/arm/mach-omap2/omap-smp.c:		 * wakeup_secondary().
NeoLKernel/arch/arm/mach-omap2/omap-smp.c:		wakeup_secondary();
NeoLKernel/arch/arm/mach-omap2/omap_hwmod.c: * _enable_wakeup: set OCP_SYSCONFIG.ENAWAKEUP bit in the hardware
NeoLKernel/arch/arm/mach-omap2/omap_hwmod.c: * Allow the hardware module @oh to send wakeups.  Returns -EINVAL
NeoLKernel/arch/arm/mach-omap2/omap_hwmod.c:static int _enable_wakeup(struct omap_hwmod *oh)
NeoLKernel/arch/arm/mach-omap2/omap_hwmod.c: * _disable_wakeup: clear OCP_SYSCONFIG.ENAWAKEUP bit in the hardware
NeoLKernel/arch/arm/mach-omap2/omap_hwmod.c: * Prevent the hardware module @oh to send wakeups.  Returns -EINVAL
NeoLKernel/arch/arm/mach-omap2/omap_hwmod.c:static int _disable_wakeup(struct omap_hwmod *oh)
NeoLKernel/arch/arm/mach-omap2/omap_hwmod.c: * On some modules, this function can affect the wakeup latency vs.
NeoLKernel/arch/arm/mach-omap2/omap_hwmod.c: * On some modules, this function can affect the wakeup latency vs.
NeoLKernel/arch/arm/mach-omap2/omap_hwmod.c: * On some modules, this function can affect the wakeup latency vs.
NeoLKernel/arch/arm/mach-omap2/omap_hwmod.c: * On some modules, this function can affect the wakeup latency vs.
NeoLKernel/arch/arm/mach-omap2/omap_hwmod.c: * omap_hwmod_enable_wakeup - allow device to wake up the system
NeoLKernel/arch/arm/mach-omap2/omap_hwmod.c: * send wakeups to the PRCM.  Eventually this should sets PRCM wakeup
NeoLKernel/arch/arm/mach-omap2/omap_hwmod.c: * registers to cause the PRCM to receive wakeup events from the
NeoLKernel/arch/arm/mach-omap2/omap_hwmod.c: * module.  Does not set any wakeup routing registers beyond this
NeoLKernel/arch/arm/mach-omap2/omap_hwmod.c: * point - if the module is to wake up any other module or subsystem,
NeoLKernel/arch/arm/mach-omap2/omap_hwmod.c:int omap_hwmod_enable_wakeup(struct omap_hwmod *oh)
NeoLKernel/arch/arm/mach-omap2/omap_hwmod.c:	_enable_wakeup(oh);
NeoLKernel/arch/arm/mach-omap2/omap_hwmod.c: * omap_hwmod_disable_wakeup - prevent device from waking the system
NeoLKernel/arch/arm/mach-omap2/omap_hwmod.c: * from sending wakeups to the PRCM.  Eventually this should clear
NeoLKernel/arch/arm/mach-omap2/omap_hwmod.c: * PRCM wakeup registers to cause the PRCM to ignore wakeup events
NeoLKernel/arch/arm/mach-omap2/omap_hwmod.c: * from the module.  Does not set any wakeup routing registers beyond
NeoLKernel/arch/arm/mach-omap2/omap_hwmod.c: * this point - if the module is to wake up any other module or
NeoLKernel/arch/arm/mach-omap2/omap_hwmod.c:int omap_hwmod_disable_wakeup(struct omap_hwmod *oh)
NeoLKernel/arch/arm/mach-omap2/omap_hwmod.c:	_disable_wakeup(oh);
NeoLKernel/arch/arm/mach-omap2/pm24xx.c:	/* Clear old wake-up events */
NeoLKernel/arch/arm/mach-omap2/pm24xx.c:	/* clear CORE wake-up events */
NeoLKernel/arch/arm/mach-omap2/pm24xx.c:	/* wakeup domain events - bit 1: GPT1, bit5 GPIO */
NeoLKernel/arch/arm/mach-omap2/pm24xx.c:	/* MPU domain wake events */
NeoLKernel/arch/arm/mach-omap2/pm24xx.c:	/* The peripherals seem not to be able to wake up the MPU when
NeoLKernel/arch/arm/mach-omap2/pm24xx.c:	/* Set all domain wakeup dependencies */
NeoLKernel/arch/arm/mach-omap2/pm24xx.c:	/* Enable wake-up events */
NeoLKernel/arch/arm/mach-omap2/pm24xx.c:	 * We copy the assembler sleep/wakeup routines to SRAM.
NeoLKernel/arch/arm/mach-omap2/pm24xx.c:	 * memory the MPU can see when it wakes up.
NeoLKernel/arch/arm/mach-omap2/pm34xx.c: * The purpose of this function is to clear any wake-up events latched
NeoLKernel/arch/arm/mach-omap2/pm34xx.c: * in the PRCM PM_WKST_x registers. It is possible that a wake-up event
NeoLKernel/arch/arm/mach-omap2/pm34xx.c: * that any peripheral wake-up events occurring while attempting to
NeoLKernel/arch/arm/mach-omap2/pm34xx.c:static int _prcm_int_handle_wakeup(void)
NeoLKernel/arch/arm/mach-omap2/pm34xx.c: * register indicates that a wake-up event is pending for the MPU and
NeoLKernel/arch/arm/mach-omap2/pm34xx.c: * this bit can only be cleared if the all the wake-up events latched
NeoLKernel/arch/arm/mach-omap2/pm34xx.c: * handler is implemented using a do-while loop so that if a wake-up
NeoLKernel/arch/arm/mach-omap2/pm34xx.c:			c = _prcm_int_handle_wakeup();
NeoLKernel/arch/arm/mach-omap2/pm34xx.c:			WARN(c == 0, "prcm: WARNING: PRCM indicated MPU wakeup "
NeoLKernel/arch/arm/mach-omap2/pm34xx.c:			     "but no wakeup sources are marked\n");
NeoLKernel/arch/arm/mach-omap2/pm34xx.c:		omap2_clkdm_wakeup(pwrdm->pwrdm_clkdms[0]);
NeoLKernel/arch/arm/mach-omap2/pm34xx.c:	/* For some reason IO doesn't generate wakeup event even if
NeoLKernel/arch/arm/mach-omap2/pm34xx.c:	 * it is selected to mpu wakeup goup */
NeoLKernel/arch/arm/mach-omap2/pm34xx.c:	/* Enable wakeups in PER */
NeoLKernel/arch/arm/mach-omap2/pm34xx.c:	/* and allow them to wake up MPU */
NeoLKernel/arch/arm/mach-omap2/powerdomain.c: * pwrdm_add_wkdep - add a wakeup dependency from pwrdm2 to pwrdm1
NeoLKernel/arch/arm/mach-omap2/powerdomain.c: * @pwrdm1: wake this struct powerdomain * up (dependent)
NeoLKernel/arch/arm/mach-omap2/powerdomain.c: * @pwrdm2: when this struct powerdomain * wakes up (source)
NeoLKernel/arch/arm/mach-omap2/powerdomain.c: * When the powerdomain represented by pwrdm2 wakes up (due to an
NeoLKernel/arch/arm/mach-omap2/powerdomain.c: * interrupt), wake up pwrdm1.	Implemented in hardware on the OMAP,
NeoLKernel/arch/arm/mach-omap2/powerdomain.c: * this feature is designed to reduce wakeup latency of the dependent
NeoLKernel/arch/arm/mach-omap2/powerdomain.c: * pointers, -ENOENT if pwrdm2 cannot wake up pwrdm1 in hardware, or
NeoLKernel/arch/arm/mach-omap2/powerdomain.c:		pr_debug("powerdomain: hardware cannot set/clear wake up of "
NeoLKernel/arch/arm/mach-omap2/powerdomain.c:			 "%s when %s wakes up\n", pwrdm1->name, pwrdm2->name);
NeoLKernel/arch/arm/mach-omap2/powerdomain.c:	pr_debug("powerdomain: hardware will wake up %s when %s wakes up\n",
NeoLKernel/arch/arm/mach-omap2/powerdomain.c: * pwrdm_del_wkdep - remove a wakeup dependency from pwrdm2 to pwrdm1
NeoLKernel/arch/arm/mach-omap2/powerdomain.c: * @pwrdm1: wake this struct powerdomain * up (dependent)
NeoLKernel/arch/arm/mach-omap2/powerdomain.c: * @pwrdm2: when this struct powerdomain * wakes up (source)
NeoLKernel/arch/arm/mach-omap2/powerdomain.c: * Remove a wakeup dependency that causes pwrdm1 to wake up when pwrdm2
NeoLKernel/arch/arm/mach-omap2/powerdomain.c: * wakes up.  Returns -EINVAL if presented with invalid powerdomain
NeoLKernel/arch/arm/mach-omap2/powerdomain.c: * pointers, -ENOENT if pwrdm2 cannot wake up pwrdm1 in hardware, or
NeoLKernel/arch/arm/mach-omap2/powerdomain.c:		pr_debug("powerdomain: hardware cannot set/clear wake up of "
NeoLKernel/arch/arm/mach-omap2/powerdomain.c:			 "%s when %s wakes up\n", pwrdm1->name, pwrdm2->name);
NeoLKernel/arch/arm/mach-omap2/powerdomain.c:	pr_debug("powerdomain: hardware will no longer wake up %s after %s "
NeoLKernel/arch/arm/mach-omap2/powerdomain.c:		 "wakes up\n", pwrdm1->name, pwrdm2->name);
NeoLKernel/arch/arm/mach-omap2/powerdomain.c: * pwrdm_read_wkdep - read wakeup dependency state from pwrdm2 to pwrdm1
NeoLKernel/arch/arm/mach-omap2/powerdomain.c: * @pwrdm1: wake this struct powerdomain * up (dependent)
NeoLKernel/arch/arm/mach-omap2/powerdomain.c: * @pwrdm2: when this struct powerdomain * wakes up (source)
NeoLKernel/arch/arm/mach-omap2/powerdomain.c: * Return 1 if a hardware wakeup dependency exists wherein pwrdm1 will be
NeoLKernel/arch/arm/mach-omap2/powerdomain.c: * awoken when pwrdm2 wakes up; 0 if dependency is not set; -EINVAL
NeoLKernel/arch/arm/mach-omap2/powerdomain.c: * wakeup dependencies.  Wakeup dependencies fixed in hardware are not
NeoLKernel/arch/arm/mach-omap2/powerdomain.c:		pr_debug("powerdomain: hardware cannot set/clear wake up of "
NeoLKernel/arch/arm/mach-omap2/powerdomain.c:			 "%s when %s wakes up\n", pwrdm1->name, pwrdm2->name);
NeoLKernel/arch/arm/mach-omap2/powerdomains.h: * XXX encode hardware fixed wakeup dependencies -- esp. for 3430 CORE
NeoLKernel/arch/arm/mach-omap2/powerdomains.h:/* OMAP2/3-common powerdomains and wakeup dependencies */
NeoLKernel/arch/arm/mach-omap2/serial.c:static void omap_uart_enable_wakeup(struct omap_uart_state *uart)
NeoLKernel/arch/arm/mach-omap2/serial.c:	/* Set wake-enable bit */
NeoLKernel/arch/arm/mach-omap2/serial.c:	/* Ensure IOPAD wake-enables are set */
NeoLKernel/arch/arm/mach-omap2/serial.c:static void omap_uart_disable_wakeup(struct omap_uart_state *uart)
NeoLKernel/arch/arm/mach-omap2/serial.c:	/* Clear wake-enable bit */
NeoLKernel/arch/arm/mach-omap2/serial.c:	/* Ensure IOPAD wake-enables are cleared */
NeoLKernel/arch/arm/mach-omap2/serial.c:	if (device_may_wakeup(&uart->pdev.dev))
NeoLKernel/arch/arm/mach-omap2/serial.c:		omap_uart_enable_wakeup(uart);
NeoLKernel/arch/arm/mach-omap2/serial.c:		omap_uart_disable_wakeup(uart);
NeoLKernel/arch/arm/mach-omap2/serial.c:			/* Check for IO pad wakeup */
NeoLKernel/arch/arm/mach-omap2/serial.c:			/* Check for normal UART wakeup */
NeoLKernel/arch/arm/mach-omap2/serial.c:			device_init_wakeup(dev, true);
NeoLKernel/arch/arm/mach-omap2/sleep24xx.S: *	 wakes up it continues execution at the point it went to sleep.
NeoLKernel/arch/arm/mach-omap2/sleep24xx.S: * SDRC shutdown then ARM shutdown.  Upon wake MPU is back on so just restore
NeoLKernel/arch/arm/mach-omap2/sleep24xx.S: * For less than 242x-ES2.2 upon wake from a sleep mode where the external
NeoLKernel/arch/arm/mach-omap2/sleep24xx.S: * at wake
NeoLKernel/arch/arm/mach-omap2/sleep24xx.S:	subs	r5, r5, #0x1		@ awake, wait just a bit
NeoLKernel/arch/arm/mach-omap2/sleep34xx.S: *	 wakes up it continues execution at the point it went to sleep.
NeoLKernel/arch/arm/mach-omap2/timer-mpu.c: * part of the wake up domain.
NeoLKernel/arch/arm/mach-omap2/clockdomain.c: * "autodep" is a powerdomain sleep/wakeup dependency that is
NeoLKernel/arch/arm/mach-omap2/clockdomain.c: * Add the "autodep" sleep & wakeup dependencies to clockdomain 'clkdm'
NeoLKernel/arch/arm/mach-omap2/clockdomain.c: * Remove the "autodep" sleep & wakeup dependencies from clockdomain 'clkdm'
NeoLKernel/arch/arm/mach-omap2/clockdomain.c: * omap2_clkdm_wakeup - force clockdomain wakeup transition
NeoLKernel/arch/arm/mach-omap2/clockdomain.c: * Instruct the CM to force a wakeup transition on the specified
NeoLKernel/arch/arm/mach-omap2/clockdomain.c: * clockdomain does not support software-controlled wakeup; 0 upon
NeoLKernel/arch/arm/mach-omap2/clockdomain.c:int omap2_clkdm_wakeup(struct clockdomain *clkdm)
NeoLKernel/arch/arm/mach-omap2/clockdomain.c:			 "wakeup via software\n", clkdm->name);
NeoLKernel/arch/arm/mach-omap2/clockdomain.c:	pr_debug("clockdomain: forcing wakeup on %s\n", clkdm->name);
NeoLKernel/arch/arm/mach-omap2/clockdomain.c: * it is awake.  Intended to be called by clk_enable() code.  If the
NeoLKernel/arch/arm/mach-omap2/clockdomain.c: * clockdomain to wake.  If the clockdomain is in hardware-supervised
NeoLKernel/arch/arm/mach-omap2/clockdomain.c:		omap2_clkdm_wakeup(clkdm);
NeoLKernel/arch/arm/mach-pnx4008/serial.c:	/* setup wakeup interrupt */
NeoLKernel/arch/arm/mach-pnx4008/sleep.S:	@ to prepare SDRAM to get out of self-refresh mode after wakeup
NeoLKernel/arch/arm/mach-pnx4008/sleep.S:	@ set 'get out of self-refresh mode after wakeup' bit
NeoLKernel/arch/arm/mach-pxa/magician.c:		.wakeup = 1,		\
NeoLKernel/arch/arm/mach-pxa/am200epd.c:	wake_up_interruptible(&par->waitq);
NeoLKernel/arch/arm/mach-pxa/am300epd.c:	wake_up(&par->waitq);
NeoLKernel/arch/arm/mach-pxa/corgi.c:	.wakeup			= 1,
NeoLKernel/arch/arm/mach-pxa/corgi_pm.c:	unsigned long wakeup_mask;
NeoLKernel/arch/arm/mach-pxa/corgi_pm.c:	wakeup_mask = GPIO_bit(CORGI_GPIO_KEY_INT) | GPIO_bit(CORGI_GPIO_WAKEUP) | GPIO_bit(CORGI_GPIO_AC_IN) | GPIO_bit(CORGI_GPIO_CHRG_FULL);
NeoLKernel/arch/arm/mach-pxa/corgi_pm.c:		wakeup_mask |= GPIO_bit(CORGI_GPIO_MAIN_BAT_LOW);
NeoLKernel/arch/arm/mach-pxa/corgi_pm.c:	PWER = wakeup_mask | PWER_RTC;
NeoLKernel/arch/arm/mach-pxa/corgi_pm.c:	PRER = wakeup_mask;
NeoLKernel/arch/arm/mach-pxa/corgi_pm.c:	PFER = wakeup_mask;
NeoLKernel/arch/arm/mach-pxa/corgi_pm.c: * Return: 0 to sleep, otherwise wake
NeoLKernel/arch/arm/mach-pxa/corgi_pm.c:static int corgi_should_wakeup(unsigned int resume_on_alarm)
NeoLKernel/arch/arm/mach-pxa/corgi_pm.c:static unsigned long corgi_charger_wakeup(void)
NeoLKernel/arch/arm/mach-pxa/corgi_pm.c:	.charger_wakeup  = corgi_charger_wakeup,
NeoLKernel/arch/arm/mach-pxa/corgi_pm.c:	.should_wakeup   = corgi_should_wakeup,
NeoLKernel/arch/arm/mach-pxa/csb701.c:		.wakeup = 1,
NeoLKernel/arch/arm/mach-pxa/mainstone.c:		.desc	= "wakeup",
NeoLKernel/arch/arm/mach-pxa/mainstone.c:		.wakeup	= 1,
NeoLKernel/arch/arm/mach-pxa/mfp-pxa2xx.c: *  wakeup detection are also supported by the same framework.
NeoLKernel/arch/arm/mach-pxa/mfp-pxa2xx.c:	unsigned	can_wakeup	: 1;
NeoLKernel/arch/arm/mach-pxa/mfp-pxa2xx.c:	 * configurations of those pins not able to wakeup
NeoLKernel/arch/arm/mach-pxa/mfp-pxa2xx.c:	if ((c & MFP_LPM_CAN_WAKEUP) && !gpio_desc[gpio].can_wakeup) {
NeoLKernel/arch/arm/mach-pxa/mfp-pxa2xx.c:		pr_warning("%s: GPIO%d unable to wakeup\n",
NeoLKernel/arch/arm/mach-pxa/mfp-pxa2xx.c:		pr_warning("%s: output GPIO%d unable to wakeup\n",
NeoLKernel/arch/arm/mach-pxa/mfp-pxa2xx.c:int gpio_set_wake(unsigned int gpio, unsigned int on)
NeoLKernel/arch/arm/mach-pxa/mfp-pxa2xx.c:	if (d->can_wakeup && (c & MFP_LPM_CAN_WAKEUP)) {
NeoLKernel/arch/arm/mach-pxa/mfp-pxa2xx.c:		gpio_desc[i].can_wakeup = 1;
NeoLKernel/arch/arm/mach-pxa/mfp-pxa2xx.c:int keypad_set_wake(unsigned int on)
NeoLKernel/arch/arm/mach-pxa/mfp-pxa2xx.c:	gpio_desc[(gpio)].can_wakeup = 1;			\
NeoLKernel/arch/arm/mach-pxa/mfp-pxa2xx.c:		gpio_desc[gpio].can_wakeup = 1;
NeoLKernel/arch/arm/mach-pxa/mfp-pxa2xx.c:	/* Overwrite GPIO13 as a PWER wakeup source */
NeoLKernel/arch/arm/mach-pxa/mfp-pxa2xx.c:		gpio_desc[i].can_wakeup = 1;
NeoLKernel/arch/arm/mach-pxa/mfp-pxa2xx.c:	gpio_desc[35].can_wakeup = 1;
NeoLKernel/arch/arm/mach-pxa/mioa701.c:#define MIO_KEY(key, _gpio, _desc, _wakeup) \
NeoLKernel/arch/arm/mach-pxa/mioa701.c:	.desc = (_desc), .type = EV_KEY, .wakeup = (_wakeup) }
NeoLKernel/arch/arm/mach-pxa/mioa701.c:	gpio_set_wake(GPIO113_GSM_EVENT, 1);
NeoLKernel/arch/arm/mach-pxa/mp900.c:	.remote_wakeup_enable = 1,
NeoLKernel/arch/arm/mach-pxa/pcm027.c:	/* initialize sleep mode regs (wake-up sources, etc) */
NeoLKernel/arch/arm/mach-pxa/pxa25x.c:/* PXA25x: supports wakeup from GPIO0..GPIO15 and RTC alarm
NeoLKernel/arch/arm/mach-pxa/pxa25x.c:static int pxa25x_set_wake(unsigned int irq, unsigned int on)
NeoLKernel/arch/arm/mach-pxa/pxa25x.c:		return gpio_set_wake(gpio, on);
NeoLKernel/arch/arm/mach-pxa/pxa25x.c:	pxa_init_irq(32, pxa25x_set_wake);
NeoLKernel/arch/arm/mach-pxa/pxa25x.c:	pxa_init_gpio(IRQ_GPIO_2_x, 2, 84, pxa25x_set_wake);
NeoLKernel/arch/arm/mach-pxa/pxa25x.c:	pxa_init_irq(32, pxa25x_set_wake);
NeoLKernel/arch/arm/mach-pxa/pxa25x.c:	pxa_init_gpio(IRQ_GPIO_2_x, 2, 89, pxa25x_set_wake);
NeoLKernel/arch/arm/mach-pxa/pxa27x.c:/* PXA27x:  Various gpios can issue wakeup events.  This logic only
NeoLKernel/arch/arm/mach-pxa/pxa27x.c:static int pxa27x_set_wake(unsigned int irq, unsigned int on)
NeoLKernel/arch/arm/mach-pxa/pxa27x.c:		return gpio_set_wake(gpio, on);
NeoLKernel/arch/arm/mach-pxa/pxa27x.c:		return keypad_set_wake(on);
NeoLKernel/arch/arm/mach-pxa/pxa27x.c:	pxa_init_irq(34, pxa27x_set_wake);
NeoLKernel/arch/arm/mach-pxa/pxa27x.c:	pxa_init_gpio(IRQ_GPIO_2_x, 2, 120, pxa27x_set_wake);
NeoLKernel/arch/arm/mach-pxa/pxa3xx.c:static unsigned long wakeup_src;
NeoLKernel/arch/arm/mach-pxa/pxa3xx.c: * Enter a standby mode (S0D1C2 or S0D2C2).  Upon wakeup, the dynamic
NeoLKernel/arch/arm/mach-pxa/pxa3xx.c:	AD2D0ER = wakeup_src;
NeoLKernel/arch/arm/mach-pxa/pxa3xx.c:	/* clear and setup wakeup source */
NeoLKernel/arch/arm/mach-pxa/pxa3xx.c:	AD3ER = wakeup_src;
NeoLKernel/arch/arm/mach-pxa/pxa3xx.c:	 * Don't sleep if no wakeup sources are defined
NeoLKernel/arch/arm/mach-pxa/pxa3xx.c:	if (wakeup_src == 0) {
NeoLKernel/arch/arm/mach-pxa/pxa3xx.c:		printk(KERN_ERR "Not suspending: no wakeup sources\n");
NeoLKernel/arch/arm/mach-pxa/pxa3xx.c:	 * Since we copy wakeup code into the SRAM, we need to ensure
NeoLKernel/arch/arm/mach-pxa/pxa3xx.c:static int pxa3xx_set_wake(unsigned int irq, unsigned int on)
NeoLKernel/arch/arm/mach-pxa/pxa3xx.c:		wakeup_src |= mask;
NeoLKernel/arch/arm/mach-pxa/pxa3xx.c:		wakeup_src &= ~mask;
NeoLKernel/arch/arm/mach-pxa/pxa3xx.c:#define pxa3xx_set_wake	NULL
NeoLKernel/arch/arm/mach-pxa/pxa3xx.c:	pxa_init_irq(56, pxa3xx_set_wake);
NeoLKernel/arch/arm/mach-pxa/e400.c:	/* wakeup */
NeoLKernel/arch/arm/mach-pxa/e740.c:	/* wakeup */
NeoLKernel/arch/arm/mach-pxa/e750.c:	/* wakeup */
NeoLKernel/arch/arm/mach-pxa/em-x270.c:		.desc	= "sleep/wakeup",
NeoLKernel/arch/arm/mach-pxa/em-x270.c:		.wakeup	= 1,
NeoLKernel/arch/arm/mach-pxa/ezx.c:		.wakeup     = 1,
NeoLKernel/arch/arm/mach-pxa/ezx.c:		.wakeup     = 1,
NeoLKernel/arch/arm/mach-pxa/ezx.c:		.wakeup     = 1,
NeoLKernel/arch/arm/mach-pxa/ezx.c:		.wakeup     = 1,
NeoLKernel/arch/arm/mach-pxa/ezx.c:		.wakeup     = 1,
NeoLKernel/arch/arm/mach-pxa/generic.h:				int (*set_wake)(unsigned int, unsigned int));
NeoLKernel/arch/arm/mach-pxa/hx4700.c:		.wakeup     = 1,			\
NeoLKernel/arch/arm/mach-pxa/imote2.c:	/* Device Identification for wakeup*/
NeoLKernel/arch/arm/mach-pxa/include/mach/corgi.h:#define CORGI_GPIO_WAKEUP			(3) /* System wakeup notification? */
NeoLKernel/arch/arm/mach-pxa/include/mach/pxa25x-udc.h:#define UDCCS0_DRWF	(1 << 3)	/* Device remote wakeup feature */
NeoLKernel/arch/arm/mach-pxa/include/mach/pxa2xx-regs.h:#define PWER_GPIO(Nb)	(1 << Nb)	/* GPIO [0..15] wake-up enable     */
NeoLKernel/arch/arm/mach-pxa/include/mach/pxa2xx-regs.h:#define PWER_GPIO0	PWER_GPIO (0)	/* GPIO  [0] wake-up enable        */
NeoLKernel/arch/arm/mach-pxa/include/mach/pxa2xx-regs.h:#define PWER_GPIO1	PWER_GPIO (1)	/* GPIO  [1] wake-up enable        */
NeoLKernel/arch/arm/mach-pxa/include/mach/pxa2xx-regs.h:#define PWER_GPIO2	PWER_GPIO (2)	/* GPIO  [2] wake-up enable        */
NeoLKernel/arch/arm/mach-pxa/include/mach/pxa2xx-regs.h:#define PWER_GPIO3	PWER_GPIO (3)	/* GPIO  [3] wake-up enable        */
NeoLKernel/arch/arm/mach-pxa/include/mach/pxa2xx-regs.h:#define PWER_GPIO4	PWER_GPIO (4)	/* GPIO  [4] wake-up enable        */
NeoLKernel/arch/arm/mach-pxa/include/mach/pxa2xx-regs.h:#define PWER_GPIO5	PWER_GPIO (5)	/* GPIO  [5] wake-up enable        */
NeoLKernel/arch/arm/mach-pxa/include/mach/pxa2xx-regs.h:#define PWER_GPIO6	PWER_GPIO (6)	/* GPIO  [6] wake-up enable        */
NeoLKernel/arch/arm/mach-pxa/include/mach/pxa2xx-regs.h:#define PWER_GPIO7	PWER_GPIO (7)	/* GPIO  [7] wake-up enable        */
NeoLKernel/arch/arm/mach-pxa/include/mach/pxa2xx-regs.h:#define PWER_GPIO8	PWER_GPIO (8)	/* GPIO  [8] wake-up enable        */
NeoLKernel/arch/arm/mach-pxa/include/mach/pxa2xx-regs.h:#define PWER_GPIO9	PWER_GPIO (9)	/* GPIO  [9] wake-up enable        */
NeoLKernel/arch/arm/mach-pxa/include/mach/pxa2xx-regs.h:#define PWER_GPIO10	PWER_GPIO (10)	/* GPIO [10] wake-up enable        */
NeoLKernel/arch/arm/mach-pxa/include/mach/pxa2xx-regs.h:#define PWER_GPIO11	PWER_GPIO (11)	/* GPIO [11] wake-up enable        */
NeoLKernel/arch/arm/mach-pxa/include/mach/pxa2xx-regs.h:#define PWER_GPIO12	PWER_GPIO (12)	/* GPIO [12] wake-up enable        */
NeoLKernel/arch/arm/mach-pxa/include/mach/pxa2xx-regs.h:#define PWER_GPIO13	PWER_GPIO (13)	/* GPIO [13] wake-up enable        */
NeoLKernel/arch/arm/mach-pxa/include/mach/pxa2xx-regs.h:#define PWER_GPIO14	PWER_GPIO (14)	/* GPIO [14] wake-up enable        */
NeoLKernel/arch/arm/mach-pxa/include/mach/pxa2xx-regs.h:#define PWER_GPIO15	PWER_GPIO (15)	/* GPIO [15] wake-up enable        */
NeoLKernel/arch/arm/mach-pxa/include/mach/pxa2xx-regs.h:#define PWER_RTC	0x80000000	/* RTC alarm wake-up enable        */
NeoLKernel/arch/arm/mach-pxa/include/mach/sharpsl_pm.h:	unsigned long (*charger_wakeup)(void);
NeoLKernel/arch/arm/mach-pxa/include/mach/sharpsl_pm.h:	int (*should_wakeup)(unsigned int resume_on_alarm);
NeoLKernel/arch/arm/mach-pxa/include/mach/mainstone.h:#define MST_MSCWR2_RADIO_WAKE	(1 << 0)   /* Radio module wake-up signal */
NeoLKernel/arch/arm/mach-pxa/include/mach/mfp-pxa27x.h:extern int keypad_set_wake(unsigned int on);
NeoLKernel/arch/arm/mach-pxa/include/mach/mfp-pxa2xx.h:/* specifically for enabling wakeup on keypad GPIOs */
NeoLKernel/arch/arm/mach-pxa/include/mach/mfp-pxa2xx.h:extern int gpio_set_wake(unsigned int gpio, unsigned int on);
NeoLKernel/arch/arm/mach-pxa/irq.c:static void __init pxa_init_low_gpio_irq(set_wake_t fn)
NeoLKernel/arch/arm/mach-pxa/irq.c:	pxa_low_gpio_chip.set_wake = fn;
NeoLKernel/arch/arm/mach-pxa/irq.c:void __init pxa_init_irq(int irq_nr, set_wake_t fn)
NeoLKernel/arch/arm/mach-pxa/irq.c:	pxa_internal_irq_chip.set_wake = fn;
NeoLKernel/arch/arm/mach-pxa/lubbock.c:	/* wakeup */
NeoLKernel/arch/arm/mach-pxa/sharpsl_pm.c:	if (!sharpsl_pm.machinfo->should_wakeup(!(sharpsl_pm.flags & SHARPSL_ALARM_ACTIVE) && alarm_enable) )
NeoLKernel/arch/arm/mach-pxa/sharpsl_pm.c:			dev_dbg(sharpsl_pm.dev, "No user triggered wakeup events and not charging. Strange. Suspend.\n");
NeoLKernel/arch/arm/mach-pxa/sharpsl_pm.c:		dev_dbg(sharpsl_pm.dev, "User triggered wakeup in offline charger.\n");
NeoLKernel/arch/arm/mach-pxa/sharpsl_pm.c: * Return 0 - sleep or wakeup depending on other factors
NeoLKernel/arch/arm/mach-pxa/sharpsl_pm.c:			/* Check if any wakeup event had occurred */
NeoLKernel/arch/arm/mach-pxa/sharpsl_pm.c:			if (sharpsl_pm.machinfo->charger_wakeup() != 0)
NeoLKernel/arch/arm/mach-pxa/sharpsl_pm.c:		/* Check if any wakeup event had occurred */
NeoLKernel/arch/arm/mach-pxa/sharpsl_pm.c:		if (sharpsl_pm.machinfo->charger_wakeup() != 0)
NeoLKernel/arch/arm/mach-pxa/sleep.S: * Low-level PXA250/210 sleep/wakeUp support
NeoLKernel/arch/arm/mach-pxa/spitz.c:	.wakeup			= 1,
NeoLKernel/arch/arm/mach-pxa/spitz.c:		.wakeup	= 1,
NeoLKernel/arch/arm/mach-pxa/spitz_pm.c:static int spitz_should_wakeup(unsigned int resume_on_alarm)
NeoLKernel/arch/arm/mach-pxa/spitz_pm.c:static unsigned long spitz_charger_wakeup(void)
NeoLKernel/arch/arm/mach-pxa/spitz_pm.c:	.charger_wakeup   = spitz_charger_wakeup,
NeoLKernel/arch/arm/mach-pxa/spitz_pm.c:	.should_wakeup    = spitz_should_wakeup,
NeoLKernel/arch/arm/mach-pxa/stargate2.c:	/* Device Identification for wakeup*/
NeoLKernel/arch/arm/mach-pxa/tosa.c:	 * The first one can be used as a wakeup source, the second can't;
NeoLKernel/arch/arm/mach-pxa/tosa.c:		.wakeup	= 1,
NeoLKernel/arch/arm/mach-pxa/tosa.c:		 * can't be used as wakeup
NeoLKernel/arch/arm/mach-pxa/tosa.c:		 * .wakeup	= 1,
NeoLKernel/arch/arm/mach-pxa/tosa.c:		.wakeup	= 1,
NeoLKernel/arch/arm/mach-pxa/tosa.c:		.wakeup	= 1,
NeoLKernel/arch/arm/mach-pxa/tosa.c:	gpio_set_wake(MFP_PIN_GPIO1, 1);
NeoLKernel/arch/arm/mach-pxa/treo680.c:	GPIO14_GPIO | WAKEUP_ON_EDGE_BOTH,	/* GSM host wake up */
NeoLKernel/arch/arm/mach-pxa/treo680.c:	GPIO11_GPIO | WAKEUP_ON_EDGE_BOTH,	/* bluetooth host wake up */
NeoLKernel/arch/arm/mach-pxa/viper.c:	/* .remote_wakeup_connected = 0, */
NeoLKernel/arch/arm/mach-pxa/viper.c:	.remote_wakeup_enable	= 0,
NeoLKernel/arch/arm/mach-realview/hotplug.c:			 * OK, proper wakeup, we're done
NeoLKernel/arch/arm/mach-realview/hotplug.c:		printk("CPU%u: spurious wakeup call\n", cpu);
NeoLKernel/arch/arm/mach-realview/platsmp.c:	 * to send a soft interrupt to wake the secondary core.
NeoLKernel/arch/arm/mach-s3c2410/mach-amlm5900.c:amlm5900_wake_interrupt(int irq, void *ignored)
NeoLKernel/arch/arm/mach-s3c2410/mach-amlm5900.c:	ret = request_irq(IRQ_EINT9, &amlm5900_wake_interrupt,
NeoLKernel/arch/arm/mach-s3c2410/mach-amlm5900.c:				"amlm5900_wakeup", &amlm5900_wake_interrupt);
NeoLKernel/arch/arm/mach-s3c2410/mach-amlm5900.c:		printk(KERN_ERR "AML-M5900: no wakeup irq, %d?\n", ret);
NeoLKernel/arch/arm/mach-s3c2410/mach-amlm5900.c:		enable_irq_wake(IRQ_EINT9);
NeoLKernel/arch/arm/mach-s3c2412/irq.c:	.set_wake  = s3c_irq_wake,
NeoLKernel/arch/arm/mach-s3c2412/irq.c:static int s3c2412_irq_rtc_wake(unsigned int irqno, unsigned int state)
NeoLKernel/arch/arm/mach-s3c2412/irq.c:	return s3c_irq_chip.set_wake(irqno, state);
NeoLKernel/arch/arm/mach-s3c2412/irq.c:	/* change RTC IRQ's set wake method */
NeoLKernel/arch/arm/mach-s3c2412/irq.c:	s3c2412_irq_rtc_chip.set_wake = s3c2412_irq_rtc_wake;
NeoLKernel/arch/arm/mach-s3c2412/pm.c:	 * get damaged during wakeup */
NeoLKernel/arch/arm/mach-sa1100/badge4.c:	PWER |= PWER_GPIO26;	/* wake up on an edge from TESTPT_J5 */
NeoLKernel/arch/arm/mach-sa1100/badge4.c:	PWER |= PWER_RTC;	/* wake up if rtc fires */
NeoLKernel/arch/arm/mach-sa1100/dma.c: * 	particularly useful after a sleep/wakeup event.
NeoLKernel/arch/arm/mach-sa1100/generic.c:	/* enable wake-up on GPIO0 (Assabet...) */
NeoLKernel/arch/arm/mach-sa1100/h3600.c: * Enable/Disable wake up events for this serial port.
NeoLKernel/arch/arm/mach-sa1100/h3600.c:static int h3600_uart_set_wake(struct uart_port *port, u_int enable)
NeoLKernel/arch/arm/mach-sa1100/h3600.c:	.set_wake	= h3600_uart_set_wake,
NeoLKernel/arch/arm/mach-sa1100/include/mach/assabet.h:#define ASSABET_BCR_RAD_WU	(1<<18)	/* Radio wake up interrupt */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO(Nb)	GPIO_GPIO (Nb)	/* GPIO [0..27] wake-up enable     */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO0	PWER_GPIO (0)	/* GPIO  [0] wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO1	PWER_GPIO (1)	/* GPIO  [1] wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO2	PWER_GPIO (2)	/* GPIO  [2] wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO3	PWER_GPIO (3)	/* GPIO  [3] wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO4	PWER_GPIO (4)	/* GPIO  [4] wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO5	PWER_GPIO (5)	/* GPIO  [5] wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO6	PWER_GPIO (6)	/* GPIO  [6] wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO7	PWER_GPIO (7)	/* GPIO  [7] wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO8	PWER_GPIO (8)	/* GPIO  [8] wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO9	PWER_GPIO (9)	/* GPIO  [9] wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO10	PWER_GPIO (10)	/* GPIO [10] wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO11	PWER_GPIO (11)	/* GPIO [11] wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO12	PWER_GPIO (12)	/* GPIO [12] wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO13	PWER_GPIO (13)	/* GPIO [13] wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO14	PWER_GPIO (14)	/* GPIO [14] wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO15	PWER_GPIO (15)	/* GPIO [15] wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO16	PWER_GPIO (16)	/* GPIO [16] wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO17	PWER_GPIO (17)	/* GPIO [17] wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO18	PWER_GPIO (18)	/* GPIO [18] wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO19	PWER_GPIO (19)	/* GPIO [19] wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO20	PWER_GPIO (20)	/* GPIO [20] wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO21	PWER_GPIO (21)	/* GPIO [21] wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO22	PWER_GPIO (22)	/* GPIO [22] wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO23	PWER_GPIO (23)	/* GPIO [23] wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO24	PWER_GPIO (24)	/* GPIO [24] wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO25	PWER_GPIO (25)	/* GPIO [25] wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO26	PWER_GPIO (26)	/* GPIO [26] wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_GPIO27	PWER_GPIO (27)	/* GPIO [27] wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PWER_RTC	0x80000000	/* RTC alarm wake-up enable        */
NeoLKernel/arch/arm/mach-sa1100/irq.c:static int sa1100_low_gpio_wake(unsigned int irq, unsigned int on)
NeoLKernel/arch/arm/mach-sa1100/irq.c:	.set_wake	= sa1100_low_gpio_wake,
NeoLKernel/arch/arm/mach-sa1100/irq.c:static int sa1100_high_gpio_wake(unsigned int irq, unsigned int on)
NeoLKernel/arch/arm/mach-sa1100/irq.c:	.set_wake	= sa1100_high_gpio_wake,
NeoLKernel/arch/arm/mach-sa1100/irq.c: * Apart form GPIOs, only the RTC alarm can be a wakeup event.
NeoLKernel/arch/arm/mach-sa1100/irq.c:static int sa1100_set_wake(unsigned int irq, unsigned int on)
NeoLKernel/arch/arm/mach-sa1100/irq.c:	.set_wake	= sa1100_set_wake,
NeoLKernel/arch/arm/mach-sa1100/irq.c:	 * Set the appropriate edges for wakeup.
NeoLKernel/arch/arm/mach-sa1100/neponset.c:	 * We would set IRQ_GPIO25 to be a wake-up IRQ, but
NeoLKernel/arch/arm/mach-sa1100/neponset.c:	enable_irq_wake(IRQ_GPIO25);
NeoLKernel/arch/arm/mach-sa1100/simpad.c:	/* enable wake-up on GPIO0 (Assabet...) */
NeoLKernel/arch/arm/mm/.dma-mapping.o.cmd:  include/linux/pm_wakeup.h \
NeoLKernel/arch/arm/mm/.iomap.o.cmd:  include/linux/pm_wakeup.h \
Binary file NeoLKernel/arch/arm/mm/ioremap.o matches
Binary file NeoLKernel/arch/arm/mm/mmap.o matches
Binary file NeoLKernel/arch/arm/mm/mmu.o matches
Binary file NeoLKernel/arch/arm/mm/pgd.o matches
Binary file NeoLKernel/arch/arm/mm/proc-syms.o matches
Binary file NeoLKernel/arch/arm/mm/context.o matches
Binary file NeoLKernel/arch/arm/mm/copypage-v6.o matches
Binary file NeoLKernel/arch/arm/mm/dma-mapping.o matches
Binary file NeoLKernel/arch/arm/mm/fault-armv.o matches
Binary file NeoLKernel/arch/arm/mm/fault.o matches
Binary file NeoLKernel/arch/arm/mm/flush.o matches
Binary file NeoLKernel/arch/arm/mm/init.o matches
Binary file NeoLKernel/arch/arm/mm/iomap.o matches
Binary file NeoLKernel/arch/arm/mm/alignment.o matches
Binary file NeoLKernel/arch/arm/mm/built-in.o matches
Binary file NeoLKernel/arch/arm/perfmon/built-in.o matches
Binary file NeoLKernel/arch/arm/perfmon/perf-function-hooks.o matches
NeoLKernel/arch/arm/plat-omap/dmtimer.c:	 * Enable wake-up on OMAP2 CPUs.
NeoLKernel/arch/arm/plat-omap/gpio.c:	u32 suspend_wakeup;
NeoLKernel/arch/arm/plat-omap/gpio.c:	u32 saved_wakeup;
NeoLKernel/arch/arm/plat-omap/gpio.c:	u32 non_wakeup_gpios;
NeoLKernel/arch/arm/plat-omap/gpio.c:	u32 enabled_non_wakeup_gpios;
NeoLKernel/arch/arm/plat-omap/gpio.c:	if (likely(!(bank->non_wakeup_gpios & gpio_bit))) {
NeoLKernel/arch/arm/plat-omap/gpio.c:			bank->enabled_non_wakeup_gpios |= gpio_bit;
NeoLKernel/arch/arm/plat-omap/gpio.c:			bank->enabled_non_wakeup_gpios &= ~gpio_bit;
NeoLKernel/arch/arm/plat-omap/gpio.c:			/* Enable wake-up during idle for dynamic tick */
NeoLKernel/arch/arm/plat-omap/gpio.c: * 1510 does not seem to have a wake-up register. If JTAG is connected
NeoLKernel/arch/arm/plat-omap/gpio.c: * to the target, system will wake up always on GPIO events. While
NeoLKernel/arch/arm/plat-omap/gpio.c: * system is running all registered GPIO interrupts need to have wake-up
NeoLKernel/arch/arm/plat-omap/gpio.c: * to have wake-up enabled.
NeoLKernel/arch/arm/plat-omap/gpio.c:static int _set_gpio_wakeup(struct gpio_bank *bank, int gpio, int enable)
NeoLKernel/arch/arm/plat-omap/gpio.c:			bank->suspend_wakeup |= (1 << gpio);
NeoLKernel/arch/arm/plat-omap/gpio.c:			bank->suspend_wakeup &= ~(1 << gpio);
NeoLKernel/arch/arm/plat-omap/gpio.c:		if (bank->non_wakeup_gpios & (1 << gpio)) {
NeoLKernel/arch/arm/plat-omap/gpio.c:			printk(KERN_ERR "Unable to modify wakeup on "
NeoLKernel/arch/arm/plat-omap/gpio.c:					"non-wakeup GPIO%d\n",
NeoLKernel/arch/arm/plat-omap/gpio.c:			bank->suspend_wakeup |= (1 << gpio);
NeoLKernel/arch/arm/plat-omap/gpio.c:			bank->suspend_wakeup &= ~(1 << gpio);
NeoLKernel/arch/arm/plat-omap/gpio.c:		printk(KERN_ERR "Can't enable GPIO wakeup for method %i\n",
NeoLKernel/arch/arm/plat-omap/gpio.c:/* Use disable_irq_wake() and enable_irq_wake() functions from drivers */
NeoLKernel/arch/arm/plat-omap/gpio.c:static int gpio_wake_enable(unsigned int irq, unsigned int enable)
NeoLKernel/arch/arm/plat-omap/gpio.c:	retval = _set_gpio_wakeup(bank, get_gpio_index(gpio), enable);
NeoLKernel/arch/arm/plat-omap/gpio.c:		/* Disable wake-up during idle for dynamic tick */
NeoLKernel/arch/arm/plat-omap/gpio.c:		/* Disable wake-up during idle for dynamic tick */
NeoLKernel/arch/arm/plat-omap/gpio.c:	.set_wake	= gpio_wake_enable,
NeoLKernel/arch/arm/plat-omap/gpio.c:	/* REVISIT: assuming only 16xx supports MPUIO wake events */
NeoLKernel/arch/arm/plat-omap/gpio.c:	.set_wake	= gpio_wake_enable,
NeoLKernel/arch/arm/plat-omap/gpio.c:	bank->saved_wakeup = __raw_readl(mask_reg);
NeoLKernel/arch/arm/plat-omap/gpio.c:	__raw_writel(0xffff & ~bank->suspend_wakeup, mask_reg);
NeoLKernel/arch/arm/plat-omap/gpio.c:	__raw_writel(bank->saved_wakeup, mask_reg);
NeoLKernel/arch/arm/plat-omap/gpio.c:			static const u32 non_wakeup_gpios[] = {
NeoLKernel/arch/arm/plat-omap/gpio.c:			if (i < ARRAY_SIZE(non_wakeup_gpios))
NeoLKernel/arch/arm/plat-omap/gpio.c:				bank->non_wakeup_gpios = non_wakeup_gpios[i];
NeoLKernel/arch/arm/plat-omap/gpio.c:		void __iomem *wake_status;
NeoLKernel/arch/arm/plat-omap/gpio.c:		void __iomem *wake_clear;
NeoLKernel/arch/arm/plat-omap/gpio.c:		void __iomem *wake_set;
NeoLKernel/arch/arm/plat-omap/gpio.c:			wake_status = bank->base + OMAP1610_GPIO_WAKEUPENABLE;
NeoLKernel/arch/arm/plat-omap/gpio.c:			wake_clear = bank->base + OMAP1610_GPIO_CLEAR_WAKEUPENA;
NeoLKernel/arch/arm/plat-omap/gpio.c:			wake_set = bank->base + OMAP1610_GPIO_SET_WAKEUPENA;
NeoLKernel/arch/arm/plat-omap/gpio.c:			wake_status = bank->base + OMAP24XX_GPIO_WAKE_EN;
NeoLKernel/arch/arm/plat-omap/gpio.c:			wake_clear = bank->base + OMAP24XX_GPIO_CLEARWKUENA;
NeoLKernel/arch/arm/plat-omap/gpio.c:			wake_set = bank->base + OMAP24XX_GPIO_SETWKUENA;
NeoLKernel/arch/arm/plat-omap/gpio.c:			wake_status = bank->base + OMAP4_GPIO_IRQWAKEN0;
NeoLKernel/arch/arm/plat-omap/gpio.c:			wake_clear = bank->base + OMAP4_GPIO_IRQWAKEN0;
NeoLKernel/arch/arm/plat-omap/gpio.c:			wake_set = bank->base + OMAP4_GPIO_IRQWAKEN0;
NeoLKernel/arch/arm/plat-omap/gpio.c:		bank->saved_wakeup = __raw_readl(wake_status);
NeoLKernel/arch/arm/plat-omap/gpio.c:		__raw_writel(0xffffffff, wake_clear);
NeoLKernel/arch/arm/plat-omap/gpio.c:		__raw_writel(bank->suspend_wakeup, wake_set);
NeoLKernel/arch/arm/plat-omap/gpio.c:		void __iomem *wake_clear;
NeoLKernel/arch/arm/plat-omap/gpio.c:		void __iomem *wake_set;
NeoLKernel/arch/arm/plat-omap/gpio.c:			wake_clear = bank->base + OMAP1610_GPIO_CLEAR_WAKEUPENA;
NeoLKernel/arch/arm/plat-omap/gpio.c:			wake_set = bank->base + OMAP1610_GPIO_SET_WAKEUPENA;
NeoLKernel/arch/arm/plat-omap/gpio.c:			wake_clear = bank->base + OMAP24XX_GPIO_CLEARWKUENA;
NeoLKernel/arch/arm/plat-omap/gpio.c:			wake_set = bank->base + OMAP24XX_GPIO_SETWKUENA;
NeoLKernel/arch/arm/plat-omap/gpio.c:			wake_clear = bank->base + OMAP4_GPIO_IRQWAKEN0;
NeoLKernel/arch/arm/plat-omap/gpio.c:			wake_set = bank->base + OMAP4_GPIO_IRQWAKEN0;
NeoLKernel/arch/arm/plat-omap/gpio.c:		__raw_writel(0xffffffff, wake_clear);
NeoLKernel/arch/arm/plat-omap/gpio.c:		__raw_writel(bank->saved_wakeup, wake_set);
NeoLKernel/arch/arm/plat-omap/gpio.c:	/* Remove triggering for all non-wakeup GPIOs.  Otherwise spurious
NeoLKernel/arch/arm/plat-omap/gpio.c:		if (!(bank->enabled_non_wakeup_gpios))
NeoLKernel/arch/arm/plat-omap/gpio.c:		l1 &= ~bank->enabled_non_wakeup_gpios;
NeoLKernel/arch/arm/plat-omap/gpio.c:		l2 &= ~bank->enabled_non_wakeup_gpios;
NeoLKernel/arch/arm/plat-omap/gpio.c:		if (!(bank->enabled_non_wakeup_gpios))
NeoLKernel/arch/arm/plat-omap/gpio.c:		/* Check if any of the non-wakeup interrupt GPIOs have changed
NeoLKernel/arch/arm/plat-omap/gpio.c:		l &= bank->non_wakeup_gpios;
NeoLKernel/arch/arm/plat-omap/gpio.c:			if (is_in && ((bank->suspend_wakeup & mask)
NeoLKernel/arch/arm/plat-omap/gpio.c:						(bank->suspend_wakeup & mask)
NeoLKernel/arch/arm/plat-omap/gpio.c:							? " wakeup" : "");
NeoLKernel/arch/arm/plat-omap/include/mach/board.h:	/* implicitly true if otg:  host supports remote wakeup? */
NeoLKernel/arch/arm/plat-omap/include/mach/clockdomain.h:int omap2_clkdm_wakeup(struct clockdomain *clkdm);
NeoLKernel/arch/arm/plat-omap/include/mach/omap-pm.h: * omap_pm_set_max_mpu_wakeup_lat - set the maximum MPU wakeup latency
NeoLKernel/arch/arm/plat-omap/include/mach/omap-pm.h: * @t: maximum MPU wakeup latency in microseconds
NeoLKernel/arch/arm/plat-omap/include/mach/omap-pm.h: * This function will not affect device wakeup latency, e.g., time
NeoLKernel/arch/arm/plat-omap/include/mach/omap-pm.h: * other use.  To control this device wakeup latency, use
NeoLKernel/arch/arm/plat-omap/include/mach/omap-pm.h: * set_max_dev_wakeup_lat()
NeoLKernel/arch/arm/plat-omap/include/mach/omap-pm.h: * Multiple calls to set_max_mpu_wakeup_lat() will replace the
NeoLKernel/arch/arm/plat-omap/include/mach/omap-pm.h:void omap_pm_set_max_mpu_wakeup_lat(struct device *dev, long t);
NeoLKernel/arch/arm/plat-omap/include/mach/omap-pm.h: * omap_pm_set_max_dev_wakeup_lat - set the maximum device enable latency
NeoLKernel/arch/arm/plat-omap/include/mach/omap-pm.h: * @t: maximum device wakeup latency in microseconds
NeoLKernel/arch/arm/plat-omap/include/mach/omap-pm.h: * Multiple calls to set_max_dev_wakeup_lat() will replace the
NeoLKernel/arch/arm/plat-omap/include/mach/omap-pm.h: * previous wakeup latency values for this device.  To remove the wakeup
NeoLKernel/arch/arm/plat-omap/include/mach/omap-pm.h:void omap_pm_set_max_dev_wakeup_lat(struct device *dev, long t);
NeoLKernel/arch/arm/plat-omap/include/mach/omap-pm.h: * will not affect MPU wakeup latency.  Use set_max_cpu_lat() to do
NeoLKernel/arch/arm/plat-omap/include/mach/omap-pm.h: * so.  Similarly, this function will not affect device wakeup latency
NeoLKernel/arch/arm/plat-omap/include/mach/omap-pm.h: * -- use set_max_dev_wakeup_lat() to affect that.
NeoLKernel/arch/arm/plat-omap/include/mach/omap_device.h: * @dev_wakeup_lat: dev wakeup latency in microseconds
NeoLKernel/arch/arm/plat-omap/include/mach/omap_device.h: * @_dev_wakeup_lat_limit: dev wakeup latency limit in usec - set by OMAP PM
NeoLKernel/arch/arm/plat-omap/include/mach/omap_device.h:	u32				dev_wakeup_lat;
NeoLKernel/arch/arm/plat-omap/include/mach/omap_device.h:	u32				_dev_wakeup_lat_limit;
NeoLKernel/arch/arm/plat-omap/include/mach/omap_device.h:			     u32 new_wakeup_lat_limit);
NeoLKernel/arch/arm/plat-omap/include/mach/omap_hwmod.h:int omap_hwmod_enable_wakeup(struct omap_hwmod *oh);
NeoLKernel/arch/arm/plat-omap/include/mach/omap_hwmod.h:int omap_hwmod_disable_wakeup(struct omap_hwmod *oh);
NeoLKernel/arch/arm/plat-omap/include/mach/powerdomain.h:	/* Powerdomains that can be told to wake this powerdomain up */
NeoLKernel/arch/arm/plat-omap/include/mach/serial.h:extern void omap_uart_check_wakeup(void);
NeoLKernel/arch/arm/plat-omap/include/mach/smp.h: * set_event() is used to wake up secondary core from wfe using sev. ROM
NeoLKernel/arch/arm/plat-omap/Kconfig:	bool "Enable wake-up events for serial ports"
NeoLKernel/arch/arm/plat-omap/Kconfig:	  Select this option if you want to have your system wake up
NeoLKernel/arch/arm/plat-omap/Kconfig:	  to data on the serial RX line. This allows you to wake the
NeoLKernel/arch/arm/plat-omap/mcbsp.c:	 * Enable wakup behavior, smart idle and all wakeups
NeoLKernel/arch/arm/plat-omap/mcbsp.c:	 * REVISIT: some wakeups may be unnecessary
NeoLKernel/arch/arm/plat-omap/mcbsp.c:	 * Disable wakup behavior, smart idle and all wakeups
NeoLKernel/arch/arm/plat-omap/omap-pm-noop.c:void omap_pm_set_max_mpu_wakeup_lat(struct device *dev, long t)
NeoLKernel/arch/arm/plat-omap/omap-pm-noop.c:		pr_debug("OMAP PM: remove max MPU wakeup latency constraint: "
NeoLKernel/arch/arm/plat-omap/omap-pm-noop.c:		pr_debug("OMAP PM: add max MPU wakeup latency constraint: "
NeoLKernel/arch/arm/plat-omap/omap-pm-noop.c:void omap_pm_set_max_dev_wakeup_lat(struct device *dev, long t)
NeoLKernel/arch/arm/plat-omap/omap_device.c: * wakeup latency, but consuming more power).  If @ignore_lat is
NeoLKernel/arch/arm/plat-omap/omap_device.c: * if @ignore_lat is USE_WAKEUP_LAT, and the device's maximum wakeup
NeoLKernel/arch/arm/plat-omap/omap_device.c: * latency is greater than the requested maximum wakeup latency, step
NeoLKernel/arch/arm/plat-omap/omap_device.c: * device's maximum wakeup latency is less than or equal to the
NeoLKernel/arch/arm/plat-omap/omap_device.c: * requested maximum wakeup latency.  Returns 0.
NeoLKernel/arch/arm/plat-omap/omap_device.c:		    (od->dev_wakeup_lat <= od->_dev_wakeup_lat_limit))
NeoLKernel/arch/arm/plat-omap/omap_device.c:		od->dev_wakeup_lat -= odpl->activate_lat;
NeoLKernel/arch/arm/plat-omap/omap_device.c: * wakeup latency, but conserving power).  If @ignore_lat is
NeoLKernel/arch/arm/plat-omap/omap_device.c: * if @ignore_lat is USE_WAKEUP_LAT, and the device's maximum wakeup
NeoLKernel/arch/arm/plat-omap/omap_device.c: * latency is less than the requested maximum wakeup latency, step
NeoLKernel/arch/arm/plat-omap/omap_device.c: * maximum wakeup latency is less than or equal to the requested
NeoLKernel/arch/arm/plat-omap/omap_device.c: * maximum wakeup latency.  Returns 0.
NeoLKernel/arch/arm/plat-omap/omap_device.c:		    ((od->dev_wakeup_lat + odpl->activate_lat) >
NeoLKernel/arch/arm/plat-omap/omap_device.c:		     od->_dev_wakeup_lat_limit))
NeoLKernel/arch/arm/plat-omap/omap_device.c:		od->dev_wakeup_lat += odpl->activate_lat;
NeoLKernel/arch/arm/plat-omap/omap_device.c:	od->dev_wakeup_lat = 0;
NeoLKernel/arch/arm/plat-omap/omap_device.c:	od->_dev_wakeup_lat_limit = INT_MAX;
NeoLKernel/arch/arm/plat-omap/omap_device.c: * the device's maximum wakeup latency limit, pm_lat_limit.  Device
NeoLKernel/arch/arm/plat-omap/omap_device.c: * omap_device_align_pm_lat - activate/deactivate device to match wakeup lat lim
NeoLKernel/arch/arm/plat-omap/omap_device.c: * When a device's maximum wakeup latency limit changes, call some of
NeoLKernel/arch/arm/plat-omap/omap_device.c: * wakeup latency is less than or equal to the new latency limit.
NeoLKernel/arch/arm/plat-omap/omap_device.c: * wakeup latency limit changes (e.g., via
NeoLKernel/arch/arm/plat-omap/omap_device.c: * omap_pm_set_dev_wakeup_lat()).  Returns 0 if nothing needs to be
NeoLKernel/arch/arm/plat-omap/omap_device.c: * wakeup latency is already current with the new limit) or passes
NeoLKernel/arch/arm/plat-omap/omap_device.c:			     u32 new_wakeup_lat_limit)
NeoLKernel/arch/arm/plat-omap/omap_device.c:	if (new_wakeup_lat_limit == od->dev_wakeup_lat)
NeoLKernel/arch/arm/plat-omap/omap_device.c:	od->_dev_wakeup_lat_limit = new_wakeup_lat_limit;
NeoLKernel/arch/arm/plat-omap/omap_device.c:	else if (new_wakeup_lat_limit > od->dev_wakeup_lat)
NeoLKernel/arch/arm/plat-omap/omap_device.c:	else if (new_wakeup_lat_limit < od->dev_wakeup_lat)
NeoLKernel/arch/arm/plat-pxa/gpio.c:void __init pxa_init_gpio(int mux_irq, int start, int end, set_wake_t fn)
NeoLKernel/arch/arm/plat-pxa/gpio.c:	pxa_muxed_gpio_chip.set_wake = fn;
NeoLKernel/arch/arm/plat-pxa/include/plat/gpio.h:typedef int (*set_wake_t)(unsigned int irq, unsigned int on);
NeoLKernel/arch/arm/plat-pxa/include/plat/gpio.h:extern void pxa_init_gpio(int mux_irq, int start, int end, set_wake_t fn);
NeoLKernel/arch/arm/plat-s3c/include/plat/pm.h:extern unsigned long s3c_irqwake_intmask;
NeoLKernel/arch/arm/plat-s3c/include/plat/pm.h:extern unsigned long s3c_irqwake_eintmask;
NeoLKernel/arch/arm/plat-s3c/include/plat/pm.h:extern unsigned long s3c_irqwake_intallow;
NeoLKernel/arch/arm/plat-s3c/include/plat/pm.h:extern unsigned long s3c_irqwake_eintallow;
NeoLKernel/arch/arm/plat-s3c/include/plat/pm.h:extern int s3c_irqext_wake(unsigned int irqno, unsigned int state);
NeoLKernel/arch/arm/plat-s3c/include/plat/pm.h:#define s3c_irqext_wake NULL
NeoLKernel/arch/arm/plat-s3c/pm.c:unsigned long s3c_irqwake_intmask	= 0xffffffffL;
NeoLKernel/arch/arm/plat-s3c/pm.c:unsigned long s3c_irqwake_eintmask	= 0xffffffffL;
NeoLKernel/arch/arm/plat-s3c/pm.c:int s3c_irqext_wake(unsigned int irqno, unsigned int state)
NeoLKernel/arch/arm/plat-s3c/pm.c:	if (!(s3c_irqwake_eintallow & bit))
NeoLKernel/arch/arm/plat-s3c/pm.c:	printk(KERN_INFO "wake %s for irq %d\n",
NeoLKernel/arch/arm/plat-s3c/pm.c:		s3c_irqwake_eintmask |= bit;
NeoLKernel/arch/arm/plat-s3c/pm.c:		s3c_irqwake_eintmask &= ~bit;
NeoLKernel/arch/arm/plat-s3c/pm.c: * array for later restoration when we wakeup.
NeoLKernel/arch/arm/plat-s3c/pm.c:	/* check if we have anything to wake-up with... bad things seem
NeoLKernel/arch/arm/plat-s3c/pm.c:	 * to happen if you suspend with no wakeup (system will often
NeoLKernel/arch/arm/plat-s3c/pm.c:	if (!any_allowed(s3c_irqwake_intmask, s3c_irqwake_intallow) &&
NeoLKernel/arch/arm/plat-s3c/pm.c:	    !any_allowed(s3c_irqwake_eintmask, s3c_irqwake_eintallow)) {
NeoLKernel/arch/arm/plat-s3c/pm.c:		printk(KERN_ERR "%s: No wake-up sources!\n", __func__);
NeoLKernel/arch/arm/plat-s3c/pm.c:	/* set the irq configuration for wake */
NeoLKernel/arch/arm/plat-s3c/pm.c:	S3C_PMDBG("sleep: irq wakeup masks: %08lx,%08lx\n",
NeoLKernel/arch/arm/plat-s3c/pm.c:	    s3c_irqwake_intmask, s3c_irqwake_eintmask);
NeoLKernel/arch/arm/plat-s3c24xx/adc.c:	wake_up(client->wait);
NeoLKernel/arch/arm/plat-s3c24xx/adc.c:	DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wake);
NeoLKernel/arch/arm/plat-s3c24xx/adc.c:	client->wait = &wake;
NeoLKernel/arch/arm/plat-s3c24xx/adc.c:	ret = wait_event_timeout(wake, client->result >= 0, HZ / 2);
NeoLKernel/arch/arm/plat-s3c24xx/include/plat/irq.h:extern int s3c_irq_wake(unsigned int irqno, unsigned int state);
NeoLKernel/arch/arm/plat-s3c24xx/include/plat/irq.h:#define s3c_irq_wake NULL
NeoLKernel/arch/arm/plat-s3c24xx/include/plat/pm-core.h:	__raw_writel(s3c_irqwake_intmask, S3C2410_INTMSK);
NeoLKernel/arch/arm/plat-s3c24xx/include/plat/pm-core.h:	__raw_writel(s3c_irqwake_eintmask, S3C2410_EINTMASK);
NeoLKernel/arch/arm/plat-s3c24xx/include/plat/pm-core.h:				s3c_irqwake_intmask);
NeoLKernel/arch/arm/plat-s3c24xx/include/plat/pm-core.h:				s3c_irqwake_eintmask);
NeoLKernel/arch/arm/plat-s3c24xx/irq-pm.c:/* default is to allow for EINT0..EINT15, and IRQ_RTC as wakeup sources
NeoLKernel/arch/arm/plat-s3c24xx/irq-pm.c: * set bit to 1 in allow bitfield to enable the wakeup settings on it
NeoLKernel/arch/arm/plat-s3c24xx/irq-pm.c:unsigned long s3c_irqwake_intallow	= 1L << (IRQ_RTC - IRQ_EINT0) | 0xfL;
NeoLKernel/arch/arm/plat-s3c24xx/irq-pm.c:unsigned long s3c_irqwake_eintallow	= 0x0000fff0L;
NeoLKernel/arch/arm/plat-s3c24xx/irq-pm.c:int s3c_irq_wake(unsigned int irqno, unsigned int state)
NeoLKernel/arch/arm/plat-s3c24xx/irq-pm.c:	if (!(s3c_irqwake_intallow & irqbit))
NeoLKernel/arch/arm/plat-s3c24xx/irq-pm.c:	printk(KERN_INFO "wake %s for irq %d\n",
NeoLKernel/arch/arm/plat-s3c24xx/irq-pm.c:		s3c_irqwake_intmask |= irqbit;
NeoLKernel/arch/arm/plat-s3c24xx/irq-pm.c:		s3c_irqwake_intmask &= ~irqbit;
NeoLKernel/arch/arm/plat-s3c24xx/irq.c:	.set_wake	= s3c_irq_wake
NeoLKernel/arch/arm/plat-s3c24xx/irq.c:	.set_wake	= s3c_irq_wake
NeoLKernel/arch/arm/plat-s3c24xx/irq.c:	.set_wake	= s3c_irqext_wake
NeoLKernel/arch/arm/plat-s3c24xx/irq.c:	.set_wake	= s3c_irq_wake,
NeoLKernel/arch/arm/plat-s3c24xx/pm.c:		irqstate = s3c_irqwake_intmask & (1L<<irqoffs);
NeoLKernel/arch/arm/plat-s3c24xx/pm.c:		irqstate = s3c_irqwake_eintmask & (1L<<irqoffs);
NeoLKernel/arch/arm/plat-s3c64xx/include/plat/pm-core.h: * the IRQ wake controls depending on the CPU we are running on */
NeoLKernel/arch/arm/plat-s3c64xx/include/plat/pm-core.h:#define s3c_irqwake_eintallow	((1 << 28) - 1)
NeoLKernel/arch/arm/plat-s3c64xx/include/plat/pm-core.h:#define s3c_irqwake_intallow	(0)
NeoLKernel/arch/arm/plat-s3c64xx/irq-eint.c:	.set_wake	= s3c_irqext_wake,
NeoLKernel/arch/arm/plat-s3c64xx/pm.c:	__raw_writel(s3c_irqwake_eintmask, S3C64XX_EINT_MASK);
NeoLKernel/arch/arm/plat-s3c64xx/pm.c:	/* clear any old wakeup */
NeoLKernel/arch/arm/plat-s3c64xx/pm.c:	/* ensure previous wakeup state is cleared before sleeping */
Binary file NeoLKernel/arch/arm/vfp/built-in.o matches
Binary file NeoLKernel/arch/arm/vfp/vfp.o matches
Binary file NeoLKernel/arch/arm/vfp/vfpmodule.o matches
NeoLKernel/arch/avr32/include/asm/mach/serial_at91.h:	int	(*set_wake)(struct uart_port *, u_int);
NeoLKernel/arch/avr32/kernel/ptrace.c:		wake_up_process(child);
NeoLKernel/arch/avr32/kernel/ptrace.c:		wake_up_process(child);
NeoLKernel/arch/avr32/kernel/ptrace.c:		wake_up_process(child);
NeoLKernel/arch/avr32/mach-at32ap/pm-at32ap700x.S:	 * marked as 'wakeup' event sources may still come along and
NeoLKernel/arch/avr32/mach-at32ap/pm-at32ap700x.S:	 * start the HSB and CPU clocks upon a wakeup event.
NeoLKernel/arch/avr32/mach-at32ap/pm.c:	pr_debug("%s: wakeup\n", __func__);
NeoLKernel/arch/blackfin/include/asm/bfin-global.h:extern int bfin_internal_set_wake(unsigned int irq, unsigned int state);
NeoLKernel/arch/blackfin/include/asm/bfin-global.h:extern unsigned vr_wakeup;
NeoLKernel/arch/blackfin/include/asm/dpmc.h:void do_hibernate(int wakeup);
NeoLKernel/arch/blackfin/include/asm/gpio.h:int gpio_pm_wakeup_request(unsigned gpio, unsigned char type);
NeoLKernel/arch/blackfin/include/asm/gpio.h:void gpio_pm_wakeup_free(unsigned gpio);
NeoLKernel/arch/blackfin/Kconfig:	  such as GPIO interrupt or RTC activity wakes up the processor.
NeoLKernel/arch/blackfin/Kconfig:	  this mode. Typically an external event or RTC activity will wake
NeoLKernel/arch/blackfin/Kconfig:	  the general-purpose wake-up enable (GPWE) control bit to enable
NeoLKernel/arch/blackfin/Kconfig:	  wake-up upon detection of an active low signal on the /GPW (PH7) pin.
NeoLKernel/arch/blackfin/kernel/bfin_gpio.c:static unsigned short wakeup_map[GPIO_BANK_NUM];
NeoLKernel/arch/blackfin/kernel/bfin_gpio.c:static unsigned char wakeup_flags_map[MAX_BLACKFIN_GPIOS];
NeoLKernel/arch/blackfin/kernel/bfin_gpio.c:int gpio_pm_wakeup_request(unsigned gpio, unsigned char type)
NeoLKernel/arch/blackfin/kernel/bfin_gpio.c:	wakeup_map[gpio_bank(gpio)] |= gpio_bit(gpio);
NeoLKernel/arch/blackfin/kernel/bfin_gpio.c:	wakeup_flags_map[gpio] = type;
NeoLKernel/arch/blackfin/kernel/bfin_gpio.c:EXPORT_SYMBOL(gpio_pm_wakeup_request);
NeoLKernel/arch/blackfin/kernel/bfin_gpio.c:void gpio_pm_wakeup_free(unsigned gpio)
NeoLKernel/arch/blackfin/kernel/bfin_gpio.c:	wakeup_map[gpio_bank(gpio)] &= ~gpio_bit(gpio);
NeoLKernel/arch/blackfin/kernel/bfin_gpio.c:EXPORT_SYMBOL(gpio_pm_wakeup_free);
NeoLKernel/arch/blackfin/kernel/bfin_gpio.c:static int bfin_gpio_wakeup_type(unsigned gpio, unsigned char type)
NeoLKernel/arch/blackfin/kernel/bfin_gpio.c:		mask = wakeup_map[gpio_bank(i)];
NeoLKernel/arch/blackfin/kernel/bfin_gpio.c:				if ((mask & 1) && (wakeup_flags_map[gpio] !=
NeoLKernel/arch/blackfin/kernel/bfin_gpio.c:					bfin_gpio_wakeup_type(gpio,
NeoLKernel/arch/blackfin/kernel/bfin_gpio.c:						wakeup_flags_map[gpio]);
NeoLKernel/arch/blackfin/kernel/bfin_gpio.c:			bfin_internal_set_wake(sic_iwr_irqs[bank], 1);
NeoLKernel/arch/blackfin/kernel/bfin_gpio.c:			gpio_array[bank]->maskb_set = wakeup_map[gpio_bank(i)];
NeoLKernel/arch/blackfin/kernel/bfin_gpio.c:		mask = wakeup_map[gpio_bank(i)];
NeoLKernel/arch/blackfin/kernel/bfin_gpio.c:			bfin_internal_set_wake(sic_iwr_irqs[bank], 0);
NeoLKernel/arch/blackfin/kernel/process.c: * interrupts here to ensure we don't miss a wakeup call.
NeoLKernel/arch/blackfin/kernel/ptrace.c:		pr_debug("ptrace: before wake_up_process\n");
NeoLKernel/arch/blackfin/kernel/ptrace.c:		wake_up_process(child);
NeoLKernel/arch/blackfin/kernel/ptrace.c:		wake_up_process(child);
NeoLKernel/arch/blackfin/kernel/ptrace.c:		wake_up_process(child);
NeoLKernel/arch/blackfin/mach-bf527/boards/cm_bf527.c:	.remote_wakeup_connected = 0,
NeoLKernel/arch/blackfin/mach-bf527/boards/ezkit.c:	.remote_wakeup_connected = 0,
NeoLKernel/arch/blackfin/mach-bf533/boards/cm_bf533.c:	.remote_wakeup_connected = 0,
NeoLKernel/arch/blackfin/mach-bf533/boards/ip0x.c:	.remote_wakeup_connected = 0,
NeoLKernel/arch/blackfin/mach-bf533/include/mach/anomaly.h:/* Internal voltage regulator does not wake up from an RTC wakeup */
NeoLKernel/arch/blackfin/mach-bf537/boards/cm_bf537e.c:	.remote_wakeup_connected = 0,
NeoLKernel/arch/blackfin/mach-bf537/boards/cm_bf537u.c:	.remote_wakeup_connected = 0,
NeoLKernel/arch/blackfin/mach-bf537/boards/pnav10.c:	.remote_wakeup_connected = 0,
NeoLKernel/arch/blackfin/mach-bf537/boards/stamp.c:	.remote_wakeup_connected = 0,
NeoLKernel/arch/blackfin/mach-bf537/boards/tcm_bf537.c:	.remote_wakeup_connected = 0,
NeoLKernel/arch/blackfin/mach-bf548/include/mach/defBF54x_base.h:#define BCODE_WAKEUP    0x0000  /* boot according to wake-up condition */
NeoLKernel/arch/blackfin/mach-bf561/boards/cm_bf561.c:	.remote_wakeup_connected = 0,
NeoLKernel/arch/blackfin/mach-bf561/boards/ezkit.c:	.remote_wakeup_connected = 0,
NeoLKernel/arch/blackfin/mach-common/dpmc_modes.S:	call _set_sic_iwr;	/* Set Awake from IDLE */
NeoLKernel/arch/blackfin/mach-common/dpmc_modes.S:	call _set_sic_iwr;	/* Set Awake from IDLE PLL */
NeoLKernel/arch/blackfin/mach-common/ints-priority.c:unsigned vr_wakeup;
NeoLKernel/arch/blackfin/mach-common/ints-priority.c:int bfin_internal_set_wake(unsigned int irq, unsigned int state)
NeoLKernel/arch/blackfin/mach-common/ints-priority.c:	u32 bank, bit, wakeup = 0;
NeoLKernel/arch/blackfin/mach-common/ints-priority.c:	wakeup |= WAKE;
NeoLKernel/arch/blackfin/mach-common/ints-priority.c:	wakeup |= CANWE;
NeoLKernel/arch/blackfin/mach-common/ints-priority.c:	wakeup |= CANWE;
NeoLKernel/arch/blackfin/mach-common/ints-priority.c:	wakeup |= USBWE;
NeoLKernel/arch/blackfin/mach-common/ints-priority.c:	wakeup |= KPADWE;
NeoLKernel/arch/blackfin/mach-common/ints-priority.c:	wakeup |= ROTWE;
NeoLKernel/arch/blackfin/mach-common/ints-priority.c:		vr_wakeup  |= wakeup;
NeoLKernel/arch/blackfin/mach-common/ints-priority.c:		vr_wakeup  &= ~wakeup;
NeoLKernel/arch/blackfin/mach-common/ints-priority.c:	.set_wake = bfin_internal_set_wake,
NeoLKernel/arch/blackfin/mach-common/ints-priority.c:int bfin_gpio_set_wake(unsigned int irq, unsigned int state)
NeoLKernel/arch/blackfin/mach-common/ints-priority.c:		gpio_pm_wakeup_request(gpio, PM_WAKE_IGNORE);
NeoLKernel/arch/blackfin/mach-common/ints-priority.c:		gpio_pm_wakeup_free(gpio);
NeoLKernel/arch/blackfin/mach-common/ints-priority.c:u32 pint_wakeup_masks[NR_PINT_SYS_IRQS];
NeoLKernel/arch/blackfin/mach-common/ints-priority.c:int bfin_gpio_set_wake(unsigned int irq, unsigned int state)
NeoLKernel/arch/blackfin/mach-common/ints-priority.c:	bfin_internal_set_wake(pint_irq, state);
NeoLKernel/arch/blackfin/mach-common/ints-priority.c:		pint_wakeup_masks[bank] |= pintbit;
NeoLKernel/arch/blackfin/mach-common/ints-priority.c:		pint_wakeup_masks[bank] &= ~pintbit;
NeoLKernel/arch/blackfin/mach-common/ints-priority.c:		if (val ^ pint_wakeup_masks[i]) {
NeoLKernel/arch/blackfin/mach-common/ints-priority.c:			pint[i]->mask_set = pint_wakeup_masks[i];
NeoLKernel/arch/blackfin/mach-common/ints-priority.c:		if (val ^ pint_wakeup_masks[i]) {
NeoLKernel/arch/blackfin/mach-common/ints-priority.c:	.set_wake = bfin_gpio_set_wake,
NeoLKernel/arch/blackfin/mach-common/ints-priority.c:	 * Boot-ROM code modifies SICA_IWRx wakeup registers
NeoLKernel/arch/blackfin/mach-common/pm.c:	gpio_pm_wakeup_request(CONFIG_PM_WAKEUP_GPIO_NUMBER, WAKEUP_TYPE);
NeoLKernel/arch/blackfin/mach-common/pm.c:	int wakeup, ret;
NeoLKernel/arch/blackfin/mach-common/pm.c:	wakeup = bfin_read_VR_CTL() & ~FREQ;
NeoLKernel/arch/blackfin/mach-common/pm.c:	wakeup |= SCKELOW;
NeoLKernel/arch/blackfin/mach-common/pm.c:	wakeup |= PHYWE;
NeoLKernel/arch/blackfin/mach-common/pm.c:	wakeup |= GPWE;
NeoLKernel/arch/blackfin/mach-common/pm.c:	do_hibernate(wakeup | vr_wakeup);	/* Goodbye */
NeoLKernel/arch/cris/arch-v10/drivers/eeprom.c:    /* don't forget to wake them up */
NeoLKernel/arch/cris/arch-v10/drivers/eeprom.c:    wake_up_interruptible(&eeprom.wait_q);  
NeoLKernel/arch/cris/arch-v10/drivers/eeprom.c:  wake_up_interruptible(&eeprom.wait_q);
NeoLKernel/arch/cris/arch-v10/drivers/eeprom.c:        /* don't forget to wake them up */
NeoLKernel/arch/cris/arch-v10/drivers/eeprom.c:        wake_up_interruptible(&eeprom.wait_q);
NeoLKernel/arch/cris/arch-v10/drivers/eeprom.c:  wake_up_interruptible(&eeprom.wait_q);
NeoLKernel/arch/cris/arch-v10/drivers/gpio.c:int etrax_gpio_wake_up_check(void)
NeoLKernel/arch/cris/arch-v10/drivers/gpio.c:			DP(printk("etrax_gpio_wake_up_check %i\n",priv->minor));
NeoLKernel/arch/cris/arch-v10/drivers/gpio.c:			wake_up_interruptible(&priv->alarm_wq);
NeoLKernel/arch/cris/arch-v10/drivers/gpio.c:		etrax_gpio_wake_up_check();
NeoLKernel/arch/cris/arch-v10/drivers/gpio.c:		return IRQ_RETVAL(etrax_gpio_wake_up_check());
NeoLKernel/arch/cris/arch-v10/drivers/gpio.c:	/* We call etrax_gpio_wake_up_check() from timer interrupt and
NeoLKernel/arch/cris/arch-v10/drivers/sync_serial.c:		/* wake up the waiting process */
NeoLKernel/arch/cris/arch-v10/drivers/sync_serial.c:		wake_up_interruptible(&port->out_wait_q);
NeoLKernel/arch/cris/arch-v10/drivers/sync_serial.c:			wake_up_interruptible(&port->in_wait_q);
NeoLKernel/arch/cris/arch-v10/drivers/sync_serial.c:				wake_up_interruptible(&port->in_wait_q);
NeoLKernel/arch/cris/arch-v10/drivers/sync_serial.c:				wake_up_interruptible(&port->out_wait_q);
NeoLKernel/arch/cris/arch-v10/kernel/fasttimer.c:static void wake_up_func(unsigned long data)
NeoLKernel/arch/cris/arch-v10/kernel/fasttimer.c:  wake_up(sleep_wait_p);
NeoLKernel/arch/cris/arch-v10/kernel/fasttimer.c:  start_one_shot_timer(&t, wake_up_func, (unsigned long)&sleep_wait, us,
NeoLKernel/arch/cris/arch-v10/kernel/fasttimer.c:	 * redundant since the timer is what wakes us up.) */
NeoLKernel/arch/cris/arch-v10/kernel/process.c:void etrax_gpio_wake_up_check(void); /* drivers/gpio.c */
NeoLKernel/arch/cris/arch-v10/kernel/process.c:  etrax_gpio_wake_up_check();
NeoLKernel/arch/cris/arch-v10/kernel/ptrace.c:			wake_up_process(child);
NeoLKernel/arch/cris/arch-v10/kernel/ptrace.c:			wake_up_process(child);
NeoLKernel/arch/cris/arch-v10/kernel/ptrace.c:			wake_up_process(child);
NeoLKernel/arch/cris/arch-v32/drivers/cryptocop.c:	wake_up(&cryptocop_ioc_process_wq);
NeoLKernel/arch/cris/arch-v32/drivers/mach-fs/gpio.c:int etrax_gpio_wake_up_check(void)
NeoLKernel/arch/cris/arch-v32/drivers/mach-fs/gpio.c:				"etrax_gpio_wake_up_check %i\n", priv->minor));
NeoLKernel/arch/cris/arch-v32/drivers/mach-fs/gpio.c:			wake_up_interruptible(&priv->alarm_wq);
NeoLKernel/arch/cris/arch-v32/drivers/mach-fs/gpio.c:		return IRQ_RETVAL(etrax_gpio_wake_up_check());
NeoLKernel/arch/cris/arch-v32/drivers/mach-fs/gpio.c:		return IRQ_RETVAL(etrax_gpio_wake_up_check());
NeoLKernel/arch/cris/arch-v32/drivers/mach-fs/gpio.c:	/* We call etrax_gpio_wake_up_check() from timer interrupt and
NeoLKernel/arch/cris/arch-v32/drivers/sync_serial.c:		/* wake up the waiting process */
NeoLKernel/arch/cris/arch-v32/drivers/sync_serial.c:		wake_up_interruptible(&port->out_wait_q);
NeoLKernel/arch/cris/arch-v32/drivers/sync_serial.c:				/* wake up the waiting process */
NeoLKernel/arch/cris/arch-v32/drivers/sync_serial.c:				wake_up_interruptible(&port->in_wait_q);
NeoLKernel/arch/cris/arch-v32/drivers/sync_serial.c:				wake_up_interruptible(&port->in_wait_q); /* Wake up application */
NeoLKernel/arch/cris/arch-v32/drivers/sync_serial.c:				wake_up_interruptible(&port->out_wait_q); /* Wake up application */
NeoLKernel/arch/cris/arch-v32/kernel/fasttimer.c:static void wake_up_func(unsigned long data)
NeoLKernel/arch/cris/arch-v32/kernel/fasttimer.c:  wake_up(sleep_wait_p);
NeoLKernel/arch/cris/arch-v32/kernel/fasttimer.c:  start_one_shot_timer(&t, wake_up_func, (unsigned long)&sleep_wait, us,
NeoLKernel/arch/cris/arch-v32/kernel/fasttimer.c:	 * somewhat redundant since the timer is what wakes us up.) */
NeoLKernel/arch/cris/arch-v32/kernel/ptrace.c:			wake_up_process(child);
NeoLKernel/arch/cris/arch-v32/kernel/ptrace.c:			wake_up_process(child);
NeoLKernel/arch/cris/arch-v32/kernel/ptrace.c:			wake_up_process(child);
NeoLKernel/arch/cris/include/arch-v10/arch/sv_addr.agh:#define R_USB_COMMAND_DEV__port_cmd__wakeup 3
NeoLKernel/arch/frv/kernel/local.h:extern void (*__power_switch_wake_setup)(void);
NeoLKernel/arch/frv/kernel/local.h:extern int  (*__power_switch_wake_check)(void);
NeoLKernel/arch/frv/kernel/local.h:extern void (*__power_switch_wake_cleanup)(void);
NeoLKernel/arch/frv/kernel/pm-mb93093.c: * Setup interrupt masks, etc to enable wakeup by power switch
NeoLKernel/arch/frv/kernel/pm-mb93093.c: * Cleanup interrupt masks, etc after wakeup by power switch
NeoLKernel/arch/frv/kernel/pm-mb93093.c: * Return non-zero if wakeup irq was caused by power switch
NeoLKernel/arch/frv/kernel/pm-mb93093.c:	__power_switch_wake_setup = mb93093_power_switch_setup;
NeoLKernel/arch/frv/kernel/pm-mb93093.c:	__power_switch_wake_check = mb93093_power_switch_check;
NeoLKernel/arch/frv/kernel/pm-mb93093.c:	__power_switch_wake_cleanup = mb93093_power_switch_cleanup;
NeoLKernel/arch/frv/kernel/pm.c: * Setup interrupt masks, etc to enable wakeup by power switch
NeoLKernel/arch/frv/kernel/pm.c: * Cleanup interrupt masks, etc after wakeup by power switch
NeoLKernel/arch/frv/kernel/pm.c: * Return non-zero if wakeup irq was caused by power switch
NeoLKernel/arch/frv/kernel/pm.c:void (*__power_switch_wake_setup)(void) = __default_power_switch_setup;
NeoLKernel/arch/frv/kernel/pm.c:int  (*__power_switch_wake_check)(void) = __default_power_switch_check;
NeoLKernel/arch/frv/kernel/pm.c:void (*__power_switch_wake_cleanup)(void) = __default_power_switch_cleanup;
NeoLKernel/arch/frv/kernel/pm.c:	 * of the interrupt state so that appropriate wakeup
NeoLKernel/arch/frv/kernel/pm.c:	__power_switch_wake_setup();
NeoLKernel/arch/frv/kernel/pm.c:	 * devices. The wake_check() tells us if we need to finish waking
NeoLKernel/arch/frv/kernel/pm.c:	} while (__power_switch_wake_check && !__power_switch_wake_check());
NeoLKernel/arch/frv/kernel/pm.c:	__power_switch_wake_cleanup();
NeoLKernel/arch/frv/kernel/sleep.S:	# wake SDRAM from self-refresh mode
NeoLKernel/arch/frv/kernel/sleep.S:	# Fall-through to the RAMBOOT# wakeup path
NeoLKernel/arch/h8300/kernel/ptrace.c:			wake_up_process(child);
NeoLKernel/arch/h8300/kernel/ptrace.c:			wake_up_process(child);
NeoLKernel/arch/h8300/kernel/ptrace.c:			wake_up_process(child);
NeoLKernel/arch/ia64/hp/sim/boot/fw-emu.c:	efi_runtime->get_wakeup_time = __pa(&efi_unimplemented);
NeoLKernel/arch/ia64/hp/sim/boot/fw-emu.c:	efi_runtime->set_wakeup_time = __pa(&efi_unimplemented);
NeoLKernel/arch/ia64/hp/sim/simserial.c:	tty_wakeup(tty);
NeoLKernel/arch/ia64/hp/sim/simserial.c:		wake_up_interruptible(&info->open_wait);
NeoLKernel/arch/ia64/hp/sim/simserial.c:	wake_up_interruptible(&info->close_wait);
NeoLKernel/arch/ia64/hp/sim/simserial.c:	wake_up_interruptible(&info->open_wait);
NeoLKernel/arch/ia64/include/asm/acpi.h:extern unsigned long acpi_wakeup_address;
NeoLKernel/arch/ia64/include/asm/kvm_host.h:	/*halt timer to wake up sleepy vcpus*/
NeoLKernel/arch/ia64/include/asm/topology.h:	.wake_idx		= 0,			\
NeoLKernel/arch/ia64/include/asm/topology.h:	.wake_idx		= 0,			\
NeoLKernel/arch/ia64/include/asm/rwsem.h:extern struct rw_semaphore *rwsem_wake(struct rw_semaphore *sem);
NeoLKernel/arch/ia64/include/asm/rwsem.h:extern struct rw_semaphore *rwsem_downgrade_wake(struct rw_semaphore *sem);
NeoLKernel/arch/ia64/include/asm/rwsem.h:		rwsem_wake(sem);
NeoLKernel/arch/ia64/include/asm/rwsem.h:		rwsem_wake(sem);
NeoLKernel/arch/ia64/include/asm/rwsem.h:		rwsem_downgrade_wake(sem);
NeoLKernel/arch/ia64/include/asm/sal.h:typedef struct ia64_sal_desc_ap_wakeup {
NeoLKernel/arch/ia64/include/asm/sal.h:} ia64_sal_desc_ap_wakeup_t ;
NeoLKernel/arch/ia64/include/asm/sal.h: * Causes the processor to go into a spin loop within SAL where SAL awaits a wakeup from
NeoLKernel/arch/ia64/include/asm/sal.h: * monarch processor sends a wake up.
NeoLKernel/arch/ia64/include/asm/sal.h: * the machine check rendezvous sequence as well as the mechanism to wake up the
NeoLKernel/arch/ia64/include/asm/smp.h:extern unsigned long ap_wakeup_vector;
NeoLKernel/arch/ia64/include/asm/hw_irq.h:#define	IA64_MCA_WAKEUP_VECTOR		0xf0	/* MCA wakeup (must be >MCA_RENDEZ_VECTOR) */
NeoLKernel/arch/ia64/kernel/acpi.c:unsigned long acpi_wakeup_address = 0;
NeoLKernel/arch/ia64/kernel/efi.c:prefix##_get_wakeup_time (efi_bool_t *enabled, efi_bool_t *pending,	       \
NeoLKernel/arch/ia64/kernel/efi.c:		(efi_get_wakeup_time_t *) __va(runtime->get_wakeup_time),      \
NeoLKernel/arch/ia64/kernel/efi.c:prefix##_set_wakeup_time (efi_bool_t enabled, efi_time_t *tm)		       \
NeoLKernel/arch/ia64/kernel/efi.c:		(efi_set_wakeup_time_t *) __va(runtime->set_wakeup_time),      \
NeoLKernel/arch/ia64/kernel/efi.c:	efi.get_wakeup_time = phys_get_wakeup_time;
NeoLKernel/arch/ia64/kernel/efi.c:	efi.set_wakeup_time = phys_set_wakeup_time;
NeoLKernel/arch/ia64/kernel/efi.c:	efi.get_wakeup_time = virt_get_wakeup_time;
NeoLKernel/arch/ia64/kernel/efi.c:	efi.set_wakeup_time = virt_set_wakeup_time;
NeoLKernel/arch/ia64/kernel/perfmon.c:	 * we must force it to wakeup to get out of the
NeoLKernel/arch/ia64/kernel/perfmon.c:		 * by pfm_load_regs() which is called upon wakeup from down().
NeoLKernel/arch/ia64/kernel/perfmon.c:		 * force task to wake up from MASKED state
NeoLKernel/arch/ia64/kernel/perfmon.c:		DPRINT(("after zombie wakeup ctx_state=%d for\n", state));
NeoLKernel/arch/ia64/kernel/perfmon.c:	 * and wakeup controlling task, indicating we are now disconnected
NeoLKernel/arch/ia64/kernel/perfmon.c:	wake_up_interruptible(&ctx->ctx_zombieq);
NeoLKernel/arch/ia64/kernel/perfmon.c:	 * we need to read the ovfl_regs only after wake-up
NeoLKernel/arch/ia64/kernel/perfmon.c:	if (msg) wake_up_interruptible(&ctx->ctx_msgq_wait);
NeoLKernel/arch/ia64/kernel/ptrace.c:	 * job control stop, so that SIGCONT can be used to wake it up.
NeoLKernel/arch/ia64/kernel/sal.c:sal_desc_ap_wakeup (void *p)
NeoLKernel/arch/ia64/kernel/sal.c:	struct ia64_sal_desc_ap_wakeup *ap = p;
NeoLKernel/arch/ia64/kernel/sal.c:		ap_wakeup_vector = ap->vector;
NeoLKernel/arch/ia64/kernel/sal.c:		printk(KERN_INFO "SAL: AP wakeup using external interrupt "
NeoLKernel/arch/ia64/kernel/sal.c:				"vector 0x%lx\n", ap_wakeup_vector);
NeoLKernel/arch/ia64/kernel/sal.c:		printk(KERN_ERR "SAL: AP wakeup mechanism unsupported!\n");
NeoLKernel/arch/ia64/kernel/sal.c:static void __init sal_desc_ap_wakeup(void *p) { }
NeoLKernel/arch/ia64/kernel/sal.c:			sal_desc_ap_wakeup(p);
NeoLKernel/arch/ia64/kernel/salinfo.c: * outstanding events and wake up the user space code.
NeoLKernel/arch/ia64/kernel/salinfo.c:salinfo_log_wakeup(int type, u8 *buffer, u64 size, int irqsafe)
NeoLKernel/arch/ia64/kernel/smpboot.c:unsigned long ap_wakeup_vector = -1; /* External Int use to wakeup APs */
NeoLKernel/arch/ia64/kernel/smpboot.c:	Dprintk("Sending wakeup vector %lu to AP 0x%x/0x%x.\n", ap_wakeup_vector, cpu, sapicid);
NeoLKernel/arch/ia64/kernel/smpboot.c:	platform_send_ipi(cpu, ap_wakeup_vector, IA64_IPI_DM_INT, 0);
NeoLKernel/arch/ia64/kernel/mca.c:extern void salinfo_log_wakeup(int type, u8 *buffer, u64 size, int irqsafe);
NeoLKernel/arch/ia64/kernel/mca.c: *  and wakes up any processes waiting for error records.
NeoLKernel/arch/ia64/kernel/mca.c:	salinfo_log_wakeup(sal_info_type, buffer, size, irq_safe);
NeoLKernel/arch/ia64/kernel/mca.c: * ia64_mca_wakeup
NeoLKernel/arch/ia64/kernel/mca.c: *	Send an inter-cpu interrupt to wake-up a particular cpu.
NeoLKernel/arch/ia64/kernel/mca.c:ia64_mca_wakeup(int cpu)
NeoLKernel/arch/ia64/kernel/mca.c: * ia64_mca_wakeup_all
NeoLKernel/arch/ia64/kernel/mca.c:ia64_mca_wakeup_all(void)
NeoLKernel/arch/ia64/kernel/mca.c:			ia64_mca_wakeup(cpu);
NeoLKernel/arch/ia64/kernel/mca.c: *	wake each slave up once the monarch is done.  The state
NeoLKernel/arch/ia64/kernel/mca.c: * ia64_mca_wakeup_int_handler
NeoLKernel/arch/ia64/kernel/mca.c: *	polling on the wakeup-interrupt bit in the IRR, there is
NeoLKernel/arch/ia64/kernel/mca.c: *  Inputs  :   wakeup_irq  (Wakeup-interrupt bit)
NeoLKernel/arch/ia64/kernel/mca.c:ia64_mca_wakeup_int_handler(int wakeup_irq, void *arg)
NeoLKernel/arch/ia64/kernel/mca.c: *	Monarch also has the duty of sending wakeup-IPIs to pull the
NeoLKernel/arch/ia64/kernel/mca.c: *	will wake up the next cpu in the mca_cpu bitmask and then go
NeoLKernel/arch/ia64/kernel/mca.c:		ia64_mca_wakeup_all();
NeoLKernel/arch/ia64/kernel/mca.c:			cpu_relax();	/* spin until monarch wakes us */
NeoLKernel/arch/ia64/kernel/mca.c:		/* wake up the next monarch cpu,
NeoLKernel/arch/ia64/kernel/mca.c:				cpu_clear(i, mca_cpu);	/* wake next cpu */
NeoLKernel/arch/ia64/kernel/mca.c:	salinfo_log_wakeup(SAL_INFO_TYPE_INIT, NULL, 0, 0);
NeoLKernel/arch/ia64/kernel/mca.c:	.handler =	ia64_mca_wakeup_int_handler,
NeoLKernel/arch/ia64/kernel/mca.c: *	1. Register spinloop and wakeup request interrupt vectors
NeoLKernel/arch/ia64/kernel/mca.c:	 * Register the rendezvous spinloop and wakeup mechanism with SAL
NeoLKernel/arch/ia64/kernel/mca.c:	/* Register the wakeup interrupt vector with SAL */
NeoLKernel/arch/ia64/kernel/mca.c:		printk(KERN_ERR "Failed to register wakeup interrupt with SAL "
NeoLKernel/arch/ia64/kernel/mca.c:	IA64_MCA_DEBUG("%s: registered MCA rendezvous spinloop and wakeup mech.\n", __func__);
NeoLKernel/arch/ia64/kernel/mca.c:	/* Setup the MCA wakeup interrupt vector */
NeoLKernel/arch/ia64/kvm/kvm-ia64.c:			wake_up_interruptible(&target_vcpu->wq);
NeoLKernel/arch/ia64/kvm/kvm-ia64.c:			wake_up_interruptible(&vcpui->wq);
NeoLKernel/arch/ia64/kvm/kvm-ia64.c:		wake_up_interruptible(q);
NeoLKernel/arch/ia64/kvm/kvm-ia64.c:		wake_up_interruptible(&vcpu->wq);
NeoLKernel/arch/ia64/xen/irq_xen.c:	if (unlikely(vector == ap_wakeup_vector)) {
NeoLKernel/arch/m32r/kernel/ptrace.c:		wake_up_process(child);
NeoLKernel/arch/m32r/kernel/ptrace.c:		wake_up_process(child);
NeoLKernel/arch/m32r/kernel/ptrace.c:		wake_up_process(child);
NeoLKernel/arch/m68k/atari/atakeyb.c:				/* wake up someone waiting for this */
NeoLKernel/arch/m68k/atari/atakeyb.c:				/* wake up someone waiting for this.
NeoLKernel/arch/m68k/atari/atakeyb.c:				/* wake_up_interruptible(&clock_wait); */
NeoLKernel/arch/m68k/atari/stdma.c:/* put onto a queue and waked up later if the owner calls              */
NeoLKernel/arch/m68k/atari/stdma.c:	wake_up(&stdma_wait);
NeoLKernel/arch/m68k/kernel/ptrace.c:		wake_up_process(child);
NeoLKernel/arch/m68k/kernel/ptrace.c:		wake_up_process(child);
NeoLKernel/arch/m68k/kernel/ptrace.c:		wake_up_process(child);
NeoLKernel/arch/m68knommu/kernel/ptrace.c:			wake_up_process(child);
NeoLKernel/arch/m68knommu/kernel/ptrace.c:			wake_up_process(child);
NeoLKernel/arch/m68knommu/kernel/ptrace.c:			wake_up_process(child);
NeoLKernel/arch/microblaze/kernel/ptrace.c:		pr_debug("wakeup_process\n");
NeoLKernel/arch/microblaze/kernel/ptrace.c:		wake_up_process(child);
NeoLKernel/arch/microblaze/kernel/ptrace.c:		wake_up_process(child);
NeoLKernel/arch/mips/alchemy/common/irq.c:static unsigned int	sleep_intctl_wake[2];
NeoLKernel/arch/mips/alchemy/common/irq.c:	sleep_intctl_wake[0] = au_readl(IC0_WAKERD);
NeoLKernel/arch/mips/alchemy/common/irq.c:	sleep_intctl_wake[1] = au_readl(IC1_WAKERD);
NeoLKernel/arch/mips/alchemy/common/irq.c:	au_writel(sleep_intctl_wake[0], IC0_WAKESET); au_sync();
NeoLKernel/arch/mips/alchemy/common/irq.c:	au_writel(sleep_intctl_wake[1], IC1_WAKESET); au_sync();
NeoLKernel/arch/mips/alchemy/common/irq.c:static int au1x_ic1_setwake(unsigned int irq, unsigned int on)
NeoLKernel/arch/mips/alchemy/common/irq.c:	unsigned long wakemsk, flags;
NeoLKernel/arch/mips/alchemy/common/irq.c:	/* only GPIO 0-7 can act as wakeup source: */
NeoLKernel/arch/mips/alchemy/common/irq.c:	wakemsk = au_readl(SYS_WAKEMSK);
NeoLKernel/arch/mips/alchemy/common/irq.c:		wakemsk |= 1 << bit;
NeoLKernel/arch/mips/alchemy/common/irq.c:		wakemsk &= ~(1 << bit);
NeoLKernel/arch/mips/alchemy/common/irq.c:	au_writel(wakemsk, SYS_WAKEMSK);
NeoLKernel/arch/mips/alchemy/common/irq.c:	.set_wake	= au1x_ic1_setwake,
NeoLKernel/arch/mips/alchemy/common/sleeper.S: * A wakeup condition will get us back here to restore the registers.
NeoLKernel/arch/mips/alchemy/common/sleeper.S:	 * return to this point upon wakeup.
NeoLKernel/arch/mips/alchemy/common/sleeper.S:	/* This is where we return upon wakeup.
NeoLKernel/arch/mips/alchemy/devboards/pm.c: * can be used by userspace to en/disable all au1x-provided wakeup
NeoLKernel/arch/mips/alchemy/devboards/pm.c: * is to trigger a wakeup.
NeoLKernel/arch/mips/alchemy/devboards/pm.c:static unsigned long db1x_pm_wakemsk;
NeoLKernel/arch/mips/alchemy/devboards/pm.c:static unsigned long db1x_pm_last_wakesrc;
NeoLKernel/arch/mips/alchemy/devboards/pm.c:	/* enable GPIO based wakeup */
NeoLKernel/arch/mips/alchemy/devboards/pm.c:	/* clear and setup wake cause and source */
NeoLKernel/arch/mips/alchemy/devboards/pm.c:	au_writel(db1x_pm_wakemsk, SYS_WAKEMSK);
NeoLKernel/arch/mips/alchemy/devboards/pm.c:	/* setup 1Hz-timer-based wakeup: wait for reg access */
NeoLKernel/arch/mips/alchemy/devboards/pm.c:	if (!db1x_pm_wakemsk) {
NeoLKernel/arch/mips/alchemy/devboards/pm.c:		printk(KERN_ERR "db1x: no wakeup source activated!\n");
NeoLKernel/arch/mips/alchemy/devboards/pm.c:	/* read and store wakeup source, the clear the register. To
NeoLKernel/arch/mips/alchemy/devboards/pm.c:	db1x_pm_last_wakesrc = au_readl(SYS_WAKESRC);
NeoLKernel/arch/mips/alchemy/devboards/pm.c:				!!(db1x_pm_wakemsk & SYS_WAKEMSK_M2));
NeoLKernel/arch/mips/alchemy/devboards/pm.c:	else if (ATTRCMP(wakesrc))
NeoLKernel/arch/mips/alchemy/devboards/pm.c:		return sprintf(buf, "%lu\n", db1x_pm_last_wakesrc);
NeoLKernel/arch/mips/alchemy/devboards/pm.c:			!!(db1x_pm_wakemsk & SYS_WAKEMSK_GPIO(idx)));
NeoLKernel/arch/mips/alchemy/devboards/pm.c:	} else if (ATTRCMP(wakemsk)) {
NeoLKernel/arch/mips/alchemy/devboards/pm.c:		return sprintf(buf, "%08lx\n", db1x_pm_wakemsk);
NeoLKernel/arch/mips/alchemy/devboards/pm.c:			db1x_pm_wakemsk |= SYS_WAKEMSK_M2;
NeoLKernel/arch/mips/alchemy/devboards/pm.c:			db1x_pm_wakemsk &= ~SYS_WAKEMSK_M2;
NeoLKernel/arch/mips/alchemy/devboards/pm.c:			db1x_pm_wakemsk |= SYS_WAKEMSK_GPIO(tmp);
NeoLKernel/arch/mips/alchemy/devboards/pm.c:			db1x_pm_wakemsk &= ~SYS_WAKEMSK_GPIO(tmp);
NeoLKernel/arch/mips/alchemy/devboards/pm.c:	} else if (ATTRCMP(wakemsk)) {
NeoLKernel/arch/mips/alchemy/devboards/pm.c:		db1x_pm_wakemsk = l & 0x0000003f;
NeoLKernel/arch/mips/alchemy/devboards/pm.c:ATTR(gpio0)		/* GPIO-based wakeup enable */
NeoLKernel/arch/mips/alchemy/devboards/pm.c:ATTR(timer)		/* TOYMATCH2-based wakeup enable */
NeoLKernel/arch/mips/alchemy/devboards/pm.c:ATTR(timer_timeout)	/* timer-based wakeup timeout value, in seconds */
NeoLKernel/arch/mips/alchemy/devboards/pm.c:ATTR(wakesrc)		/* contents of SYS_WAKESRC after last wakeup */
NeoLKernel/arch/mips/alchemy/devboards/pm.c:ATTR(wakemsk)		/* direct access to SYS_WAKEMSK */
NeoLKernel/arch/mips/alchemy/devboards/pm.c:	ATTR_LIST(wakesrc),
NeoLKernel/arch/mips/alchemy/devboards/pm.c:	ATTR_LIST(wakemsk),
NeoLKernel/arch/mips/alchemy/devboards/pm.c:	db1x_pm_last_wakesrc = au_readl(SYS_WAKESRC);
NeoLKernel/arch/mips/basler/excite/excite_iodev.c:	wake_up(&wq);
NeoLKernel/arch/mips/include/asm/octeon/cvmx-npei-defs.h:		uint64_t c1_wake:1;
NeoLKernel/arch/mips/include/asm/octeon/cvmx-npei-defs.h:		uint64_t c0_wake:1;
NeoLKernel/arch/mips/include/asm/octeon/cvmx-npei-defs.h:		uint64_t c1_wake:1;
NeoLKernel/arch/mips/include/asm/octeon/cvmx-npei-defs.h:		uint64_t c0_wake:1;
NeoLKernel/arch/mips/include/asm/octeon/cvmx-npei-defs.h:		uint64_t c1_wake:1;
NeoLKernel/arch/mips/include/asm/octeon/cvmx-npei-defs.h:		uint64_t c0_wake:1;
NeoLKernel/arch/mips/include/asm/octeon/cvmx-npei-defs.h:		uint64_t c1_wake:1;
NeoLKernel/arch/mips/include/asm/octeon/cvmx-npei-defs.h:		uint64_t c0_wake:1;
NeoLKernel/arch/mips/include/asm/octeon/cvmx-npei-defs.h:		uint64_t c1_wake:1;
NeoLKernel/arch/mips/include/asm/octeon/cvmx-npei-defs.h:		uint64_t c0_wake:1;
NeoLKernel/arch/mips/include/asm/octeon/cvmx-npei-defs.h:		uint64_t c1_wake:1;
NeoLKernel/arch/mips/include/asm/octeon/cvmx-npei-defs.h:		uint64_t c0_wake:1;
NeoLKernel/arch/mips/include/asm/octeon/cvmx-npei-defs.h:		uint64_t c1_wake:1;
NeoLKernel/arch/mips/include/asm/octeon/cvmx-npei-defs.h:		uint64_t c0_wake:1;
NeoLKernel/arch/mips/include/asm/octeon/cvmx-npei-defs.h:		uint64_t c1_wake:1;
NeoLKernel/arch/mips/include/asm/octeon/cvmx-npei-defs.h:		uint64_t c0_wake:1;
NeoLKernel/arch/mips/include/asm/octeon/cvmx-npei-defs.h:		uint64_t c1_wake:1;
NeoLKernel/arch/mips/include/asm/octeon/cvmx-npei-defs.h:		uint64_t c0_wake:1;
NeoLKernel/arch/mips/include/asm/octeon/cvmx-npei-defs.h:		uint64_t c1_wake:1;
NeoLKernel/arch/mips/include/asm/octeon/cvmx-npei-defs.h:		uint64_t c0_wake:1;
NeoLKernel/arch/mips/include/asm/mach-au1x00/au1000.h:	/* 0x0034 */ u32 wakemsk;
NeoLKernel/arch/mips/include/asm/mach-au1x00/au1000.h:	/* 0x005C */ u32 wakesrc;
NeoLKernel/arch/mips/include/asm/mach-au1x00/gpio-au1000.h: * register enables use of GPIOs as wake source.
NeoLKernel/arch/mips/kernel/ptrace.c:		wake_up_process(child);
NeoLKernel/arch/mips/kernel/ptrace.c:		wake_up_process(child);
NeoLKernel/arch/mips/kernel/rtlx.c:			wake_up(&channel_wqs[i].lx_queue);
NeoLKernel/arch/mips/kernel/rtlx.c:			wake_up(&channel_wqs[i].rt_queue);
NeoLKernel/arch/mips/kernel/rtlx.c:	/* wake up any sleeping rtlx_open's */
NeoLKernel/arch/mips/kernel/rtlx.c:		wake_up_interruptible(&channel_wqs[i].lx_queue);
NeoLKernel/arch/mips/kernel/rtlx.c:		wake_up_interruptible(&channel_wqs[i].lx_queue);
NeoLKernel/arch/mips/sgi-ip32/ip32-reset.c:	/* setup for kickstart & wake-up (DS12287 Ref. Man. p. 19) */
NeoLKernel/arch/mips/sibyte/common/sb_tbprof.c:			wake_up_interruptible(&sbp.tb_sync);
NeoLKernel/arch/mips/sibyte/common/sb_tbprof.c:			wake_up_interruptible(&sbp.tb_sync);
NeoLKernel/arch/mips/sibyte/common/sb_tbprof.c:		wake_up_interruptible(&sbp.tb_read);
NeoLKernel/arch/mips/sibyte/common/sb_tbprof.c:		 * see the disable, and do the wake_up before this sleep
NeoLKernel/arch/mn10300/kernel/mn10300-serial.c:		uart_write_wakeup(&port->uart);
NeoLKernel/arch/mn10300/kernel/mn10300-serial.c:	wake_up_interruptible(&port->uart.state->port.delta_msr_wait);
NeoLKernel/arch/parisc/hpux/sys_hpux.c:	"mwakeup",               
NeoLKernel/arch/parisc/hpux/sys_hpux.c:	"kwakeup",               
NeoLKernel/arch/parisc/include/asm/unistd.h:#define __NR_HPUX_mwakeup               322
NeoLKernel/arch/parisc/include/asm/unistd.h:#define __NR_HPUX_kwakeup               399
NeoLKernel/arch/parisc/include/asm/unistd.h:#define __NR_HPUX_lf_wakeup_conn_q      468
NeoLKernel/arch/parisc/include/asm/pdcpat.h: *  			for wake up from Monarch Processor.
NeoLKernel/arch/parisc/kernel/ptrace.c:		/* Don't wake up the task, but let the
NeoLKernel/arch/powerpc/boot/dts/mpc8313erdb.dts:			fsl,mpc8313-wakeup-timer = <&gtm1>;
NeoLKernel/arch/powerpc/include/asm/pmac_feature.h: * Pass 0 to set IOs to wake
NeoLKernel/arch/powerpc/include/asm/pmac_feature.h: * wakeup from sleep
NeoLKernel/arch/powerpc/include/asm/kvm_host.h:	u32 halt_wakeup;
NeoLKernel/arch/powerpc/include/asm/smu.h:/* Power events wakeup bits */
NeoLKernel/arch/powerpc/include/asm/reg.h:#define   SRR1_WAKEMASK		0x00380000 /* reason for wakeup */
NeoLKernel/arch/powerpc/include/asm/rwsem.h:extern struct rw_semaphore *rwsem_wake(struct rw_semaphore *sem);
NeoLKernel/arch/powerpc/include/asm/rwsem.h:extern struct rw_semaphore *rwsem_downgrade_wake(struct rw_semaphore *sem);
NeoLKernel/arch/powerpc/include/asm/rwsem.h:		rwsem_wake(sem);
NeoLKernel/arch/powerpc/include/asm/rwsem.h:		rwsem_wake(sem);
NeoLKernel/arch/powerpc/include/asm/rwsem.h:		rwsem_downgrade_wake(sem);
NeoLKernel/arch/powerpc/include/asm/mpc52xx.h:extern int mpc52xx_set_wakeup_gpio(u8 pin, u8 level);
NeoLKernel/arch/powerpc/include/asm/time.h:extern void wakeup_decrementer(void);
NeoLKernel/arch/powerpc/include/asm/topology.h:	.wake_idx		= 0,			\
NeoLKernel/arch/powerpc/include/asm/uninorth.h: *  to do on a non-recoverable reset (powerup or wakeup)
NeoLKernel/arch/powerpc/kernel/prom_init.c:	 * will block when they are awakened from their OF spinloop.
NeoLKernel/arch/powerpc/kernel/prom_init.c:		 * the secondary cpu when it awakens from its OF
NeoLKernel/arch/powerpc/kernel/smp.c:	/* wake up cpus */
NeoLKernel/arch/powerpc/kernel/time.c:void wakeup_decrementer(void)
NeoLKernel/arch/powerpc/kernel/time.c:	 * The timebase gets saved on sleep and restored on wakeup,
NeoLKernel/arch/powerpc/kernel/time.c:	wakeup_decrementer();
NeoLKernel/arch/powerpc/kvm/booke.c:	{ "halt_wakeup", VCPU_STAT(halt_wakeup) },
NeoLKernel/arch/powerpc/kvm/powerpc.c:		wake_up_interruptible(&vcpu->wq);
NeoLKernel/arch/powerpc/kvm/powerpc.c:		vcpu->stat.halt_wakeup++;
NeoLKernel/arch/powerpc/kvm/powerpc.c:		wake_up_interruptible(&vcpu->wq);
NeoLKernel/arch/powerpc/kvm/powerpc.c:		vcpu->stat.halt_wakeup++;
NeoLKernel/arch/powerpc/platforms/52xx/efika.c:	u8 level = 1;	/* wakeup on high level */
NeoLKernel/arch/powerpc/platforms/52xx/efika.c:	/* IOW. to wake it up, short pins 1 and 3 on IRDA connector */
NeoLKernel/arch/powerpc/platforms/52xx/efika.c:	mpc52xx_set_wakeup_gpio(pin, level);
NeoLKernel/arch/powerpc/platforms/52xx/lite5200.c:	u8 level = 0;	/* wakeup on low level */
NeoLKernel/arch/powerpc/platforms/52xx/lite5200.c:	mpc52xx_set_wakeup_gpio(pin, level);
NeoLKernel/arch/powerpc/platforms/52xx/lite5200_pm.c:	wakeup_decrementer();
NeoLKernel/arch/powerpc/platforms/52xx/lite5200_sleep.S:	/* setup wakeup address for u-boot at physical location 0x0 */
NeoLKernel/arch/powerpc/platforms/52xx/lite5200_sleep.S:	lis	r4, lite5200_wakeup@h
NeoLKernel/arch/powerpc/platforms/52xx/lite5200_sleep.S:	ori	r4, r4, lite5200_wakeup@l
NeoLKernel/arch/powerpc/platforms/52xx/lite5200_sleep.S:	 *   possibly because BDI sets SDRAM registers before wakeup code does
NeoLKernel/arch/powerpc/platforms/52xx/lite5200_sleep.S:lite5200_wakeup:
NeoLKernel/arch/powerpc/platforms/52xx/mpc52xx_gpio.c: * GPIO LIB API implementation for wakeup GPIOs.
NeoLKernel/arch/powerpc/platforms/52xx/mpc52xx_gpio.c: * There's a maximum of 8 wakeup GPIOs. Which of these are available
NeoLKernel/arch/powerpc/platforms/52xx/mpc52xx_gpio.c:		printk(KERN_ERR "Unable to register wakeup GPIO driver\n");
NeoLKernel/arch/powerpc/platforms/52xx/mpc52xx_pic.c: * group has 3 irqs, External IRQ0, slice timer 0 irq, and wake from deep
NeoLKernel/arch/powerpc/platforms/52xx/mpc52xx_pm.c:int mpc52xx_set_wakeup_gpio(u8 pin, u8 level)
NeoLKernel/arch/powerpc/platforms/52xx/mpc52xx_pm.c:	/* low/high level creates wakeup interrupt */
NeoLKernel/arch/powerpc/platforms/52xx/mpc52xx_pm.c:		printk(KERN_ALERT "%s: %i don't know how to wake up the board\n",
NeoLKernel/arch/powerpc/platforms/52xx/mpc52xx_pm.c:	wakeup_decrementer();
NeoLKernel/arch/powerpc/platforms/52xx/mpc52xx_sleep.S:/* ### interrupt handler for wakeup from deep-sleep ### */
NeoLKernel/arch/powerpc/platforms/52xx/mpc52xx_sleep.S:	/* acknowledge wakeup, so CCS releases power pown */
NeoLKernel/arch/powerpc/platforms/83xx/suspend-asm.S:	/* Rev 1 of the 8313 has problems with wakeup events that are
NeoLKernel/arch/powerpc/platforms/83xx/suspend.c:static int is_pci_agent, wake_from_pci;
NeoLKernel/arch/powerpc/platforms/83xx/suspend.c:			wake_up(&agent_wq);
NeoLKernel/arch/powerpc/platforms/83xx/suspend.c:	if (wake_from_pci) {
NeoLKernel/arch/powerpc/platforms/83xx/suspend.c:	 * require going through the boot firmware upon a wakeup event.
NeoLKernel/arch/powerpc/platforms/83xx/suspend.c:		wake_from_pci = 1;
NeoLKernel/arch/powerpc/platforms/83xx/suspend.c:		wake_from_pci = 0;
NeoLKernel/arch/powerpc/platforms/cell/pervasive.c:	 * restored for us after wake-up.
NeoLKernel/arch/powerpc/platforms/cell/ras.c:	 * Enable System Error & thermal interrupts and wakeup conditions
NeoLKernel/arch/powerpc/platforms/cell/spufs/fault.c:		wake_up_all(&ctx->stop_wq);
NeoLKernel/arch/powerpc/platforms/cell/spufs/file.c:		spu_context_trace(spufs_ps_fault__wake, ctx, ctx->spu);
NeoLKernel/arch/powerpc/platforms/cell/spufs/file.c:	wake_up_all(&ctx->ibox_wq);
NeoLKernel/arch/powerpc/platforms/cell/spufs/file.c:	wake_up_all(&ctx->wbox_wq);
NeoLKernel/arch/powerpc/platforms/cell/spufs/file.c:	wake_up_all(&ctx->mfc_wq);
NeoLKernel/arch/powerpc/platforms/cell/spufs/file.c:	wake_up(&ctx->switch_log->wait);
NeoLKernel/arch/powerpc/platforms/cell/spufs/run.c:		wake_up_all(&ctx->stop_wq);
NeoLKernel/arch/powerpc/platforms/cell/spufs/sched.c:	 * When the awakened processes see their "notify_active" flag is set,
NeoLKernel/arch/powerpc/platforms/cell/spufs/sched.c:				wake_up_all(&ctx->stop_wq);
NeoLKernel/arch/powerpc/platforms/cell/spufs/sched.c:		wake_up_all(&ctx->stop_wq);
NeoLKernel/arch/powerpc/platforms/cell/spufs/sched.c:	 * Fortunately we need to wake up all these threads at the same time
NeoLKernel/arch/powerpc/platforms/cell/spufs/sched.c:		wake_up_all(&ctx->run_wq);
NeoLKernel/arch/powerpc/platforms/cell/spufs/sched.c:					wake_up(&new->stop_wq);
NeoLKernel/arch/powerpc/platforms/cell/spufs/sched.c:static void spusched_wake(unsigned long data)
NeoLKernel/arch/powerpc/platforms/cell/spufs/sched.c:	wake_up_process(spusched_task);
NeoLKernel/arch/powerpc/platforms/cell/spufs/sched.c:static void spuloadavg_wake(unsigned long data)
NeoLKernel/arch/powerpc/platforms/cell/spufs/sched.c:	setup_timer(&spusched_timer, spusched_wake, 0);
NeoLKernel/arch/powerpc/platforms/cell/spufs/sched.c:	setup_timer(&spuloadavg_timer, spuloadavg_wake, 0);
NeoLKernel/arch/powerpc/platforms/iseries/vio.c:		 * completion to wake up the guy who sent the request
NeoLKernel/arch/powerpc/platforms/powermac/cpufreq_32.c:	wakeup_decrementer();
NeoLKernel/arch/powerpc/platforms/powermac/cpufreq_32.c:	 * we have appropriate voltage and/or bus speed for the wakeup process,
NeoLKernel/arch/powerpc/platforms/powermac/cpufreq_32.c:	 * not cause too short delays if we sleep in low speed and wake in high
NeoLKernel/arch/powerpc/platforms/powermac/cpufreq_64.c:	 * might have to be called on init and/or wakeup, I'm not too sure
NeoLKernel/arch/powerpc/platforms/powermac/feature.c:static void heathrow_wakeup(struct macio_chip *macio, int secondary)
NeoLKernel/arch/powerpc/platforms/powermac/feature.c:		heathrow_wakeup(&macio_chips[0], 0);
NeoLKernel/arch/powerpc/platforms/powermac/feature.c:			heathrow_wakeup(&macio_chips[0], 1);
NeoLKernel/arch/powerpc/platforms/powermac/feature.c:core99_wake_up(void)
NeoLKernel/arch/powerpc/platforms/powermac/feature.c:		return core99_wake_up();
NeoLKernel/arch/powerpc/platforms/powermac/feature.c:generic_dev_can_wake(struct device_node *node, long param, long value)
NeoLKernel/arch/powerpc/platforms/powermac/feature.c:	{ PMAC_FTR_DEVICE_CAN_WAKE,	generic_dev_can_wake },
NeoLKernel/arch/powerpc/platforms/powermac/pfunc_base.c:	/* Note: We do not at this point implement the "at sleep" or "at wake"
NeoLKernel/arch/powerpc/platforms/powermac/sleep.S: * soon. We need to save all that is needed and setup the wakeup
NeoLKernel/arch/powerpc/platforms/powermac/sleep.S: * vector that will be called by the ROM on wakeup
NeoLKernel/arch/powerpc/platforms/powermac/sleep.S:	/* The ROM can wake us up via 2 different vectors:
NeoLKernel/arch/powerpc/platforms/powermac/sleep.S:	 *  - On Core99, we must store the wakeup vector at
NeoLKernel/arch/powerpc/platforms/powermac/sleep.S:	lis	r5,grackle_wake_up@ha
NeoLKernel/arch/powerpc/platforms/powermac/sleep.S:	addi	r5,r5,grackle_wake_up@l
NeoLKernel/arch/powerpc/platforms/powermac/sleep.S:	lis	r3,core99_wake_up@ha
NeoLKernel/arch/powerpc/platforms/powermac/sleep.S:	addi	r3,r3,core99_wake_up@l
NeoLKernel/arch/powerpc/platforms/powermac/sleep.S: * wakeup so that the host bridge properly stays asleep. The
NeoLKernel/arch/powerpc/platforms/powermac/sleep.S:_GLOBAL(core99_wake_up)
NeoLKernel/arch/powerpc/platforms/powermac/sleep.S:grackle_wake_up:
NeoLKernel/arch/powerpc/platforms/ps3/setup.c:	 * flags: 0 = wake on DEC interrupt, 1 = ignore DEC interrupt.
NeoLKernel/arch/powerpc/platforms/pseries/rtasd.c:		wake_up_interruptible(&rtas_log_wait);
NeoLKernel/arch/s390/include/asm/rwsem.h:extern struct rw_semaphore *rwsem_wake(struct rw_semaphore *);
NeoLKernel/arch/s390/include/asm/rwsem.h:extern struct rw_semaphore *rwsem_downgrade_wake(struct rw_semaphore *);
NeoLKernel/arch/s390/include/asm/rwsem.h:			rwsem_wake(sem);
NeoLKernel/arch/s390/include/asm/rwsem.h:			rwsem_wake(sem);
NeoLKernel/arch/s390/include/asm/rwsem.h:		rwsem_downgrade_wake(sem);
NeoLKernel/arch/s390/kvm/interrupt.c:		wake_up_interruptible(&vcpu->arch.local_int.wq);
NeoLKernel/arch/s390/kvm/interrupt.c: * low level hrtimer wake routine. Because this runs in hardirq context
NeoLKernel/arch/s390/kvm/interrupt.c:enum hrtimer_restart kvm_s390_idle_wakeup(struct hrtimer *timer)
NeoLKernel/arch/s390/kvm/interrupt.c:		wake_up_interruptible(&li->wq);
NeoLKernel/arch/s390/kvm/interrupt.c:		wake_up_interruptible(&vcpu->arch.local_int.wq);
NeoLKernel/arch/s390/kvm/kvm-s390.c:	vcpu->arch.ckc_timer.function = kvm_s390_idle_wakeup;
NeoLKernel/arch/s390/kvm/kvm-s390.h:enum hrtimer_restart kvm_s390_idle_wakeup(struct hrtimer *timer);
NeoLKernel/arch/s390/kvm/sigp.c:		wake_up_interruptible(&li->wq);
NeoLKernel/arch/s390/kvm/sigp.c:		wake_up_interruptible(&li->wq);
NeoLKernel/arch/s390/kvm/sigp.c:		wake_up_interruptible(&li->wq);
NeoLKernel/arch/s390/mm/cmm.c:	wake_up(&cmm_thread_wait);
NeoLKernel/arch/s390/mm/fault.c:			 * back to zero and wake up the process. This can
NeoLKernel/arch/s390/mm/fault.c:			wake_up_process(tsk);
NeoLKernel/arch/sh/boards/mach-hp6xx/Makefile:obj-$(CONFIG_PM)	+= pm.o pm_wakeup.o
NeoLKernel/arch/sh/boards/mach-hp6xx/pm.c:extern u8 wakeup_start;
NeoLKernel/arch/sh/boards/mach-hp6xx/pm.c:extern u8 wakeup_end;
NeoLKernel/arch/sh/boards/mach-hp6xx/pm.c:	       &wakeup_start, &wakeup_end - &wakeup_start);
NeoLKernel/arch/sh/boards/mach-hp6xx/pm_wakeup.S:ENTRY(wakeup_start)
NeoLKernel/arch/sh/boards/mach-hp6xx/pm_wakeup.S:ENTRY(wakeup_end)
NeoLKernel/arch/sh/boards/mach-se/7343/setup.c:	.remote_wakeup_enable	= 0,
NeoLKernel/arch/sh/drivers/dma/dma-g2.c:				wake_up(&chan->wait_queue);
NeoLKernel/arch/sh/drivers/dma/dma-sh.c: * Besides that it needs to waken any waiting process, which should handle
NeoLKernel/arch/sh/drivers/dma/dma-sh.c:	wake_up(&chan->wait_queue);
NeoLKernel/arch/sh/include/asm/rwsem.h:extern struct rw_semaphore *rwsem_wake(struct rw_semaphore *sem);
NeoLKernel/arch/sh/include/asm/rwsem.h:extern struct rw_semaphore *rwsem_downgrade_wake(struct rw_semaphore *sem);
NeoLKernel/arch/sh/include/asm/rwsem.h:		rwsem_wake(sem);
NeoLKernel/arch/sh/include/asm/rwsem.h:		rwsem_wake(sem);
NeoLKernel/arch/sh/include/asm/rwsem.h:		rwsem_downgrade_wake(sem);
NeoLKernel/arch/sh/include/asm/topology.h:	.wake_idx		= 0,			\
NeoLKernel/arch/sh/include/asm/ubc.h:extern void ubc_wakeup(void);
NeoLKernel/arch/sh/include/asm/ubc.h:#define ubc_wakeup()	do { } while (0)
NeoLKernel/arch/sh/Kconfig:	  Selecting this option will wakeup the User Break Controller (UBC) on
NeoLKernel/arch/sh/Kconfig:	  startup. Although the UBC is left in an awake state when the processor
NeoLKernel/arch/sh/kernel/cpu/init.c:	 * we wake it up and hope that all is well.
NeoLKernel/arch/sh/kernel/cpu/init.c:		ubc_wakeup();
NeoLKernel/arch/sh/kernel/cpu/ubc.S:ENTRY(ubc_wakeup)
NeoLKernel/arch/sh/kernel/process_64.c:	panic("Unexpected wakeup!\n");
NeoLKernel/arch/sparc/include/asm/oplib_64.h:/* Initiate a wakeup event. */
NeoLKernel/arch/sparc/include/asm/oplib_64.h:extern int prom_wakeupsystem(void);
NeoLKernel/arch/sparc/include/asm/system_64.h: * The offending sequence was the following in sym_wakeup_done() of the
NeoLKernel/arch/sparc/include/asm/fhc.h:#define  FHC_RCS_WEVENT		0x04000000 /* CPU reset was due to wakeup event	*/
NeoLKernel/arch/sparc/include/asm/topology_64.h:	.wake_idx		= 0,			\
NeoLKernel/arch/sparc/kernel/ds.c:		wake_up(&ds_wait);
NeoLKernel/arch/sparc/kernel/pcr.c: * Therefore we can't do things like wakeups and other work
NeoLKernel/arch/sparc/lib/rwsem_32.S:	call		__rwsem_wake
NeoLKernel/arch/sparc/lib/rwsem_32.S:	call		__rwsem_wake
NeoLKernel/arch/sparc/lib/rwsem_64.S:	call		rwsem_wake
NeoLKernel/arch/sparc/lib/rwsem_64.S:	call		rwsem_wake
NeoLKernel/arch/sparc/lib/rwsem_64.S:	call		rwsem_downgrade_wake
NeoLKernel/arch/sparc/prom/misc_64.c:int prom_wakeupsystem(void)
NeoLKernel/arch/sparc/prom/misc_64.c:	return p1275_cmd("SUNW,wakeup-system", P1275_INOUT(0, 1));
NeoLKernel/arch/um/drivers/line.c:	tty_wakeup(tty);
NeoLKernel/arch/um/drivers/net_kern.c:		netif_wake_queue(dev);
NeoLKernel/arch/um/drivers/net_kern.c:	netif_wake_queue(dev);
NeoLKernel/arch/um/drivers/random.c:	wake_up(&host_read_wait);
NeoLKernel/arch/um/kernel/ptrace.c:		wake_up_process(child);
NeoLKernel/arch/um/kernel/ptrace.c:		wake_up_process(child);
NeoLKernel/arch/um/kernel/ptrace.c:		wake_up_process(child);
NeoLKernel/arch/x86/boot/video-mode.c: * file in order to be shared with the ACPI wakeup code.
NeoLKernel/arch/x86/include/asm/acpi.h:extern unsigned long acpi_wakeup_address;
NeoLKernel/arch/x86/include/asm/apic.h:	/* wakeup_secondary_cpu */
NeoLKernel/arch/x86/include/asm/apic.h:	int (*wakeup_secondary_cpu)(int apicid, unsigned long start_eip);
NeoLKernel/arch/x86/include/asm/apic.h:extern int wakeup_secondary_cpu_via_nmi(int apicid, unsigned long start_eip);
NeoLKernel/arch/x86/include/asm/kvm_host.h:	u32 halt_wakeup;
NeoLKernel/arch/x86/include/asm/suspend_64.h: * If you modify it, fix arch/x86/kernel/acpi/wakeup_64.S and make sure that
NeoLKernel/arch/x86/include/asm/topology.h:	.wake_idx		= 0,					\
NeoLKernel/arch/x86/include/asm/rwsem.h: rwsem_wake(struct rw_semaphore *);
NeoLKernel/arch/x86/include/asm/rwsem.h: rwsem_downgrade_wake(struct rw_semaphore *sem);
NeoLKernel/arch/x86/include/asm/rwsem.h:		     "  call call_rwsem_wake\n"
NeoLKernel/arch/x86/include/asm/rwsem.h:		     "  call call_rwsem_wake\n"
NeoLKernel/arch/x86/include/asm/rwsem.h:		     "  call call_rwsem_downgrade_wake\n"
NeoLKernel/arch/x86/kernel/acpi/Makefile:obj-$(CONFIG_ACPI_SLEEP)	+= sleep.o wakeup_rm.o wakeup_$(BITS).o
NeoLKernel/arch/x86/kernel/acpi/Makefile:$(obj)/wakeup_rm.o:    $(obj)/realmode/wakeup.bin
NeoLKernel/arch/x86/kernel/acpi/Makefile:$(obj)/realmode/wakeup.bin: FORCE
NeoLKernel/arch/x86/kernel/acpi/realmode/Makefile:always		:= wakeup.bin
NeoLKernel/arch/x86/kernel/acpi/realmode/Makefile:targets		:= wakeup.elf wakeup.lds
NeoLKernel/arch/x86/kernel/acpi/realmode/Makefile:wakeup-y	+= wakeup.o wakemain.o video-mode.o copy.o bioscall.o regs.o
NeoLKernel/arch/x86/kernel/acpi/realmode/Makefile:wakeup-y	+= video-vga.o
NeoLKernel/arch/x86/kernel/acpi/realmode/Makefile:wakeup-y	+= video-vesa.o
NeoLKernel/arch/x86/kernel/acpi/realmode/Makefile:wakeup-y	+= video-bios.o
NeoLKernel/arch/x86/kernel/acpi/realmode/Makefile:targets		+= $(wakeup-y)
NeoLKernel/arch/x86/kernel/acpi/realmode/Makefile:WAKEUP_OBJS = $(addprefix $(obj)/,$(wakeup-y))
NeoLKernel/arch/x86/kernel/acpi/realmode/Makefile:LDFLAGS_wakeup.elf	:= -T
NeoLKernel/arch/x86/kernel/acpi/realmode/Makefile:CPPFLAGS_wakeup.lds += -P -C
NeoLKernel/arch/x86/kernel/acpi/realmode/Makefile:$(obj)/wakeup.elf: $(obj)/wakeup.lds $(WAKEUP_OBJS) FORCE
NeoLKernel/arch/x86/kernel/acpi/realmode/Makefile:OBJCOPYFLAGS_wakeup.bin	:= -O binary
NeoLKernel/arch/x86/kernel/acpi/realmode/Makefile:$(obj)/wakeup.bin: $(obj)/wakeup.elf FORCE
NeoLKernel/arch/x86/kernel/acpi/realmode/wakemain.c:#include "wakeup.h"
NeoLKernel/arch/x86/kernel/acpi/realmode/wakemain.c:	if (wakeup_header.real_magic != 0x12345678)
NeoLKernel/arch/x86/kernel/acpi/realmode/wakemain.c:	if (wakeup_header.realmode_flags & 4)
NeoLKernel/arch/x86/kernel/acpi/realmode/wakemain.c:	if (wakeup_header.realmode_flags & 1)
NeoLKernel/arch/x86/kernel/acpi/realmode/wakemain.c:	if (wakeup_header.realmode_flags & 2) {
NeoLKernel/arch/x86/kernel/acpi/realmode/wakemain.c:		set_mode(wakeup_header.video_mode);
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.h: * Definitions for the wakeup data structure at the head of the
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.h: * wakeup code.
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.h:/* This must match data at wakeup.S */
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.h:struct wakeup_header {
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.h:	u8  wakeup_jmp;
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.h:	u16 wakeup_jmp_off;
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.h:	u16 wakeup_jmp_seg;
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.h:	u64 wakeup_gdt[3];
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.h:extern struct wakeup_header wakeup_header;
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.lds.S: * wakeup.ld
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.lds.S: * Linker script for the real-mode wakeup code
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.lds.S:#include "wakeup.h"
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.S: * ACPI wakeup real mode startup stub
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.S:/* This should match the structure in wakeup.h */
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.S:		.globl	wakeup_header
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.S:wakeup_header:
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.S:wakeup_jmp:	.byte	0xea	/* ljmpw */
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.S:wakeup_jmp_off:	.word	3f
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.S:wakeup_jmp_seg:	.word	0
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.S:wakeup_gdt:	.quad	0, 0, 0
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.S:wakeup_code:
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.S:	lgdtl	%cs:wakeup_gdt
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.S:	jmp	wakeup_jmp
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.S:	lidtl	wakeup_idt
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.S:	movl	$wakeup_stack_end, %esp
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.S:wakeup_idt:
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.S:	.long	wakeup_heap
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.S:	.long	wakeup_stack
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.S:wakeup_heap:
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.S:wakeup_stack:
NeoLKernel/arch/x86/kernel/acpi/realmode/wakeup.S:wakeup_stack_end:
NeoLKernel/arch/x86/kernel/acpi/sleep.c:#include "realmode/wakeup.h"
NeoLKernel/arch/x86/kernel/acpi/sleep.c:unsigned long acpi_wakeup_address;
NeoLKernel/arch/x86/kernel/acpi/sleep.c:/* address in low memory of the wakeup routine. */
NeoLKernel/arch/x86/kernel/acpi/sleep.c: * Create an identity mapped page table and copy the wakeup routine to
NeoLKernel/arch/x86/kernel/acpi/sleep.c: * Note that this is too late to change acpi_wakeup_address.
NeoLKernel/arch/x86/kernel/acpi/sleep.c:	struct wakeup_header *header;
NeoLKernel/arch/x86/kernel/acpi/sleep.c:	memcpy((void *)acpi_realmode, &wakeup_code_start, WAKEUP_SIZE);
NeoLKernel/arch/x86/kernel/acpi/sleep.c:	header = (struct wakeup_header *)(acpi_realmode + HEADER_OFFSET);
NeoLKernel/arch/x86/kernel/acpi/sleep.c:		printk(KERN_ERR "wakeup header does not match\n");
NeoLKernel/arch/x86/kernel/acpi/sleep.c:	header->wakeup_jmp_seg = acpi_wakeup_address >> 4;
NeoLKernel/arch/x86/kernel/acpi/sleep.c:	 * Set up the wakeup GDT.  We set these up as Big Real Mode,
NeoLKernel/arch/x86/kernel/acpi/sleep.c:	header->wakeup_gdt[0] =
NeoLKernel/arch/x86/kernel/acpi/sleep.c:		(u64)(sizeof(header->wakeup_gdt) - 1) +
NeoLKernel/arch/x86/kernel/acpi/sleep.c:		((u64)(acpi_wakeup_address +
NeoLKernel/arch/x86/kernel/acpi/sleep.c:			((char *)&header->wakeup_gdt - (char *)acpi_realmode))
NeoLKernel/arch/x86/kernel/acpi/sleep.c:	header->wakeup_gdt[1] =
NeoLKernel/arch/x86/kernel/acpi/sleep.c:		GDT_ENTRY(0x809b, acpi_wakeup_address, 0xfffff);
NeoLKernel/arch/x86/kernel/acpi/sleep.c:	header->wakeup_gdt[2] =
NeoLKernel/arch/x86/kernel/acpi/sleep.c:		GDT_ENTRY(0x8093, acpi_wakeup_address, 0xfffff);
NeoLKernel/arch/x86/kernel/acpi/sleep.c:	header->pmode_entry = (u32)&wakeup_pmode_return;
NeoLKernel/arch/x86/kernel/acpi/sleep.c:	initial_code = (unsigned long)wakeup_long64;
NeoLKernel/arch/x86/kernel/acpi/sleep.c: * We allocate a page from the first 1MB of memory for the wakeup
NeoLKernel/arch/x86/kernel/acpi/sleep.c:	if ((&wakeup_code_end - &wakeup_code_start) > WAKEUP_SIZE) {
NeoLKernel/arch/x86/kernel/acpi/sleep.c:	acpi_wakeup_address = virt_to_phys((void *)acpi_realmode);
NeoLKernel/arch/x86/kernel/acpi/sleep.h:extern char wakeup_code_start, wakeup_code_end;
NeoLKernel/arch/x86/kernel/acpi/sleep.h:extern int wakeup_pmode_return;
NeoLKernel/arch/x86/kernel/acpi/sleep.h:extern unsigned long acpi_copy_wakeup_routine(unsigned long);
NeoLKernel/arch/x86/kernel/acpi/sleep.h:extern void wakeup_long64(void);
NeoLKernel/arch/x86/kernel/acpi/wakeup_32.S:ENTRY(wakeup_pmode_return)
NeoLKernel/arch/x86/kernel/acpi/wakeup_32.S:wakeup_pmode_return:
NeoLKernel/arch/x86/kernel/acpi/wakeup_64.S:ENTRY(wakeup_long64)
NeoLKernel/arch/x86/kernel/acpi/wakeup_64.S:ENDPROC(wakeup_long64)
NeoLKernel/arch/x86/kernel/acpi/wakeup_rm.S:	.globl	wakeup_code_start, wakeup_code_end
NeoLKernel/arch/x86/kernel/acpi/wakeup_rm.S:wakeup_code_start:
NeoLKernel/arch/x86/kernel/acpi/wakeup_rm.S:	.incbin	"arch/x86/kernel/acpi/realmode/wakeup.bin"
NeoLKernel/arch/x86/kernel/acpi/wakeup_rm.S:wakeup_code_end:
NeoLKernel/arch/x86/kernel/acpi/wakeup_rm.S:	.size	wakeup_code_start, .-wakeup_code_start
NeoLKernel/arch/x86/kernel/apic/es7000_32.c:static int __cpuinit wakeup_secondary_cpu_via_mip(int cpu, unsigned long eip)
NeoLKernel/arch/x86/kernel/apic/es7000_32.c:	.wakeup_secondary_cpu		= wakeup_secondary_cpu_via_mip,
NeoLKernel/arch/x86/kernel/apic/numaq_32.c:	.wakeup_secondary_cpu		= wakeup_secondary_cpu_via_nmi,
NeoLKernel/arch/x86/kernel/apic/x2apic_uv_x.c:static int __cpuinit uv_wakeup_secondary(int phys_apicid, unsigned long start_rip)
NeoLKernel/arch/x86/kernel/apic/x2apic_uv_x.c:	.wakeup_secondary_cpu		= uv_wakeup_secondary,
NeoLKernel/arch/x86/kernel/apm_32.c:	wake_up_interruptible(&apm_waitqueue);
NeoLKernel/arch/x86/kernel/apm_32.c:	wake_up_interruptible(&apm_suspend_waitqueue);
NeoLKernel/arch/x86/kernel/apm_32.c:	wake_up_process(kapmd_task);
NeoLKernel/arch/x86/kernel/cpu/cpufreq/longhaul.c:			/* Don't allow wakeup */
NeoLKernel/arch/x86/kernel/cpu/cpufreq/powernow-k7.c: *  CPU with half frequency multipliers may hang upon wakeup from disconnect.
NeoLKernel/arch/x86/kernel/cpu/mcheck/mce.c:		wake_up_interruptible(&mce_wait);
NeoLKernel/arch/x86/kernel/efi.c:static efi_status_t virt_efi_get_wakeup_time(efi_bool_t *enabled,
NeoLKernel/arch/x86/kernel/efi.c:	return efi_call_virt3(get_wakeup_time,
NeoLKernel/arch/x86/kernel/efi.c:static efi_status_t virt_efi_set_wakeup_time(efi_bool_t enabled, efi_time_t *tm)
NeoLKernel/arch/x86/kernel/efi.c:	return efi_call_virt2(set_wakeup_time,
NeoLKernel/arch/x86/kernel/efi.c:	efi.get_wakeup_time = virt_efi_get_wakeup_time;
NeoLKernel/arch/x86/kernel/efi.c:	efi.set_wakeup_time = virt_efi_set_wakeup_time;
NeoLKernel/arch/x86/kernel/process_32.c:	/* never put a printk in __switch_to... printk() calls wake_up*() indirectly */
NeoLKernel/arch/x86/kernel/smpboot.c:	 * If waken up by an INIT in an 82489DX configuration
NeoLKernel/arch/x86/kernel/smpboot.c: * Poke the other CPU in the eye via NMI to wake it up. Remember that the normal
NeoLKernel/arch/x86/kernel/smpboot.c:wakeup_secondary_cpu_via_nmi(int logical_apicid, unsigned long start_eip)
NeoLKernel/arch/x86/kernel/smpboot.c:wakeup_secondary_cpu_via_init(int phys_apicid, unsigned long start_eip)
NeoLKernel/arch/x86/kernel/smpboot.c: * ->wakeup_secondary_cpu.
NeoLKernel/arch/x86/kernel/smpboot.c:	if (apic->wakeup_secondary_cpu)
NeoLKernel/arch/x86/kernel/smpboot.c:		boot_error = apic->wakeup_secondary_cpu(apicid, start_ip);
NeoLKernel/arch/x86/kernel/smpboot.c:		boot_error = wakeup_secondary_cpu_via_init(apicid, start_ip);
NeoLKernel/arch/x86/kernel/tboot.c:#include "acpi/realmode/wakeup.h"
NeoLKernel/arch/x86/kernel/tboot.c:	add_mac_region(acpi_wakeup_address, WAKEUP_SIZE);
NeoLKernel/arch/x86/kernel/tboot.c:	tboot->acpi_sinfo.kernel_s3_resume_vector = acpi_wakeup_address;
NeoLKernel/arch/x86/kernel/tboot.c:	tboot->acpi_sinfo.wakeup_vector = fadt->facs +
NeoLKernel/arch/x86/kernel/tboot.c:	/* we always use the 32b wakeup vector */
NeoLKernel/arch/x86/kernel/tboot.c:	u32               rlp_wakeup_addr;
NeoLKernel/arch/x86/kernel/tsc.c:	sched_clock_idle_wakeup_event(0);
NeoLKernel/arch/x86/kernel/verify_cpu_64.S: *	arch/x86_64/kernel/acpi/wakeup.S:Verfication at resume (16bit)
NeoLKernel/arch/x86/kernel/irqinit.c:	 * IPI, driven by wakeup.
NeoLKernel/arch/x86/kvm/timer.c:		wake_up_interruptible(q);
NeoLKernel/arch/x86/kvm/x86.c:	{ "halt_wakeup", VCPU_STAT(halt_wakeup) },
NeoLKernel/arch/x86/kvm/x86.c:		wake_up_interruptible(&vcpu->wq);
NeoLKernel/arch/x86/kvm/x86.c:		++vcpu->stat.halt_wakeup;
NeoLKernel/arch/x86/lguest/boot.c:	/* Please wake us this far in the future. */
NeoLKernel/arch/x86/lib/semaphore_32.S:ENTRY(call_rwsem_wake)
NeoLKernel/arch/x86/lib/semaphore_32.S:	call rwsem_wake
NeoLKernel/arch/x86/lib/semaphore_32.S:	ENDPROC(call_rwsem_wake)
NeoLKernel/arch/x86/lib/semaphore_32.S:ENTRY(call_rwsem_downgrade_wake)
NeoLKernel/arch/x86/lib/semaphore_32.S:	call rwsem_downgrade_wake
NeoLKernel/arch/x86/lib/semaphore_32.S:	ENDPROC(call_rwsem_downgrade_wake)
NeoLKernel/arch/x86/lib/thunk_64.S:	thunk rwsem_wake_thunk,rwsem_wake
NeoLKernel/arch/x86/lib/thunk_64.S:	thunk rwsem_downgrade_thunk,rwsem_downgrade_wake
NeoLKernel/arch/x86/mm/kmemcheck/error.c:static void do_wakeup(unsigned long data)
NeoLKernel/arch/x86/mm/kmemcheck/error.c:static DECLARE_TASKLET(kmemcheck_tasklet, &do_wakeup, 0);
NeoLKernel/arch/x86/mm/pageattr-test.c:		wake_up_process(p);
NeoLKernel/arch/x86/xen/spinlock.c:	} while (!xen_test_irq_pending(irq)); /* check for spurious wakeups */
NeoLKernel/arch/xtensa/include/asm/rwsem.h:extern struct rw_semaphore *rwsem_wake(struct rw_semaphore *sem);
NeoLKernel/arch/xtensa/include/asm/rwsem.h:extern struct rw_semaphore *rwsem_downgrade_wake(struct rw_semaphore *sem);
NeoLKernel/arch/xtensa/include/asm/rwsem.h:		rwsem_wake(sem);
NeoLKernel/arch/xtensa/include/asm/rwsem.h:		rwsem_wake(sem);
NeoLKernel/arch/xtensa/include/asm/rwsem.h:		rwsem_downgrade_wake(sem);
NeoLKernel/arch/xtensa/kernel/ptrace.c:		wake_up_process(child);
NeoLKernel/arch/xtensa/kernel/ptrace.c:		wake_up_process(child);
NeoLKernel/arch/xtensa/kernel/ptrace.c:		wake_up_process(child);
NeoLKernel/arch/xtensa/platforms/iss/network.c:		netif_wake_queue(dev);
NeoLKernel/arch/xtensa/platforms/iss/network.c:	netif_wake_queue(dev);
NeoLKernel/block/as-iosched.c: * are timing from when the candidate process wakes up hopefully.
NeoLKernel/block/bfq-ioc.c: * the module is exiting wake up anyone waiting for its deallocation
NeoLKernel/block/blk-core.c:	 * lose wakeups.
NeoLKernel/block/blk-core.c: * is the behaviour we want though - once it gets a wakeup it should be given
NeoLKernel/block/blk-core.c:			wake_up(&rl->wait[sync]);
NeoLKernel/block/blk-core.c: * congestion status, wake up any waiters.   Called under q->queue_lock.
NeoLKernel/block/bsg.c:	wake_up(&bd->wq_free);
NeoLKernel/block/bsg.c:	wake_up(&bd->wq_done);
NeoLKernel/block/blk-sysfs.c:		wake_up(&rl->wait[BLK_RW_SYNC]);
NeoLKernel/block/blk-sysfs.c:		wake_up(&rl->wait[BLK_RW_ASYNC]);
NeoLKernel/Documentation/ABI/testing/sysfs-bus-usb:		in response to I/O requests.  However remote-wakeup requests
NeoLKernel/Documentation/ABI/testing/sysfs-bus-usb:		from the device may still be enabled (the remote-wakeup
NeoLKernel/Documentation/ABI/testing/sysfs-bus-usb:		setting is controlled separately by the power/wakeup
NeoLKernel/Documentation/ABI/testing/sysfs-bus-usb:		free to wake up in response to I/O requests, you should
NeoLKernel/Documentation/ABI/testing/sysfs-devices-system-cpu:		2 - Also bias task wakeups to semi-idle cpu package for power
NeoLKernel/Documentation/arm/msm/tsif.txt:To achieve this, driver holds wake lock.
NeoLKernel/Documentation/arm/OMAP/omap_pm:1. Set the maximum MPU wakeup latency:
NeoLKernel/Documentation/arm/OMAP/omap_pm:   (*pdata->set_max_mpu_wakeup_lat)(struct device *dev, unsigned long t)
NeoLKernel/Documentation/arm/OMAP/omap_pm:2. Set the maximum device wakeup latency:
NeoLKernel/Documentation/arm/OMAP/omap_pm:   (*pdata->set_max_dev_wakeup_lat)(struct device *dev, unsigned long t)
NeoLKernel/Documentation/arm/OMAP/omap_pm:.set_max_dev_wakeup_lat will point to
NeoLKernel/Documentation/arm/OMAP/omap_pm:omap_pm_set_max_dev_wakeup_lat(), etc.  Other architectures which do
NeoLKernel/Documentation/arm/OMAP/omap_pm:        if (pdata->set_max_dev_wakeup_lat)
NeoLKernel/Documentation/arm/OMAP/omap_pm:            (*pdata->set_max_dev_wakeup_lat)(dev, t);
NeoLKernel/Documentation/arm/OMAP/omap_pm:set_max_mpu_wakeup_lat() function to to constrain the MPU wakeup
NeoLKernel/Documentation/arm/OMAP/omap_pm:latency, and the set_max_dev_wakeup_lat() function to constrain the
NeoLKernel/Documentation/arm/OMAP/omap_pm:device wakeup latency (from clk_enable() to accessibility).  For
NeoLKernel/Documentation/arm/OMAP/omap_pm:        /* Limit MPU wakeup latency */
NeoLKernel/Documentation/arm/OMAP/omap_pm:        if (pdata->set_max_mpu_wakeup_lat)
NeoLKernel/Documentation/arm/OMAP/omap_pm:            (*pdata->set_max_mpu_wakeup_lat)(dev, tc);
NeoLKernel/Documentation/arm/OMAP/omap_pm:        /* Limit device powerdomain wakeup latency */
NeoLKernel/Documentation/arm/OMAP/omap_pm:        if (pdata->set_max_dev_wakeup_lat)
NeoLKernel/Documentation/arm/OMAP/omap_pm:            (*pdata->set_max_dev_wakeup_lat)(dev, td);
NeoLKernel/Documentation/arm/OMAP/omap_pm:        /* total wakeup latency in this example: (tc + td) */
NeoLKernel/Documentation/arm/pxa/mfp.txt:     wakeup from GPIO(s) any more, depending on the sleeping state, ADxER
NeoLKernel/Documentation/arm/pxa/mfp.txt:     (as defined in pxa3xx-regs.h) controls the wakeup from MFP
NeoLKernel/Documentation/arm/pxa/mfp.txt:   c) if by board design, a pin can be configured to wake up the system
NeoLKernel/Documentation/arm/pxa/mfp.txt:   to indicate that this pin has the capability of wake-up the system,
NeoLKernel/Documentation/arm/pxa/mfp.txt:   pin _will_ wakeup the system, it will only when set_irq_wake() is
NeoLKernel/Documentation/arm/pxa/mfp.txt:   and eventually calls gpio_set_wake() for the actual register setting.
NeoLKernel/Documentation/arm/pxa/mfp.txt:   internal logic will only wakeup the system when those specific bits
NeoLKernel/Documentation/arm/pxa/mfp.txt:   corresponding peripheral, thus set_irq_wake() can be called with 
NeoLKernel/Documentation/arm/pxa/mfp.txt:   the peripheral IRQ to enable the wakeup.
NeoLKernel/Documentation/arm/Samsung-S3C24XX/Suspend.txt:  The following is an example of code used for testing wakeup from
NeoLKernel/Documentation/arm/Samsung-S3C24XX/Suspend.txt:	enable_irq_wake(IRQ_EINT0);
NeoLKernel/Documentation/btmrvl.txt:	where GPIO is the pin number of GPIO used to wake up the host.
NeoLKernel/Documentation/btmrvl.txt:	wakeup will be used instead).
NeoLKernel/Documentation/btmrvl.txt:	where Gap is the gap in milli seconds between wakeup signal and
NeoLKernel/Documentation/btmrvl.txt:	wakeup event, or 0xff for special host sleep setting.
NeoLKernel/Documentation/btmrvl.txt:		# Use SDIO interface to wake up the host and set GAP to 0x80:
NeoLKernel/Documentation/btmrvl.txt:		# Use GPIO pin #3 to wake up the host and set GAP to 0xff:
NeoLKernel/Documentation/btmrvl.txt:	These commands are used to enable host sleep or wake up firmware
NeoLKernel/Documentation/BUG-HUNTING:> [<ffffffff810482d9>] autoremove_wake_function+0x0/0x2e
NeoLKernel/Documentation/laptops/laptop-mode.txt:# exceeded, the kernel will wake pdflush which will then reduce the amount
NeoLKernel/Documentation/laptops/laptop-mode.txt:# exceeded, the kernel will wake pdflush which will then reduce the amount
NeoLKernel/Documentation/laptops/thinkpad-acpi.txt:	wakeup_reason:
NeoLKernel/Documentation/laptops/thinkpad-acpi.txt:		undock.  Set to zero for normal wake-ups or wake-ups
NeoLKernel/Documentation/laptops/thinkpad-acpi.txt:	wakeup_hotunplug_complete:
NeoLKernel/Documentation/laptops/thinkpad-acpi.txt:		Set to 1 if the system was waken up because of an
NeoLKernel/Documentation/laptops/thinkpad-acpi.txt:		hotkey_radio_sw, wakeup_hotunplug_complete, wakeup_reason
NeoLKernel/Documentation/memory-barriers.txt:     - Sleep and wake-up functions.
NeoLKernel/Documentation/memory-barriers.txt:of going to sleep, and the primitives to initiate a wake up imply certain
NeoLKernel/Documentation/memory-barriers.txt:Secondly, code that performs a wake up normally follows something like this:
NeoLKernel/Documentation/memory-barriers.txt:	wake_up(&event_wait_queue);
NeoLKernel/Documentation/memory-barriers.txt:	wake_up_process(event_daemon);
NeoLKernel/Documentation/memory-barriers.txt:A write memory barrier is implied by wake_up() and co. if and only if they wake
NeoLKernel/Documentation/memory-barriers.txt:	  set_mb();			wake_up();
NeoLKernel/Documentation/memory-barriers.txt:The available waker functions include:
NeoLKernel/Documentation/memory-barriers.txt:	wake_up();
NeoLKernel/Documentation/memory-barriers.txt:	wake_up_all();
NeoLKernel/Documentation/memory-barriers.txt:	wake_up_bit();
NeoLKernel/Documentation/memory-barriers.txt:	wake_up_interruptible();
NeoLKernel/Documentation/memory-barriers.txt:	wake_up_interruptible_all();
NeoLKernel/Documentation/memory-barriers.txt:	wake_up_interruptible_nr();
NeoLKernel/Documentation/memory-barriers.txt:	wake_up_interruptible_poll();
NeoLKernel/Documentation/memory-barriers.txt:	wake_up_interruptible_sync();
NeoLKernel/Documentation/memory-barriers.txt:	wake_up_interruptible_sync_poll();
NeoLKernel/Documentation/memory-barriers.txt:	wake_up_locked();
NeoLKernel/Documentation/memory-barriers.txt:	wake_up_locked_poll();
NeoLKernel/Documentation/memory-barriers.txt:	wake_up_nr();
NeoLKernel/Documentation/memory-barriers.txt:	wake_up_poll();
NeoLKernel/Documentation/memory-barriers.txt:	wake_up_process();
NeoLKernel/Documentation/memory-barriers.txt:[!] Note that the memory barriers implied by the sleeper and the waker do _not_
NeoLKernel/Documentation/memory-barriers.txt:order multiple stores before the wake-up with respect to loads of those stored
NeoLKernel/Documentation/memory-barriers.txt:and the waker does:
NeoLKernel/Documentation/memory-barriers.txt:	wake_up(&event_wait_queue);
NeoLKernel/Documentation/memory-barriers.txt:and the waker should do:
NeoLKernel/Documentation/memory-barriers.txt:	wake_up(&event_wait_queue);
NeoLKernel/Documentation/memory-barriers.txt:To wake up a particular waiter, the up_read() or up_write() functions have to:
NeoLKernel/Documentation/memory-barriers.txt: (4) call wake_up_process() on the task; and
NeoLKernel/Documentation/memory-barriers.txt:	CALL wakeup
NeoLKernel/Documentation/memory-barriers.txt:	CALL wakeup
NeoLKernel/Documentation/sound/alsa/HD-Audio.txt:the wake-up timing.  It wakes up a few samples before actually
NeoLKernel/Documentation/sound/alsa/HD-Audio.txt:an artificial delay to the wake up timing.  This delay is controlled
NeoLKernel/Documentation/sound/alsa/powersave.txt:state.  Also, it often takes certain time to wake up from the
NeoLKernel/Documentation/sound/alsa/powersave.txt:consumption, but might result in longer wake-up time and click noise.
NeoLKernel/Documentation/sound/alsa/seq_oss.html:process will be awaked.
NeoLKernel/Documentation/sound/oss/ALS:If isapnptools is used to wake up the sound card (as in 2.2.x), the settings
NeoLKernel/Documentation/sound/oss/README.OSS:PnP models of sound cards even you have managed to wake up the card properly.
NeoLKernel/Documentation/spinlocks.txt:wake up. So read-locks are safe (which is good: they are very common
NeoLKernel/Documentation/sysctl/vm.txt:written out next time a pdflush daemon wakes up.
NeoLKernel/Documentation/sysctl/vm.txt:The pdflush writeback daemons will periodically wake up and write `old' data
NeoLKernel/Documentation/sysctl/vm.txt:out to disk.  This tunable expresses the interval between those wakeups, in
NeoLKernel/Documentation/DocBook/device-drivers.tmpl:X!Edrivers/acpi/sleep/wakeup.c
NeoLKernel/Documentation/DocBook/dvb/demux.xml: be specified as the wake-up condition. Only the latest event for each filter is
NeoLKernel/Documentation/DocBook/dvb/frontend.xml: be specified as the wake-up condition. Since the event queue allocated is
NeoLKernel/Documentation/DocBook/dvb/video.xml: poll(), POLLPRI should be specified as the wake-up condition. Read-only
NeoLKernel/Documentation/DocBook/gadget.tmpl:		USB suspend/resume, remote wakeup,
NeoLKernel/Documentation/DocBook/gadget.tmpl:more battery-friendly kind of device wakeup protocol.
NeoLKernel/Documentation/DocBook/gadget.tmpl:<function>usb_gadget_wakeup</function>
NeoLKernel/Documentation/DocBook/gadget.tmpl:	SRP support can be user-initiated just like remote wakeup,
NeoLKernel/Documentation/DocBook/genericirq.tmpl:	  <listitem><para>set_irq_wake()</para></listitem>
NeoLKernel/Documentation/DocBook/genericirq.tmpl:	  <listitem><para>set_wake() - Optional</para></listitem>
NeoLKernel/Documentation/DocBook/kernel-api.tmpl:	"standby" state may allow wakeup from several active domains, a
NeoLKernel/Documentation/DocBook/kernel-api.tmpl:	the number of possible wakeup event sources.  A driver's suspend
NeoLKernel/Documentation/DocBook/kernel-hacking.tmpl:   A wait queue is used to wait for someone to wake you up when a
NeoLKernel/Documentation/DocBook/kernel-hacking.tmpl:    Call <function>wake_up()</function>
NeoLKernel/Documentation/DocBook/kernel-hacking.tmpl:    which will wake up every process in the queue.  The exception is
NeoLKernel/Documentation/DocBook/mac80211.tmpl:!Finclude/net/mac80211.h ieee80211_wake_queue
NeoLKernel/Documentation/DocBook/mac80211.tmpl:!Finclude/net/mac80211.h ieee80211_wake_queues
NeoLKernel/Documentation/DocBook/writing-an-alsa-driver.tmpl:        position and calculates the available space, and wakes up the
NeoLKernel/Documentation/dontdiff:wakeup.bin
NeoLKernel/Documentation/dontdiff:wakeup.elf
NeoLKernel/Documentation/dontdiff:wakeup.lds
NeoLKernel/Documentation/filesystems/caching/object.txt:wakes up in that state.  There are four logical sets of states:
NeoLKernel/Documentation/filesystems/coda.txt:  Now P awakes and continues processing upcall.  There are some
NeoLKernel/Documentation/filesystems/fuse.txt: |        [wake up fc->waitq]         |        [woken up]
NeoLKernel/Documentation/filesystems/fuse.txt: |          [woken up]                |      [wake up req->waitq]
NeoLKernel/Documentation/filesystems/knfsd-stats.txt:	already choosing not to wake idle nfsd threads because there are too
NeoLKernel/Documentation/filesystems/knfsd-stats.txt:	Counts how many times the sunrpc server layer chose not to wake an
NeoLKernel/Documentation/futex-requeue-pi.txt:implementation would wake the highest-priority waiter, and leave the
NeoLKernel/Documentation/futex-requeue-pi.txt:rest to the natural wakeup inherent in unlocking the mutex
NeoLKernel/Documentation/futex-requeue-pi.txt:The requeue code cannot simply wake the waiter and leave it to
NeoLKernel/Documentation/futex-requeue-pi.txt:wake-up scenarios.
NeoLKernel/Documentation/futex-requeue-pi.txt:FUTEX_REQUEUE_CMP_PI is called by the waker
NeoLKernel/Documentation/futex-requeue-pi.txt:possibly wake the waiting tasks. Internally, this system call is
NeoLKernel/Documentation/futex-requeue-pi.txt:nr_wake+nr_requeue tasks to the PI futex, calling
NeoLKernel/Documentation/futex-requeue-pi.txt:FUTEX_REQUEUE_PI accepts nr_wake and nr_requeue as arguments, but
NeoLKernel/Documentation/futex-requeue-pi.txt:their sum is all that really matters.  futex_requeue() will wake or
NeoLKernel/Documentation/futex-requeue-pi.txt:requeue up to nr_wake + nr_requeue tasks.  It will wake only as many
NeoLKernel/Documentation/futex-requeue-pi.txt:nr_wake=1.  nr_requeue should be INT_MAX for broadcast and 0 for
NeoLKernel/Documentation/genlock.txt:(which will wake up other processes waiting for a read lock) without first
NeoLKernel/Documentation/gpio.txt:    wakeup events, to wake the system from a low power state.
NeoLKernel/Documentation/gpio.txt:system wakeup capabilities.
NeoLKernel/Documentation/i2c/writing-clients:activating a system wakeup mechanism -- do that in the suspend() method.
NeoLKernel/Documentation/ia64/efirtc.txt:EFI provides an API by which one can program when a machine should wakeup,
NeoLKernel/Documentation/networking/multiqueue.txt:netif_{start|stop|wake}_subqueue() functions to manage each queue while the
NeoLKernel/Documentation/networking/ppp_generic.txt:  and the channel should call the ppp_output_wakeup() function at a
NeoLKernel/Documentation/networking/ppp_generic.txt:* ppp_output_wakeup() is called by a channel when it has previously
NeoLKernel/Documentation/networking/ppp_generic.txt:when the channel calls  ppp_output_wakeup() or when the core
NeoLKernel/Documentation/networking/ppp_generic.txt:  ppp_output_wakeup(), ppp_channel_index() or ppp_unit_number() for a
NeoLKernel/Documentation/networking/rds.txt:    wake up sock
NeoLKernel/Documentation/networking/README.ipw2100:must buffer packets at the AP until the station wakes up and requests 
NeoLKernel/Documentation/networking/spider_net.txt:the netdev needs to be reawakened, so that more TX packets are placed
NeoLKernel/Documentation/networking/spider_net.txt:interrupt wakes up the netdev, which can then refill the queue.
NeoLKernel/Documentation/networking/vortex.txt:  Becker's `ether-wake' application may be used to wake suspended
NeoLKernel/Documentation/networking/vortex.txt:Donald's wake-on-LAN page:
NeoLKernel/Documentation/networking/vortex.txt:     http://www.scyld.com/wakeonlan.html
NeoLKernel/Documentation/networking/driver.txt:			printk(KERN_ERR PFX "%s: BUG! Tx Ring full when queue awake!\n",
NeoLKernel/Documentation/networking/driver.txt:		netif_wake_queue(dp->dev);
NeoLKernel/Documentation/networking/driver.txt:		netif_wake_queue(dp->dev);
NeoLKernel/Documentation/parport-lowlevel.txt:typedef void (*wakeup_func) (void *handle);
NeoLKernel/Documentation/parport-lowlevel.txt:                                          wakeup_func wakeup,
NeoLKernel/Documentation/parport-lowlevel.txt:'preempt', 'wakeup' and 'irq'.  Each of these may be NULL in order to
NeoLKernel/Documentation/parport-lowlevel.txt:The 'wakeup' function is called once another driver has released the
NeoLKernel/Documentation/parport-lowlevel.txt:parallel port from within the 'wakeup' function (in which case the
NeoLKernel/Documentation/parport-lowlevel.txt:static void wakeup (void *handle)
NeoLKernel/Documentation/parport-lowlevel.txt:					        wakeup, NULL, 0,
NeoLKernel/Documentation/PCI/pci.txt:			Useful for enabling wake-on-lan (NIC) or changing
NeoLKernel/Documentation/PCI/pci.txt:	o wake up the device if it was in suspended state,
NeoLKernel/Documentation/pi-futex.txt:pi_state->rt_mutex and thus wakes up any potential waiters.
NeoLKernel/Documentation/power/devices.txt:	Some drivers can manage hardware wakeup events, which make the system
NeoLKernel/Documentation/power/devices.txt:	relevant /sys/devices/.../power/wakeup file; enabling it may cost some
NeoLKernel/Documentation/power/devices.txt:Examples of hardware wakeup events include an alarm from a real time clock,
NeoLKernel/Documentation/power/devices.txt:network wake-on-LAN packets, keyboard or mouse activity, and media insertion
NeoLKernel/Documentation/power/devices.txt:/sys/devices/.../power/wakeup files
NeoLKernel/Documentation/power/devices.txt:wakeup events, which are hardware signals that can force the device and/or
NeoLKernel/Documentation/power/devices.txt:driver code using device_init_wakeup(dev,can_wakeup).
NeoLKernel/Documentation/power/devices.txt:The "can_wakeup" flag just records whether the device (and its driver) can
NeoLKernel/Documentation/power/devices.txt:physically support wakeup events.  When that flag is clear, the sysfs
NeoLKernel/Documentation/power/devices.txt:"wakeup" file is empty, and device_may_wakeup() returns false.
NeoLKernel/Documentation/power/devices.txt:For devices that can issue wakeup events, a separate flag controls whether
NeoLKernel/Documentation/power/devices.txt:that device should try to use its wakeup mechanism.  The initial value of
NeoLKernel/Documentation/power/devices.txt:device_may_wakeup() will be true, so that the device's "wakeup" file holds
NeoLKernel/Documentation/power/devices.txt:device_may_wakeup() returns false; or change it back to "enabled" (so that
NeoLKernel/Documentation/power/devices.txt:like pci_set_power_state(), pci_enable_wake(), pci_save_state(), and
NeoLKernel/Documentation/power/devices.txt:system-specific.  Also, wakeup-enabled devices will usually stay partly
NeoLKernel/Documentation/power/devices.txt:functional in order to wake the system.
NeoLKernel/Documentation/power/devices.txt:system wakeup events.
NeoLKernel/Documentation/power/devices.txt:When any driver sees that its device_can_wakeup(dev), it should make sure
NeoLKernel/Documentation/power/devices.txt:to use the relevant hardware signals to trigger a system wakeup event.
NeoLKernel/Documentation/power/devices.txt:For example, enable_irq_wake() might identify GPIO signals hooked up to
NeoLKernel/Documentation/power/devices.txt:a switch or other external hardware, and pci_enable_wake() does something
NeoLKernel/Documentation/power/devices.txt:PCI device may not perform DMA or issue IRQs, and any wakeup events it
NeoLKernel/Documentation/power/devices.txt:wakeup event sources (so drivers would call enable_irq_wake) and might
NeoLKernel/Documentation/power/devices.txt:be able to treat DMA completion as a wakeup event (sometimes DMA can stay
NeoLKernel/Documentation/power/devices.txt:	state kept in hardware, or issue system wakeup events.
NeoLKernel/Documentation/power/devices.txt:    PM_EVENT_HIBERNATE -- Put hardware into a low-power state and enable wakeup
NeoLKernel/Documentation/power/devices.txt:	(suspend-to-disk) and few devices are able to wake up the system from
NeoLKernel/Documentation/power/devices.txt:	followed by a call to the driver's resume() method.  Neither wakeup
NeoLKernel/Documentation/power/devices.txt:	wakeup events nor DMA are allowed.
NeoLKernel/Documentation/power/devices.txt:Note that the bus-specific runtime PM wakeup mechanism can exist, and might
NeoLKernel/Documentation/power/devices.txt:be defined to share some of the same driver code as for system wakeup.  For
NeoLKernel/Documentation/power/devices.txt:so it wouldn't only be called from bus.resume() during system-wide wakeup.
NeoLKernel/Documentation/power/devices.txt:See bus-specific information about how runtime wakeup events are handled.
NeoLKernel/Documentation/power/devices.txt:the system and manages its wakeup sequence.
NeoLKernel/Documentation/power/devices.txt:peripheral requesting "remote wakeup" or by plugging a new peripheral.  The
NeoLKernel/Documentation/power/devices.txt:same wakeup mechanism usually works from "standby" sleep states, and on some
NeoLKernel/Documentation/power/freezing-of-tasks.txt:either wakes them up, if they are kernel threads, or sends fake signals to them,
NeoLKernel/Documentation/power/pci.txt:pci_enable_wake
NeoLKernel/Documentation/power/pci.txt:	pci_enable_wake(struct pci_dev *dev, pci_power_t state, int enable);
NeoLKernel/Documentation/power/pci.txt:	and fail if it does not, unless enable == 0 (request is to disable wake
NeoLKernel/Documentation/power/pci.txt:calls to pci_enable_wake().
NeoLKernel/Documentation/power/pci.txt:	pci_enable_wake();
NeoLKernel/Documentation/power/runtime_pm.txt:In particular, if the driver requires remote wake-up capability (i.e. hardware
NeoLKernel/Documentation/power/runtime_pm.txt:PCI PME) for proper functioning and device_run_wake() returns 'false' for the
NeoLKernel/Documentation/power/runtime_pm.txt:device_run_wake() returns 'true' for the device and the device is put into a low
NeoLKernel/Documentation/power/runtime_pm.txt:expected that remote wake-up will be enabled for the device.  Generally, remote
NeoLKernel/Documentation/power/runtime_pm.txt:wake-up should be enabled for all input devices put into a low power state at
NeoLKernel/Documentation/power/runtime_pm.txt:->probe() callback will likely need to wake it up using one of the PM core's
NeoLKernel/Documentation/power/states.txt:trigger wake up events (e.g. pressing a key or opening a laptop lid).
NeoLKernel/Documentation/power/userland-swsusp.txt:	to use the SNAPSHOT_UNFREEZE call after the system wakes up.  This call
NeoLKernel/Documentation/powerpc/booting-without-of.txt:   awake during system suspend, but will not be disabled until then.
NeoLKernel/Documentation/powerpc/dts-bindings/fsl/mpc5200.txt:gpio@<addr>	fsl,mpc5200-gpio-wkup	 MPC5200 wakeup gpio controller
NeoLKernel/Documentation/powerpc/dts-bindings/fsl/pmc.txt:- fsl,mpc8313-wakeup-timer: For "fsl,mpc8313-pmc"-compatible devices,
NeoLKernel/Documentation/powerpc/dts-bindings/fsl/pmc.txt:  a wakeup source from deep sleep.
NeoLKernel/Documentation/RCU/torture.txt:posting wakeups to the migration kthreads, and N when waiting on CPU N.
NeoLKernel/Documentation/robust-futex-ABI.txt:robust_futexes.  The kernel will only be able to wakeup the next thread
NeoLKernel/Documentation/robust-futex-ABI.txt:indicating their holder died, and wakeup the next thread waiting for
NeoLKernel/Documentation/robust-futex-ABI.txt:existing futex mechanism to wait for, and wakeup, locks.  The kernels
NeoLKernel/Documentation/robust-futex-ABI.txt:    wakeup on that address, which will waken the next thread that has
NeoLKernel/Documentation/robust-futexes.txt:waiter with the waker - without them having to know about each other.
NeoLKernel/Documentation/robust-futexes.txt:sys_futex(FUTEX_WAKE) syscall to wake them up.  Once all waiters have
NeoLKernel/Documentation/robust-futexes.txt:this thread with the FUTEX_OWNER_DIED bit, and wakes up one waiter (if
NeoLKernel/Documentation/robust-futexes.txt:and wakes up the next futex waiter (if any). User-space does the rest of
NeoLKernel/Documentation/rt-mutex-design.txt:mutex, but that owner has yet to wake up and actually take the mutex.
NeoLKernel/Documentation/rt-mutex-design.txt:  owner to grab the mutex.  When a pending owner wakes up, it checks to see
NeoLKernel/Documentation/rt-mutex-design.txt:The schedule can then wake up for a few reasons.
NeoLKernel/Documentation/rt-mutex-design.txt:If there are waiters, then we need to wake one up and give that waiter
NeoLKernel/Documentation/rt-mutex-design.txt:On the wake up code, the pi_lock of the current owner is taken.  The top
NeoLKernel/Documentation/rt-mutex-design.txt:Finally we unlock the pi_lock of the pending owner and wake it up.
NeoLKernel/Documentation/rtc.txt:a few ways (enabling longer alarm periods, and wake-from-hibernate).
NeoLKernel/Documentation/rtc.txt:wakealarm:	 The time at which the clock will generate a system wakeup
NeoLKernel/Documentation/rtc.txt:		 event. This is a one shot wakeup event, so must be reset
NeoLKernel/Documentation/rtc.txt:		 after wake if a daily wakeup is required. Format is either
NeoLKernel/Documentation/rtc.txt:In many cases, the RTC alarm can be a system wake event, used to force
NeoLKernel/Documentation/s390/Debugging390.txt:is cpu_idle+0x66 ( quiet the cpu is asleep, don't wake it )
NeoLKernel/Documentation/scheduler/sched-arch.txt:take the runqueue lock. This is usually due to a wake up operation in
NeoLKernel/Documentation/scheduler/sched-arch.txt:   need an interrupt to wake them up when need_resched goes high.
NeoLKernel/Documentation/scheduler/sched-arch.txt:        over the sleep mean only NMIs can wake it up, so can't fix easily
NeoLKernel/Documentation/scheduler/sched-stats.txt:Next two are try_to_wake_up() statistics:
NeoLKernel/Documentation/scheduler/sched-stats.txt:     8) # of times try_to_wake_up() was called
NeoLKernel/Documentation/scheduler/sched-stats.txt:     9) # of times try_to_wake_up() was called to wake up the local cpu
NeoLKernel/Documentation/scheduler/sched-stats.txt:   Next three are try_to_wake_up() statistics:
NeoLKernel/Documentation/scheduler/sched-stats.txt:    34) # of times in this domain try_to_wake_up() awoke a task that
NeoLKernel/Documentation/scheduler/sched-stats.txt:    35) # of times in this domain try_to_wake_up() moved a task to the
NeoLKernel/Documentation/scheduler/sched-stats.txt:    36) # of times in this domain try_to_wake_up() started passive balancing
NeoLKernel/Documentation/scsi/ChangeLog.1992-1997:	* scsi.h: Call wake_up(&wait_for_request) when done with a
NeoLKernel/Documentation/scsi/ChangeLog.1992-1997:	count to 0, clear this bit to allow usage to continue, wake up
NeoLKernel/Documentation/scsi/ChangeLog.lpfc:	* If the mbox_cmpl == lpfc_sli_wake_mbox_wait in
NeoLKernel/Documentation/scsi/ChangeLog.lpfc:	* Fix race condition in lpfc_do_dpc.  If wake_up interrupt occurs
NeoLKernel/Documentation/scsi/ChangeLog.lpfc:	  does not wakeup.  The sleep interval is MAX_SCHEDULE_TIMEOUT
NeoLKernel/Documentation/scsi/ChangeLog.lpfc:	  moved to kthread. kthread_stop() is not able to wake up thread
NeoLKernel/Documentation/scsi/ChangeLog.lpfc:	  lpfc_del_bind(), lpfc_sli_wake_mbox_wait() and
NeoLKernel/Documentation/scsi/ChangeLog.lpfc:	* Change lpfc_sli_wake_iocb_wait to do a regular wake_up since
NeoLKernel/Documentation/scsi/ChangeLog.lpfc:	* Move lpfc_wakeup_event from lpfc_fcp.c to lpfc_ioctl.c
NeoLKernel/Documentation/scsi/ChangeLog.lpfc:	* Remove functions lpfc_get_OsNameVersion and elx_wakeup. Change
NeoLKernel/Documentation/scsi/ChangeLog.lpfc:	  elx_wakeup to wake_up_interruptible
NeoLKernel/Documentation/scsi/ChangeLog.sym53c8xx:	- Make the code simpler in the wakeup_done routine.
NeoLKernel/Documentation/scsi/scsi_eh.txt:shost->host_failed.  This wakes up SCSI EH thread.  So, once woken up,
NeoLKernel/Documentation/serial/driver:uart_write_wakeup(port)
NeoLKernel/Documentation/serial/tty.txt:write_wakeup()	-	May be called at any point between open and close.
NeoLKernel/Documentation/serial/tty.txt:			write_wakeup() method in order to resume
NeoLKernel/Documentation/timers/highres.txt:context. This applies, for example, to the common case of a wakeup function as
NeoLKernel/Documentation/timers/timer_stats.txt:wakeups, which should be avoided to optimize power consumption.
NeoLKernel/Documentation/intel_txt.txt:o  It will wake the APs from the special sleep state the GETSEC[SENTER]
NeoLKernel/Documentation/intel_txt.txt:      special code into the kernel's MP wakeup sequence.
NeoLKernel/Documentation/kernel-parameters.txt:			interrupt wake-up latency, which may improve performance
NeoLKernel/Documentation/kernel-parameters.txt:			this state using a wakeup-capable RTC alarm.
NeoLKernel/Documentation/cpu-freq/governors.txt:(for example, when there's a "daemonized" function that wakes up 
NeoLKernel/Documentation/cpu-load.txt:                                     (only to be awaken quite soon)
NeoLKernel/Documentation/trace/events.txt:To enable a particular event, such as 'sched_wakeup', simply echo it
NeoLKernel/Documentation/trace/events.txt:	# echo sched_wakeup >> /sys/kernel/debug/tracing/set_event
NeoLKernel/Documentation/trace/events.txt:	# echo '!sched_wakeup' >> /sys/kernel/debug/tracing/set_event
NeoLKernel/Documentation/trace/events.txt:To enable event 'sched_wakeup':
NeoLKernel/Documentation/trace/events.txt:	# echo 1 > /sys/kernel/debug/tracing/events/sched/sched_wakeup/enable
NeoLKernel/Documentation/trace/events.txt:	# echo 0 > /sys/kernel/debug/tracing/events/sched/sched_wakeup/enable
NeoLKernel/Documentation/trace/events.txt:For example, here's the information displayed for the 'sched_wakeup'
NeoLKernel/Documentation/trace/events.txt:# cat /debug/tracing/events/sched/sched_wakeup/format
NeoLKernel/Documentation/trace/events.txt:name: sched_wakeup
NeoLKernel/Documentation/trace/events.txt:# cd /debug/tracing/events/sched/sched_wakeup
NeoLKernel/Documentation/trace/events.txt:# cat sched_wakeup/filter
NeoLKernel/Documentation/trace/events.txt:# cat sched_wakeup/filter
NeoLKernel/Documentation/trace/events.txt:# cat sched_wakeup/filter
NeoLKernel/Documentation/trace/ftrace.txt:	Traces the context switches and wakeups between tasks.
NeoLKernel/Documentation/trace/ftrace.txt:  "wakeup"
NeoLKernel/Documentation/trace/ftrace.txt:The sched_switch tracer also includes tracing of task wakeups
NeoLKernel/Documentation/trace/ftrace.txt:"FUNCTION" is a misnomer since here it represents the wake ups
NeoLKernel/Documentation/trace/ftrace.txt:The sched_switch file only lists the wake ups (represented with
NeoLKernel/Documentation/trace/ftrace.txt:wakeup
NeoLKernel/Documentation/trace/ftrace.txt:wakeup time it takes for the highest priority task that is woken
NeoLKernel/Documentation/trace/ftrace.txt:work well with Real-Time tasks.  The wakeup tracer was designed
NeoLKernel/Documentation/trace/ftrace.txt:to record the worst case wakeups of RT tasks. Non-RT tasks are
NeoLKernel/Documentation/trace/ftrace.txt: # echo wakeup > current_tracer
NeoLKernel/Documentation/trace/ftrace.txt:# tracer: wakeup
NeoLKernel/Documentation/trace/ftrace.txt:wakeup latency trace v1.1.5 on 2.6.26-rc8
NeoLKernel/Documentation/trace/ftrace.txt:  <idle>-0     1d.h4    0us+: try_to_wake_up (wake_up_process)
NeoLKernel/Documentation/trace/ftrace.txt:# tracer: wakeup
NeoLKernel/Documentation/trace/ftrace.txt:wakeup latency trace v1.1.5 on 2.6.26-rc8
NeoLKernel/Documentation/trace/ftrace.txt:ksoftirq-7     1d.H3    0us : try_to_wake_up (wake_up_process)
NeoLKernel/Documentation/trace/ftrace.txt:ksoftirq-7     1d.H3    2us : check_preempt_wakeup (try_to_wake_up)
NeoLKernel/Documentation/trace/ftrace.txt:ksoftirq-7     1d.H3    3us : update_curr (check_preempt_wakeup)
NeoLKernel/Documentation/trace/ftrace.txt:ksoftirq-7     1d.H3    5us : __resched_task (check_preempt_wakeup)
NeoLKernel/Documentation/trace/ftrace.txt:ksoftirq-7     1d.H3    6us : task_wake_up_rt (try_to_wake_up)
NeoLKernel/Documentation/trace/ftrace.txt:ksoftirq-7     1d.H3    7us : _spin_unlock_irqrestore (try_to_wake_up)
NeoLKernel/Documentation/trace/ftrace.txt:  360.774523 |   1)   0.541 us    |                                        __wake_up_bit();
NeoLKernel/Documentation/trace/ftrace.txt:  360.774529 |   1)               |                                      wake_up_bit() {
NeoLKernel/Documentation/trace/ftrace.txt:hrtimer_wakeup
NeoLKernel/Documentation/trace/ftrace.txt:hrtimer_wakeup
NeoLKernel/Documentation/trace/ftrace.txt:            bash-4043  [01]   115.281648: wake_up_process <-kthread_stop
NeoLKernel/Documentation/trace/ftrace.txt:            bash-4043  [01]   115.281649: try_to_wake_up <-wake_up_process
NeoLKernel/Documentation/trace/ftrace.txt: 0)   0.639 us    |      __wake_up_bit();
NeoLKernel/Documentation/trace/ftrace.txt: 0)   0.638 us    |      __wake_up_bit();
NeoLKernel/Documentation/trace/ftrace.txt:            bash-4043  [00] 41.267110: wake_up_process <-kthread_stop
NeoLKernel/Documentation/trace/ftrace.txt:            bash-4043  [00] 41.267110: try_to_wake_up <-wake_up_process
NeoLKernel/Documentation/trace/ftrace.txt:            bash-4043  [00] 41.267111: select_task_rq_rt <-try_to_wake_up
NeoLKernel/Documentation/uml/UserModeLinux-HOWTO.txt:  version command is a good way to 'wake it up' before networking has
NeoLKernel/Documentation/usb/msm_otg.txt:remote device remote wakeup.
NeoLKernel/Documentation/usb/msm_otg.txt:System suspend is negated by acquiring wakelock while processing OTG state
NeoLKernel/Documentation/usb/msm_otg.txt:acquire wakelock if required.
NeoLKernel/Documentation/usb/msm_otg.txt:SRP may be initiated when function drivers use remote wakeup facility, when
NeoLKernel/Documentation/usb/persist.txt:wakes up all the devices attached to that controller are treated as
NeoLKernel/Documentation/usb/persist.txt:was asleep, on many systems during the initial stages of wakeup the
NeoLKernel/Documentation/usb/persist.txt:suspended -- but it will crash as soon as it wakes up, which isn't
NeoLKernel/Documentation/usb/power-management.txt:LAN"; we will refer to it generically as "remote wakeup".  When a
NeoLKernel/Documentation/usb/power-management.txt:device is enabled for remote wakeup and it is suspended, it may resume
NeoLKernel/Documentation/usb/power-management.txt:same reason, an autosuspended device will usually have remote wakeup
NeoLKernel/Documentation/usb/power-management.txt:enabled, if the device supports remote wakeup.
NeoLKernel/Documentation/usb/power-management.txt:userspace), and remote wakeup (triggered by the device).  Internal
NeoLKernel/Documentation/usb/power-management.txt:relevant attribute files are: wakeup, level, and autosuspend.
NeoLKernel/Documentation/usb/power-management.txt:	power/wakeup
NeoLKernel/Documentation/usb/power-management.txt:		remote wakeup.  Otherwise the file contains either the
NeoLKernel/Documentation/usb/power-management.txt:		whether or not remote wakeup will be enabled when the
NeoLKernel/Documentation/usb/power-management.txt:		wakeup may still be allowed, since it is controlled
NeoLKernel/Documentation/usb/power-management.txt:		separately by the power/wakeup attribute.)
NeoLKernel/Documentation/usb/power-management.txt:causing the keyboard to do a remote wakeup all right, would
NeoLKernel/Documentation/usb/power-management.txt:showed that some of them would issue a remote-wakeup request in
NeoLKernel/Documentation/usb/power-management.txt:Sometimes a driver needs to make sure that remote wakeup is enabled
NeoLKernel/Documentation/usb/power-management.txt:remote wakeup by typing on it.  If the driver sets
NeoLKernel/Documentation/usb/power-management.txt:intf->needs_remote_wakeup to 1, the kernel won't autosuspend the
NeoLKernel/Documentation/usb/power-management.txt:device if remote wakeup isn't available or has been disabled through
NeoLKernel/Documentation/usb/power-management.txt:the power/wakeup attribute.  (If the device is already autosuspended,
NeoLKernel/Documentation/usb/power-management.txt:do get resumed when the system wakes up.  (Presumably they will be
NeoLKernel/Documentation/usb/power-management.txt:wakeup, then the reset-resume takes place even if the device was
NeoLKernel/Documentation/usb/power-management.txt:that a reset-resume is a kind of remote-wakeup event.  Or to put it
NeoLKernel/Documentation/usb/power-management.txt:normal remote-wakeup signals, so it ought to be resumed immediately.)
NeoLKernel/Documentation/usb/power-management.txt:For example, a suspended device may send a remote-wakeup signal while
NeoLKernel/Documentation/usb/power-management.txt:the system is suspending.  The remote wakeup may succeed, which would
NeoLKernel/Documentation/usb/power-management.txt:cause the system suspend to abort.  If the remote wakeup doesn't
NeoLKernel/Documentation/usb/power-management.txt:wakeup may fail and get lost.  Which outcome occurs depends on timing
NeoLKernel/Documentation/usb/WUSB-Design-overview.txt:UWBD wakes up and scans the event list; finds a beacon and adds it to
NeoLKernel/Documentation/video4linux/v4l2-framework.txt:	wake_up(&buf->vb.done);
NeoLKernel/Documentation/vm/balance:highmem pages. kswapd looks at the zone_wake_kswapd field in the zone
NeoLKernel/Documentation/vm/balance:watemark[WMARK_MIN/WMARK_LOW/WMARK_HIGH]/low_on_memory/zone_wake_kswapd: These
NeoLKernel/Documentation/vm/balance:pages is below watermark[WMARK_LOW]; in which case zone_wake_kswapd is also set.
NeoLKernel/drivers/firewire/core-cdev.c:	wake_up_interruptible(&client->wait);
NeoLKernel/drivers/firewire/core-cdev.c:static void wake_up_client(struct client *client)
NeoLKernel/drivers/firewire/core-cdev.c:	wake_up_interruptible(&client->wait);
NeoLKernel/drivers/firewire/core-cdev.c:	for_each_client(device, wake_up_client);
NeoLKernel/drivers/firewire/net.c:		netif_wake_queue(net);
NeoLKernel/drivers/firewire/net.c:		netif_wake_queue(net);
NeoLKernel/drivers/firewire/net.c:		netif_wake_queue(net);
NeoLKernel/drivers/memstick/host/jmb38x_ms.c:	pci_enable_wake(dev, pci_choose_state(dev, state), 0);
NeoLKernel/drivers/sbus/char/bbc_i2c.c:		wake_up_interruptible(&bp->wq);
NeoLKernel/drivers/acpi/acpica/acevents.h:acpi_ev_check_for_wake_only_gpe(struct acpi_gpe_event_info *gpe_event_info);
NeoLKernel/drivers/acpi/acpica/acglobal.h: * Disable wakeup GPEs during runtime? Default is TRUE because WAKE and
NeoLKernel/drivers/acpi/acpica/acglobal.h:u8 ACPI_INIT_GLOBAL(acpi_gbl_leave_wake_gpes_disabled, TRUE);
NeoLKernel/drivers/acpi/acpica/acglobal.h:ACPI_EXTERN u8 acpi_gbl_system_awake_and_running;
NeoLKernel/drivers/acpi/acpica/achware.h:acpi_status acpi_hw_enable_all_wakeup_gpes(void);
NeoLKernel/drivers/acpi/acpica/aclocal.h:	u8 enable_for_wake;	/* GPEs to keep enabled when sleeping */
NeoLKernel/drivers/acpi/acpica/exoparg2.c:		 * GPE method wake/notify check.  Here, we want to ensure that we
NeoLKernel/drivers/acpi/acpica/exoparg2.c:		 * as "wake-only" and disabled.
NeoLKernel/drivers/acpi/acpica/exoparg2.c:		 * 1) Is the Notify() value == device_wake?
NeoLKernel/drivers/acpi/acpica/exoparg2.c:		 *    (versus during wake)
NeoLKernel/drivers/acpi/acpica/exoparg2.c:		 * If all three cases are true, this is a wake-only GPE that should
NeoLKernel/drivers/acpi/acpica/exoparg2.c:		if (value == 2) {	/* device_wake */
NeoLKernel/drivers/acpi/acpica/exoparg2.c:			    acpi_ev_check_for_wake_only_gpe(walk_state->
NeoLKernel/drivers/acpi/acpica/exsystem.c:				  "*** Thread awake after blocking, %s\n",
NeoLKernel/drivers/acpi/acpica/exsystem.c:				  "*** Thread awake after blocking, %s\n",
NeoLKernel/drivers/acpi/acpica/hwgpe.c:acpi_hw_enable_wakeup_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
NeoLKernel/drivers/acpi/acpica/hwgpe.c:	/* GPE enabled for wake? */
NeoLKernel/drivers/acpi/acpica/hwgpe.c:	if (register_bit & gpe_register_info->enable_for_wake) {
NeoLKernel/drivers/acpi/acpica/hwgpe.c: *              combination wake/run GPEs.
NeoLKernel/drivers/acpi/acpica/hwgpe.c: * FUNCTION:    acpi_hw_enable_wakeup_gpe_block
NeoLKernel/drivers/acpi/acpica/hwgpe.c: * DESCRIPTION: Enable all "wake" GPEs within a single GPE block. Includes
NeoLKernel/drivers/acpi/acpica/hwgpe.c: *              combination wake/run GPEs.
NeoLKernel/drivers/acpi/acpica/hwgpe.c:acpi_hw_enable_wakeup_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
NeoLKernel/drivers/acpi/acpica/hwgpe.c:		if (!gpe_block->register_info[i].enable_for_wake) {
NeoLKernel/drivers/acpi/acpica/hwgpe.c:		/* Enable all "wake" GPEs in this register */
NeoLKernel/drivers/acpi/acpica/hwgpe.c:		    acpi_hw_write(gpe_block->register_info[i].enable_for_wake,
NeoLKernel/drivers/acpi/acpica/hwgpe.c: * FUNCTION:    acpi_hw_enable_all_wakeup_gpes
NeoLKernel/drivers/acpi/acpica/hwgpe.c: * DESCRIPTION: Enable all "wakeup" GPEs, in all GPE blocks
NeoLKernel/drivers/acpi/acpica/hwgpe.c:acpi_status acpi_hw_enable_all_wakeup_gpes(void)
NeoLKernel/drivers/acpi/acpica/hwgpe.c:	ACPI_FUNCTION_TRACE(hw_enable_all_wakeup_gpes);
NeoLKernel/drivers/acpi/acpica/hwgpe.c:	status = acpi_ev_walk_gpe_list(acpi_hw_enable_wakeup_gpe_block, NULL);
NeoLKernel/drivers/acpi/acpica/hwsleep.c:	 * be used, unless we want the wake-up code to be called by the BIOS in
NeoLKernel/drivers/acpi/acpica/hwsleep.c:	/* _PSW methods could be run here to enable wake-on keyboard, LAN, etc. */
NeoLKernel/drivers/acpi/acpica/hwsleep.c:	/* Clear wake status */
NeoLKernel/drivers/acpi/acpica/hwsleep.c:	 * 2) Enable all wakeup GPEs
NeoLKernel/drivers/acpi/acpica/hwsleep.c:	acpi_gbl_system_awake_and_running = FALSE;
NeoLKernel/drivers/acpi/acpica/hwsleep.c:	status = acpi_hw_enable_all_wakeup_gpes();
NeoLKernel/drivers/acpi/acpica/hwsleep.c:		/* Spin until we wake */
NeoLKernel/drivers/acpi/acpica/hwsleep.c:	/* Clear the wake status bit (PM1) */
NeoLKernel/drivers/acpi/acpica/hwsleep.c:	 * 2) Enable all wakeup GPEs
NeoLKernel/drivers/acpi/acpica/hwsleep.c:	acpi_gbl_system_awake_and_running = FALSE;
NeoLKernel/drivers/acpi/acpica/hwsleep.c:	status = acpi_hw_enable_all_wakeup_gpes();
NeoLKernel/drivers/acpi/acpica/hwsleep.c:	acpi_gbl_system_awake_and_running = TRUE;
NeoLKernel/drivers/acpi/acpica/utglobal.c:	acpi_gbl_system_awake_and_running = TRUE;
NeoLKernel/drivers/acpi/acpica/evgpe.c: * DESCRIPTION: Sets the new type for the GPE (wake, run, or wake/run)
NeoLKernel/drivers/acpi/acpica/evgpe.c:		ACPI_CLEAR_BIT(gpe_register_info->enable_for_wake,
NeoLKernel/drivers/acpi/acpica/evgpe.c:		ACPI_SET_BIT(gpe_register_info->enable_for_wake, register_bit);
NeoLKernel/drivers/acpi/acpica/evgpe.c:		ACPI_CLEAR_BIT(gpe_register_info->enable_for_wake,
NeoLKernel/drivers/acpi/acpica/evgpe.c:		ACPI_SET_BIT(gpe_register_info->enable_for_wake, register_bit);
NeoLKernel/drivers/acpi/acpica/evgpe.c:	/* Mark wake-enabled or HW enable, or both */
NeoLKernel/drivers/acpi/acpica/evgpeblk.c:	u32 wake_gpe_count;
NeoLKernel/drivers/acpi/acpica/evgpeblk.c:	 * Runtime option: Should wake GPEs be enabled at runtime?  The default
NeoLKernel/drivers/acpi/acpica/evgpeblk.c:	if (acpi_gbl_leave_wake_gpes_disabled) {
NeoLKernel/drivers/acpi/acpica/evgpeblk.c:		 * Differentiate runtime vs wake GPEs, via the _PRW control methods.
NeoLKernel/drivers/acpi/acpica/evgpeblk.c:		 * definition a wake GPE and will not be enabled while the machine
NeoLKernel/drivers/acpi/acpica/evgpeblk.c:	 * 1) are "runtime" or "run/wake" GPEs, and
NeoLKernel/drivers/acpi/acpica/evgpeblk.c:	wake_gpe_count = 0;
NeoLKernel/drivers/acpi/acpica/evgpeblk.c:				wake_gpe_count++;
NeoLKernel/drivers/acpi/acpica/evgpeblk.c:			  wake_gpe_count, gpe_enabled_count));
NeoLKernel/drivers/acpi/acpica/evmisc.c:		/* Got the lock, now wake all threads waiting for it */
NeoLKernel/drivers/acpi/acpica/evxfevnt.c: *              Flags           - Just enable, or also wake enable?
NeoLKernel/drivers/acpi/acpica/evxfevnt.c: *              Flags           - Just disable, or also wake disable?
NeoLKernel/drivers/acpi/bus.c:bool acpi_bus_can_wakeup(acpi_handle handle)
NeoLKernel/drivers/acpi/bus.c:	return result ? false : device->wakeup.flags.valid;
NeoLKernel/drivers/acpi/bus.c:EXPORT_SYMBOL(acpi_bus_can_wakeup);
NeoLKernel/drivers/acpi/bus.c:	wake_up_interruptible(&acpi_bus_event_queue);
NeoLKernel/drivers/acpi/bus.c:	acpi_wakeup_device_init();
NeoLKernel/drivers/acpi/button.c:	if (device->wakeup.flags.valid) {
NeoLKernel/drivers/acpi/button.c:		/* Button's GPE is run-wake GPE */
NeoLKernel/drivers/acpi/button.c:		acpi_set_gpe_type(device->wakeup.gpe_device,
NeoLKernel/drivers/acpi/button.c:				  device->wakeup.gpe_number,
NeoLKernel/drivers/acpi/button.c:		acpi_enable_gpe(device->wakeup.gpe_device,
NeoLKernel/drivers/acpi/button.c:				device->wakeup.gpe_number);
NeoLKernel/drivers/acpi/button.c:		device->wakeup.state.enabled = 1;
NeoLKernel/drivers/acpi/ec.c:		wake_up(&ec->wait);
NeoLKernel/drivers/acpi/glue.c:		if (acpi_dev->wakeup.flags.valid) {
NeoLKernel/drivers/acpi/glue.c:			device_set_wakeup_capable(dev, true);
NeoLKernel/drivers/acpi/glue.c:			device_set_wakeup_enable(dev,
NeoLKernel/drivers/acpi/glue.c:						acpi_dev->wakeup.state.enabled);
NeoLKernel/drivers/acpi/internal.h:int acpi_device_sleep_wake(struct acpi_device *dev,
NeoLKernel/drivers/acpi/internal.h:int acpi_enable_wakeup_device_power(struct acpi_device *dev, int sleep_state);
NeoLKernel/drivers/acpi/internal.h:int acpi_disable_wakeup_device_power(struct acpi_device *dev);
NeoLKernel/drivers/acpi/internal.h:int acpi_wakeup_device_init(void);
NeoLKernel/drivers/acpi/Makefile:acpi-y				+= wakeup.o
NeoLKernel/drivers/acpi/osl.c: * We disable wake-GPEs at run-time to prevent spurious
NeoLKernel/drivers/acpi/osl.c: * to tell Linux to keep the wake-time GPEs enabled at run-time.
NeoLKernel/drivers/acpi/osl.c:static int __init acpi_wake_gpes_always_on_setup(char *str)
NeoLKernel/drivers/acpi/osl.c:	printk(KERN_INFO PREFIX "wake GPEs not disabled\n");
NeoLKernel/drivers/acpi/osl.c:	acpi_gbl_leave_wake_gpes_disabled = FALSE;
NeoLKernel/drivers/acpi/osl.c:__setup("acpi_wake_gpes_always_on", acpi_wake_gpes_always_on_setup);
NeoLKernel/drivers/acpi/power.c: * acpi_device_sleep_wake - execute _DSW (Device Sleep Wake) or (deprecated in
NeoLKernel/drivers/acpi/power.c: * @enable: 0 - disable, 1 - enable the wake capabilities of the device.
NeoLKernel/drivers/acpi/power.c: * wakeup.flags.valid flag.
NeoLKernel/drivers/acpi/power.c:int acpi_device_sleep_wake(struct acpi_device *dev,
NeoLKernel/drivers/acpi/power.c:	 * Argument 0: enable/disable the wake capabilities
NeoLKernel/drivers/acpi/power.c:	 * When _DSW object is called to disable the wake capabilities, maybe
NeoLKernel/drivers/acpi/power.c:		dev->wakeup.flags.valid = 0;
NeoLKernel/drivers/acpi/power.c:		dev->wakeup.flags.valid = 0;
NeoLKernel/drivers/acpi/power.c: * Prepare a wakeup device, two steps (Ref ACPI 2.0:P229):
NeoLKernel/drivers/acpi/power.c: * 1. Power on the power resources required for the wakeup device 
NeoLKernel/drivers/acpi/power.c:int acpi_enable_wakeup_device_power(struct acpi_device *dev, int sleep_state)
NeoLKernel/drivers/acpi/power.c:	if (!dev || !dev->wakeup.flags.valid)
NeoLKernel/drivers/acpi/power.c:	if (dev->wakeup.prepare_count++)
NeoLKernel/drivers/acpi/power.c:	for (i = 0; i < dev->wakeup.resources.count; i++) {
NeoLKernel/drivers/acpi/power.c:		int ret = acpi_power_on(dev->wakeup.resources.handles[i], dev);
NeoLKernel/drivers/acpi/power.c:			dev->wakeup.flags.valid = 0;
NeoLKernel/drivers/acpi/power.c:	err = acpi_device_sleep_wake(dev, 1, sleep_state, 3);
NeoLKernel/drivers/acpi/power.c:		dev->wakeup.prepare_count = 0;
NeoLKernel/drivers/acpi/power.c: * Shutdown a wakeup device, counterpart of above method
NeoLKernel/drivers/acpi/power.c:int acpi_disable_wakeup_device_power(struct acpi_device *dev)
NeoLKernel/drivers/acpi/power.c:	if (!dev || !dev->wakeup.flags.valid)
NeoLKernel/drivers/acpi/power.c:	if (--dev->wakeup.prepare_count > 0)
NeoLKernel/drivers/acpi/power.c:	if (dev->wakeup.prepare_count < 0)
NeoLKernel/drivers/acpi/power.c:		dev->wakeup.prepare_count = 0;
NeoLKernel/drivers/acpi/power.c:	err = acpi_device_sleep_wake(dev, 0, 0, 0);
NeoLKernel/drivers/acpi/power.c:	for (i = 0; i < dev->wakeup.resources.count; i++) {
NeoLKernel/drivers/acpi/power.c:				dev->wakeup.resources.handles[i], dev);
NeoLKernel/drivers/acpi/power.c:			dev->wakeup.flags.valid = 0;
NeoLKernel/drivers/acpi/proc.c: * /proc/acpi/wakeup
NeoLKernel/drivers/acpi/proc.c:/* use /sys/class/rtc/rtcX/wakealarm instead; it's not ACPI-specific */
NeoLKernel/drivers/acpi/proc.c:acpi_system_wakeup_device_seq_show(struct seq_file *seq, void *offset)
NeoLKernel/drivers/acpi/proc.c:	list_for_each_safe(node, next, &acpi_wakeup_device_list) {
NeoLKernel/drivers/acpi/proc.c:		    container_of(node, struct acpi_device, wakeup_list);
NeoLKernel/drivers/acpi/proc.c:		if (!dev->wakeup.flags.valid)
NeoLKernel/drivers/acpi/proc.c:			   (u32) dev->wakeup.sleep_state,
NeoLKernel/drivers/acpi/proc.c:			   dev->wakeup.flags.run_wake ? '*' : ' ',
NeoLKernel/drivers/acpi/proc.c:			   dev->wakeup.state.enabled ? "enabled" : "disabled");
NeoLKernel/drivers/acpi/proc.c:static void physical_device_enable_wakeup(struct acpi_device *adev)
NeoLKernel/drivers/acpi/proc.c:	if (dev && device_can_wakeup(dev))
NeoLKernel/drivers/acpi/proc.c:		device_set_wakeup_enable(dev, adev->wakeup.state.enabled);
NeoLKernel/drivers/acpi/proc.c:acpi_system_write_wakeup_device(struct file *file,
NeoLKernel/drivers/acpi/proc.c:	list_for_each_safe(node, next, &acpi_wakeup_device_list) {
NeoLKernel/drivers/acpi/proc.c:		    container_of(node, struct acpi_device, wakeup_list);
NeoLKernel/drivers/acpi/proc.c:		if (!dev->wakeup.flags.valid)
NeoLKernel/drivers/acpi/proc.c:			dev->wakeup.state.enabled =
NeoLKernel/drivers/acpi/proc.c:			    dev->wakeup.state.enabled ? 0 : 1;
NeoLKernel/drivers/acpi/proc.c:		physical_device_enable_wakeup(found_dev);
NeoLKernel/drivers/acpi/proc.c:		list_for_each_safe(node, next, &acpi_wakeup_device_list) {
NeoLKernel/drivers/acpi/proc.c:							       wakeup_list);
NeoLKernel/drivers/acpi/proc.c:			    (dev->wakeup.gpe_number ==
NeoLKernel/drivers/acpi/proc.c:			     found_dev->wakeup.gpe_number)
NeoLKernel/drivers/acpi/proc.c:			    && (dev->wakeup.gpe_device ==
NeoLKernel/drivers/acpi/proc.c:				found_dev->wakeup.gpe_device)) {
NeoLKernel/drivers/acpi/proc.c:				dev->wakeup.state.enabled =
NeoLKernel/drivers/acpi/proc.c:				    found_dev->wakeup.state.enabled;
NeoLKernel/drivers/acpi/proc.c:				physical_device_enable_wakeup(dev);
NeoLKernel/drivers/acpi/proc.c:acpi_system_wakeup_device_open_fs(struct inode *inode, struct file *file)
NeoLKernel/drivers/acpi/proc.c:	return single_open(file, acpi_system_wakeup_device_seq_show,
NeoLKernel/drivers/acpi/proc.c:static const struct file_operations acpi_system_wakeup_device_fops = {
NeoLKernel/drivers/acpi/proc.c:	.open = acpi_system_wakeup_device_open_fs,
NeoLKernel/drivers/acpi/proc.c:	.write = acpi_system_write_wakeup_device,
NeoLKernel/drivers/acpi/proc.c:	/* 'wakeup device' [R/W] */
NeoLKernel/drivers/acpi/proc.c:	proc_create("wakeup", S_IFREG | S_IRUGO | S_IWUSR,
NeoLKernel/drivers/acpi/proc.c:		    acpi_root_dir, &acpi_system_wakeup_device_fops);
NeoLKernel/drivers/acpi/processor_idle.c:	 * in order for Bus Master activity to wake the
NeoLKernel/drivers/acpi/processor_idle.c:	sched_clock_idle_wakeup_event(sleep_ticks*PM_TIMER_TICK_NS);
NeoLKernel/drivers/acpi/processor_idle.c:	sched_clock_idle_wakeup_event(sleep_ticks*PM_TIMER_TICK_NS);
NeoLKernel/drivers/acpi/sbshc.c:		wake_up(&hc->wait);
NeoLKernel/drivers/acpi/scan.c:LIST_HEAD(acpi_wakeup_device_list);
NeoLKernel/drivers/acpi/scan.c:	INIT_LIST_HEAD(&device->wakeup_list);
NeoLKernel/drivers/acpi/scan.c:	if (device->wakeup.flags.valid)
NeoLKernel/drivers/acpi/scan.c:		list_add_tail(&device->wakeup_list, &acpi_wakeup_device_list);
NeoLKernel/drivers/acpi/scan.c:	list_del(&device->wakeup_list);
NeoLKernel/drivers/acpi/scan.c:	list_del(&device->wakeup_list);
NeoLKernel/drivers/acpi/scan.c:acpi_bus_extract_wakeup_device_power_package(struct acpi_device *device,
NeoLKernel/drivers/acpi/scan.c:		device->wakeup.gpe_device =
NeoLKernel/drivers/acpi/scan.c:		device->wakeup.gpe_number =
NeoLKernel/drivers/acpi/scan.c:		device->wakeup.gpe_number = element->integer.value;
NeoLKernel/drivers/acpi/scan.c:	device->wakeup.sleep_state = element->integer.value;
NeoLKernel/drivers/acpi/scan.c:	device->wakeup.resources.count = package->package.count - 2;
NeoLKernel/drivers/acpi/scan.c:	for (i = 0; i < device->wakeup.resources.count; i++) {
NeoLKernel/drivers/acpi/scan.c:		device->wakeup.resources.handles[i] = element->reference.handle;
NeoLKernel/drivers/acpi/scan.c:static int acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
NeoLKernel/drivers/acpi/scan.c:	status = acpi_bus_extract_wakeup_device_power_package(device, package);
NeoLKernel/drivers/acpi/scan.c:	device->wakeup.flags.valid = 1;
NeoLKernel/drivers/acpi/scan.c:	device->wakeup.prepare_count = 0;
NeoLKernel/drivers/acpi/scan.c:	/* Call _PSW/_DSW object to disable its ability to wake the sleeping
NeoLKernel/drivers/acpi/scan.c:	psw_error = acpi_device_sleep_wake(device, 0, 0, 0);
NeoLKernel/drivers/acpi/scan.c:	/* Power button, Lid switch always enable wakeup */
NeoLKernel/drivers/acpi/scan.c:		device->wakeup.flags.run_wake = 1;
NeoLKernel/drivers/acpi/scan.c:		device->flags.wake_capable = 0;
NeoLKernel/drivers/acpi/scan.c:	/* TBD: System wake support and resource requirements. */
NeoLKernel/drivers/acpi/scan.c:	/* Presence of _PRW indicates wake capable */
NeoLKernel/drivers/acpi/scan.c:		device->flags.wake_capable = 1;
NeoLKernel/drivers/acpi/scan.c:	if (device->flags.wake_capable) {
NeoLKernel/drivers/acpi/scan.c:		result = acpi_bus_get_wakeup_device_flags(device);
NeoLKernel/drivers/acpi/sleep.c:	/* do we have a wakeup address for S2 and S3? */
NeoLKernel/drivers/acpi/sleep.c:		if (!acpi_wakeup_address) {
NeoLKernel/drivers/acpi/sleep.c:				(acpi_physical_address)acpi_wakeup_address);
NeoLKernel/drivers/acpi/sleep.c:	acpi_enable_wakeup_device_prep(acpi_state);
NeoLKernel/drivers/acpi/sleep.c: *	nastiness to get the wakeup code to the waking vector.
NeoLKernel/drivers/acpi/sleep.c: *	This is called after we wake back up (or if entering the sleep state
NeoLKernel/drivers/acpi/sleep.c:	acpi_disable_wakeup_device(acpi_state);
NeoLKernel/drivers/acpi/sleep.c: * enabled and SCI_EN bit is set on wake-up from S1 - S3 sleep states.  Still,
NeoLKernel/drivers/acpi/sleep.c:	acpi_enable_wakeup_device(acpi_state);
NeoLKernel/drivers/acpi/sleep.c:	 * (like wakeup GPE) haven't handler, this can avoid such GPE misfire.
NeoLKernel/drivers/acpi/sleep.c:	.wake = acpi_pm_finish,
NeoLKernel/drivers/acpi/sleep.c:	.wake = acpi_pm_finish,
NeoLKernel/drivers/acpi/sleep.c:	acpi_enable_wakeup_device(ACPI_STATE_S4);
NeoLKernel/drivers/acpi/sleep.c: *	@dev: device to examine; its driver model wakeup flags control
NeoLKernel/drivers/acpi/sleep.c: *		whether it should be able to wake up the system
NeoLKernel/drivers/acpi/sleep.c: *	by %acpi_target_sleep_state.  If @wake is nonzero, the device should be
NeoLKernel/drivers/acpi/sleep.c: *	able to wake up the system from this sleep state.  If @d_min_p is set,
NeoLKernel/drivers/acpi/sleep.c: *	supposed to be able to wake up the system and passing this information
NeoLKernel/drivers/acpi/sleep.c: *	via @wake.
NeoLKernel/drivers/acpi/sleep.c:	 * If _PRW says we can wake up the system from the target sleep state,
NeoLKernel/drivers/acpi/sleep.c:	 * wakeup-aware driver if wake is set).  Still, if _SxW exists
NeoLKernel/drivers/acpi/sleep.c:	 * can wake the system.  _S0W may be valid, too.
NeoLKernel/drivers/acpi/sleep.c:	    (device_may_wakeup(dev) && adev->wakeup.state.enabled &&
NeoLKernel/drivers/acpi/sleep.c:	     adev->wakeup.sleep_state <= acpi_target_sleep_state)) {
NeoLKernel/drivers/acpi/sleep.c: *	acpi_pm_device_sleep_wake - enable or disable the system wake-up
NeoLKernel/drivers/acpi/sleep.c: *	@enable: 'true' - enable, 'false' - disable the wake-up capability
NeoLKernel/drivers/acpi/sleep.c:int acpi_pm_device_sleep_wake(struct device *dev, bool enable)
NeoLKernel/drivers/acpi/sleep.c:	if (!device_can_wakeup(dev))
NeoLKernel/drivers/acpi/sleep.c:		acpi_enable_wakeup_device_power(adev, acpi_target_sleep_state) :
NeoLKernel/drivers/acpi/sleep.c:		acpi_disable_wakeup_device_power(adev);
NeoLKernel/drivers/acpi/sleep.c:		dev_info(dev, "wake-up capability %s by ACPI\n",
NeoLKernel/drivers/acpi/sleep.c:	acpi_enable_wakeup_device(ACPI_STATE_S5);
NeoLKernel/drivers/acpi/sleep.h:extern void acpi_enable_wakeup_device_prep(u8 sleep_state);
NeoLKernel/drivers/acpi/sleep.h:extern void acpi_enable_wakeup_device(u8 sleep_state);
NeoLKernel/drivers/acpi/sleep.h:extern void acpi_disable_wakeup_device(u8 sleep_state);
NeoLKernel/drivers/acpi/sleep.h:extern struct list_head acpi_wakeup_device_list;
NeoLKernel/drivers/acpi/system.c:		size += sprintf(buf + size, "	wake_enabled");
NeoLKernel/drivers/acpi/wakeup.c: * wakeup.c - support wakeup devices
NeoLKernel/drivers/acpi/wakeup.c:ACPI_MODULE_NAME("wakeup_devices")
NeoLKernel/drivers/acpi/wakeup.c: * acpi_enable_wakeup_device_prep - prepare wakeup devices
NeoLKernel/drivers/acpi/wakeup.c: * Enable all wakup devices power if the devices' wakeup level
NeoLKernel/drivers/acpi/wakeup.c:void acpi_enable_wakeup_device_prep(u8 sleep_state)
NeoLKernel/drivers/acpi/wakeup.c:	list_for_each_safe(node, next, &acpi_wakeup_device_list) {
NeoLKernel/drivers/acpi/wakeup.c:						       wakeup_list);
NeoLKernel/drivers/acpi/wakeup.c:		if (!dev->wakeup.flags.valid ||
NeoLKernel/drivers/acpi/wakeup.c:		    !dev->wakeup.state.enabled ||
NeoLKernel/drivers/acpi/wakeup.c:		    (sleep_state > (u32) dev->wakeup.sleep_state))
NeoLKernel/drivers/acpi/wakeup.c:		acpi_enable_wakeup_device_power(dev, sleep_state);
NeoLKernel/drivers/acpi/wakeup.c: * acpi_enable_wakeup_device - enable wakeup devices
NeoLKernel/drivers/acpi/wakeup.c:void acpi_enable_wakeup_device(u8 sleep_state)
NeoLKernel/drivers/acpi/wakeup.c:	list_for_each_safe(node, next, &acpi_wakeup_device_list) {
NeoLKernel/drivers/acpi/wakeup.c:			container_of(node, struct acpi_device, wakeup_list);
NeoLKernel/drivers/acpi/wakeup.c:		if (!dev->wakeup.flags.valid)
NeoLKernel/drivers/acpi/wakeup.c:		/* If users want to disable run-wake GPE,
NeoLKernel/drivers/acpi/wakeup.c:		 * we only disable it for wake and leave it for runtime
NeoLKernel/drivers/acpi/wakeup.c:		if ((!dev->wakeup.state.enabled && !dev->wakeup.prepare_count)
NeoLKernel/drivers/acpi/wakeup.c:		    || sleep_state > (u32) dev->wakeup.sleep_state) {
NeoLKernel/drivers/acpi/wakeup.c:			if (dev->wakeup.flags.run_wake) {
NeoLKernel/drivers/acpi/wakeup.c:				acpi_set_gpe_type(dev->wakeup.gpe_device,
NeoLKernel/drivers/acpi/wakeup.c:						  dev->wakeup.gpe_number,
NeoLKernel/drivers/acpi/wakeup.c:		if (!dev->wakeup.flags.run_wake)
NeoLKernel/drivers/acpi/wakeup.c:			acpi_enable_gpe(dev->wakeup.gpe_device,
NeoLKernel/drivers/acpi/wakeup.c:					dev->wakeup.gpe_number);
NeoLKernel/drivers/acpi/wakeup.c: * acpi_disable_wakeup_device - disable devices' wakeup capability
NeoLKernel/drivers/acpi/wakeup.c: * Disable all wakup devices's GPE and wakeup capability
NeoLKernel/drivers/acpi/wakeup.c:void acpi_disable_wakeup_device(u8 sleep_state)
NeoLKernel/drivers/acpi/wakeup.c:	list_for_each_safe(node, next, &acpi_wakeup_device_list) {
NeoLKernel/drivers/acpi/wakeup.c:			container_of(node, struct acpi_device, wakeup_list);
NeoLKernel/drivers/acpi/wakeup.c:		if (!dev->wakeup.flags.valid)
NeoLKernel/drivers/acpi/wakeup.c:		if ((!dev->wakeup.state.enabled && !dev->wakeup.prepare_count)
NeoLKernel/drivers/acpi/wakeup.c:		    || sleep_state > (u32) dev->wakeup.sleep_state) {
NeoLKernel/drivers/acpi/wakeup.c:			if (dev->wakeup.flags.run_wake) {
NeoLKernel/drivers/acpi/wakeup.c:				acpi_set_gpe_type(dev->wakeup.gpe_device,
NeoLKernel/drivers/acpi/wakeup.c:						  dev->wakeup.gpe_number,
NeoLKernel/drivers/acpi/wakeup.c:				acpi_enable_gpe(dev->wakeup.gpe_device,
NeoLKernel/drivers/acpi/wakeup.c:						dev->wakeup.gpe_number);
NeoLKernel/drivers/acpi/wakeup.c:		acpi_disable_wakeup_device_power(dev);
NeoLKernel/drivers/acpi/wakeup.c:		/* Never disable run-wake GPE */
NeoLKernel/drivers/acpi/wakeup.c:		if (!dev->wakeup.flags.run_wake) {
NeoLKernel/drivers/acpi/wakeup.c:			acpi_disable_gpe(dev->wakeup.gpe_device,
NeoLKernel/drivers/acpi/wakeup.c:					 dev->wakeup.gpe_number);
NeoLKernel/drivers/acpi/wakeup.c:			acpi_clear_gpe(dev->wakeup.gpe_device,
NeoLKernel/drivers/acpi/wakeup.c:				       dev->wakeup.gpe_number, ACPI_NOT_ISR);
NeoLKernel/drivers/acpi/wakeup.c:int __init acpi_wakeup_device_init(void)
NeoLKernel/drivers/acpi/wakeup.c:	list_for_each_safe(node, next, &acpi_wakeup_device_list) {
NeoLKernel/drivers/acpi/wakeup.c:						       wakeup_list);
NeoLKernel/drivers/acpi/wakeup.c:		if (!dev->wakeup.flags.run_wake || dev->wakeup.state.enabled)
NeoLKernel/drivers/acpi/wakeup.c:		acpi_set_gpe_type(dev->wakeup.gpe_device,
NeoLKernel/drivers/acpi/wakeup.c:				  dev->wakeup.gpe_number,
NeoLKernel/drivers/acpi/wakeup.c:		acpi_enable_gpe(dev->wakeup.gpe_device,
NeoLKernel/drivers/acpi/wakeup.c:				dev->wakeup.gpe_number);
NeoLKernel/drivers/acpi/wakeup.c:		dev->wakeup.state.enabled = 1;
NeoLKernel/drivers/ata/ahci.c:	/* wake up link */
NeoLKernel/drivers/ata/ata_piix.c:	 * controller to be awake on entry; otherwise, it burns cpu
NeoLKernel/drivers/ata/libata-core.c:	/* issue phy wake/reset */
NeoLKernel/drivers/ata/libata-eh.c:	wake_up_all(&ap->eh_wait_q);
NeoLKernel/drivers/ata/libata-eh.c:		 * controller state is undefined.  Reset also wakes up
NeoLKernel/drivers/atm/atmtcp.c:	wake_up(sk_atm(vcc)->sk_sleep);
NeoLKernel/drivers/atm/eni.c:	wake_up(&eni_dev->rx_wait);
NeoLKernel/drivers/atm/eni.c:		wake_up(&eni_dev->tx_wait);
NeoLKernel/drivers/atm/eni.c:		wake_up(&eni_dev->tx_wait);
NeoLKernel/drivers/atm/firestream.c:				wake_up_interruptible (& FS_VCC (ATM_SKB(skb)->vcc)->close_wait);
NeoLKernel/drivers/atm/he.c:			HPRINTK("wake_up rx_waitq  (cid 0x%x)\n", cid);
NeoLKernel/drivers/atm/he.c:			wake_up(&he_vcc->rx_waitq);
NeoLKernel/drivers/atm/he.c:			HPRINTK("wake_up(tx_waitq) cid 0x%x\n",
NeoLKernel/drivers/atm/he.c:				wake_up(&HE_VCC(tpd->vcc)->tx_waitq);
NeoLKernel/drivers/atm/horizon.c:  wake_up_interruptible (&dev->tx_queue);
NeoLKernel/drivers/atm/horizon.c:  // wake Serial EEPROM and send 110 (READ) command
NeoLKernel/drivers/atm/iphase.c:               wake_up(&iadev->close_wait);
NeoLKernel/drivers/atm/iphase.c:                    wake_up(&ia_dev[i]->close_wait);
NeoLKernel/drivers/atm/nicstar.c:         wake_up_interruptible(&(scq->scqfull_waitq));
NeoLKernel/drivers/atm/solos-pci.c:			wake_up(&card->param_wq);
NeoLKernel/drivers/atm/solos-pci.c:		wake_up(&card->fw_wq);
NeoLKernel/drivers/atm/zatm.c:	wake_up(&zatm_vcc->tx_wait);
NeoLKernel/drivers/base/genlock.c:		wake_up(&lock->queue);
NeoLKernel/drivers/base/genlock.c:		 * then wake up any pending waiters in case they want a read
NeoLKernel/drivers/base/genlock.c:			wake_up(&lock->queue);
NeoLKernel/drivers/base/power/main.c:		((state.event & PM_EVENT_SLEEP) && device_may_wakeup(dev)) ?
NeoLKernel/drivers/base/power/main.c:		", may wakeup" : "");
NeoLKernel/drivers/base/power/main.c:		if (pm_runtime_barrier(dev) && device_may_wakeup(dev)) {
NeoLKernel/drivers/base/power/runtime.c:	wake_up_all(&dev->power.wait_queue);
NeoLKernel/drivers/base/power/runtime.c:	wake_up_all(&dev->power.wait_queue);
NeoLKernel/drivers/base/power/runtime.c:	wake_up_all(&dev->power.wait_queue);
NeoLKernel/drivers/base/power/runtime.c: * __pm_runtime_get - Reference count a device and wake it up, if necessary.
NeoLKernel/drivers/base/power/runtime.c:		/* Suspend, wake-up or idle notification in progress. */
NeoLKernel/drivers/base/power/runtime.c: * if there's a pending resume request for the device, wake the device up.
NeoLKernel/drivers/base/power/runtime.c: * function will wake up the device before disabling its run-time PM.
NeoLKernel/drivers/base/power/sysfs.c: *	wakeup - Report/change current wakeup option for device
NeoLKernel/drivers/base/power/sysfs.c: *	Some devices support "wakeup" events, which are hardware signals
NeoLKernel/drivers/base/power/sysfs.c: *	devices have one of three values for the sysfs power/wakeup file:
NeoLKernel/drivers/base/power/sysfs.c: *	 + "\n" for temporary or permanent inability to issue wakeup.
NeoLKernel/drivers/base/power/sysfs.c: *	(For example, unconfigured USB devices can't issue wakeups.)
NeoLKernel/drivers/base/power/sysfs.c: *	Familiar examples of devices that can issue wakeup events include
NeoLKernel/drivers/base/power/sysfs.c: *	will wake the entire system from a suspend state; others may just
NeoLKernel/drivers/base/power/sysfs.c: *	wake up the device (if the system as a whole is already active).
NeoLKernel/drivers/base/power/sysfs.c: *	Some wakeup events use normal IRQ lines; other use special out
NeoLKernel/drivers/base/power/sysfs.c: *	wakeup signaling as part of changing device power states, respecting
NeoLKernel/drivers/base/power/sysfs.c: *	Devices may not be able to generate wakeup events from all power
NeoLKernel/drivers/base/power/sysfs.c: *	active, or which may have wakeup disabled.  Some drivers rely on
NeoLKernel/drivers/base/power/sysfs.c: *	wakeup events internally (unless they are disabled), keeping
NeoLKernel/drivers/base/power/sysfs.c:wake_show(struct device * dev, struct device_attribute *attr, char * buf)
NeoLKernel/drivers/base/power/sysfs.c:	return sprintf(buf, "%s\n", device_can_wakeup(dev)
NeoLKernel/drivers/base/power/sysfs.c:		? (device_may_wakeup(dev) ? enabled : disabled)
NeoLKernel/drivers/base/power/sysfs.c:wake_store(struct device * dev, struct device_attribute *attr,
NeoLKernel/drivers/base/power/sysfs.c:	if (!device_can_wakeup(dev))
NeoLKernel/drivers/base/power/sysfs.c:		device_set_wakeup_enable(dev, 1);
NeoLKernel/drivers/base/power/sysfs.c:		device_set_wakeup_enable(dev, 0);
NeoLKernel/drivers/base/power/sysfs.c:static DEVICE_ATTR(wakeup, 0644, wake_show, wake_store);
NeoLKernel/drivers/base/power/sysfs.c:	&dev_attr_wakeup.attr,
NeoLKernel/drivers/base/sys.c:	pr_debug("Checking wake-up interrupts\n");
NeoLKernel/drivers/base/sys.c:	/* Return error code if there are any wake-up interrupts pending */
NeoLKernel/drivers/base/sys.c:	ret = check_wakeup_irqs();
NeoLKernel/drivers/base/core.c:	device_init_wakeup(dev, 0);
NeoLKernel/drivers/base/dd.c:	wake_up(&probe_waitqueue);
NeoLKernel/drivers/block/mg_disk.c:	/* wait until mflash wakeup */
NeoLKernel/drivers/block/amiflop.c:		wake_up(&fdc_wait);
NeoLKernel/drivers/block/amiflop.c:		wake_up (&wait_fd_block);
NeoLKernel/drivers/block/amiflop.c:	wake_up(&wait_fd_block);
NeoLKernel/drivers/block/ataflop.c:		wake_up( &format_wait );
NeoLKernel/drivers/block/ataflop.c:	wake_up( &format_wait );
NeoLKernel/drivers/block/ataflop.c:	wake_up( &fdc_wait );
NeoLKernel/drivers/block/cciss.c:	wake_up_process(cciss_scan_thread);
NeoLKernel/drivers/block/cciss.c:		wake_up_process(cciss_scan_thread);
NeoLKernel/drivers/block/DAC960.c:  DAC960_WaitForCommand waits for a wake_up on Controller's Command Wait Queue.
NeoLKernel/drivers/block/DAC960.c:  wake_up(&Controller->CommandWaitQueue);
NeoLKernel/drivers/block/DAC960.c:  wake_up(&Controller->CommandWaitQueue);
NeoLKernel/drivers/block/DAC960.c:      wake_up(&Controller->HealthStatusWaitQueue);
NeoLKernel/drivers/block/floppy.c:	wake_up(&fdc_wait);
NeoLKernel/drivers/block/floppy.c:static void do_wakeup(void)
NeoLKernel/drivers/block/floppy.c:	reschedule_timeout(MAXTIMEOUT, "do wakeup", 0);
NeoLKernel/drivers/block/floppy.c:	wake_up(&command_done);
NeoLKernel/drivers/block/floppy.c:static struct cont_t wakeup_cont = {
NeoLKernel/drivers/block/floppy.c:	.redo		= do_wakeup,
NeoLKernel/drivers/block/floppy.c:	cont = &wakeup_cont;
NeoLKernel/drivers/block/floppy.c:static void success_and_wakeup(void)
NeoLKernel/drivers/block/floppy.c:	.interrupt	= success_and_wakeup,
NeoLKernel/drivers/block/floppy.c:	.redo		= success_and_wakeup,
NeoLKernel/drivers/block/floppy.c:	.interrupt	= success_and_wakeup,
NeoLKernel/drivers/block/loop.c:	wake_up(&lo->lo_event);
NeoLKernel/drivers/block/loop.c:	wake_up_process(lo->lo_thread);
NeoLKernel/drivers/block/nbd.c:	wake_up_all(&lo->active_wq);
NeoLKernel/drivers/block/nbd.c:		wake_up(&lo->waiting_wq);
NeoLKernel/drivers/block/nbd.c:		wake_up_process(thread);
NeoLKernel/drivers/block/paride/kbic.c:	The chips are almost identical, however, the wakeup code 
NeoLKernel/drivers/block/paride/paride.c:static void pi_wake_up(void *p)
NeoLKernel/drivers/block/paride/paride.c:	wake_up(&(pi->parq));
NeoLKernel/drivers/block/paride/paride.c:					     pi_wake_up, NULL, 0, (void *) pi);
NeoLKernel/drivers/block/paride/Transition-notes:	* in pi_wake_up() called for PIA that belongs to pd.c, everything from
NeoLKernel/drivers/block/paride/Transition-notes:	   case that needs consideration is call from pi_wake_up() and there
NeoLKernel/drivers/block/paride/Transition-notes:	f) pi_wake_up() can enter the area only when the thread is holding
NeoLKernel/drivers/block/pktcdvd.c:		wake_up(&pd->wqueue);
NeoLKernel/drivers/block/pktcdvd.c:	wake_up(&pd->wqueue);
NeoLKernel/drivers/block/pktcdvd.c:		wake_up(&pd->wqueue);
NeoLKernel/drivers/block/pktcdvd.c:	wake_up(&pd->wqueue);
NeoLKernel/drivers/block/pktcdvd.c:	int wakeup;
NeoLKernel/drivers/block/pktcdvd.c:	   below, wake up any waiters */
NeoLKernel/drivers/block/pktcdvd.c:	wakeup = (pd->write_congestion_on > 0
NeoLKernel/drivers/block/pktcdvd.c:	if (wakeup) {
NeoLKernel/drivers/block/pktcdvd.c:			VPRINTK("kcdrwd: wake up\n");
NeoLKernel/drivers/block/pktcdvd.c:					wake_up(&pd->wqueue);
NeoLKernel/drivers/block/pktcdvd.c:		/* This wake_up is required for correct operation */
NeoLKernel/drivers/block/pktcdvd.c:		wake_up(&pd->wqueue);
NeoLKernel/drivers/block/pktcdvd.c:		 * This wake up is not required for correct operation,
NeoLKernel/drivers/block/pktcdvd.c:		wake_up(&pd->wqueue);
NeoLKernel/drivers/block/swim3.c:		wake_up(&fs->wait);
NeoLKernel/drivers/block/ub.c:	wake_up(&sc->reset_wait);
NeoLKernel/drivers/block/viodasd.c:		 * completion to wake up the guy who sent the request
NeoLKernel/drivers/block/xd.c:		wake_up(&xd_wait_int);	/* and wake up sleeping processes */
NeoLKernel/drivers/block/xd.c:	wake_up(&xd_wait_int);
NeoLKernel/drivers/block/xsysace.c:	 * bail out back to the idle state and wake up all the waiters */
NeoLKernel/drivers/bluetooth/bfusb.c:static void bfusb_tx_wakeup(struct bfusb_data *data)
NeoLKernel/drivers/bluetooth/bfusb.c:	bfusb_tx_wakeup(data);
NeoLKernel/drivers/bluetooth/bfusb.c:	bfusb_tx_wakeup(data);
NeoLKernel/drivers/bluetooth/bluecard_cs.c:static void bluecard_write_wakeup(bluecard_info_t *info)
NeoLKernel/drivers/bluetooth/bluecard_cs.c:					bluecard_write_wakeup(info);
NeoLKernel/drivers/bluetooth/bluecard_cs.c:			bluecard_write_wakeup(info);
NeoLKernel/drivers/bluetooth/bluecard_cs.c:			bluecard_write_wakeup(info);
NeoLKernel/drivers/bluetooth/bluecard_cs.c:	bluecard_write_wakeup(info);
NeoLKernel/drivers/bluetooth/bluecard_cs.c:	bluecard_write_wakeup(info);
NeoLKernel/drivers/bluetooth/bluesleep.c:	unsigned host_wake;
NeoLKernel/drivers/bluetooth/bluesleep.c:	unsigned ext_wake;
NeoLKernel/drivers/bluetooth/bluesleep.c:	unsigned host_wake_irq;
NeoLKernel/drivers/bluetooth/bluesleep.c:/** Tasklet to respond to change in hostwake line */
NeoLKernel/drivers/bluetooth/bluesleep.c:static struct tasklet_struct hostwake_task;
NeoLKernel/drivers/bluetooth/bluesleep.c:	return gpio_get_value(bsi->ext_wake) &&
NeoLKernel/drivers/bluetooth/bluesleep.c:		gpio_get_value(bsi->host_wake) &&
NeoLKernel/drivers/bluetooth/bluesleep.c:void bluesleep_sleep_wakeup(void)
NeoLKernel/drivers/bluetooth/bluesleep.c:		gpio_set_value(bsi->ext_wake, 0);
NeoLKernel/drivers/bluetooth/bluesleep.c:		bluesleep_sleep_wakeup();
NeoLKernel/drivers/bluetooth/bluesleep.c:static void bluesleep_hostwake_task(unsigned long data)
NeoLKernel/drivers/bluetooth/bluesleep.c:	BT_DBG("hostwake line change");
NeoLKernel/drivers/bluetooth/bluesleep.c:	if (gpio_get_value(bsi->host_wake))
NeoLKernel/drivers/bluetooth/bluesleep.c:	if (gpio_get_value(bsi->ext_wake)) {
NeoLKernel/drivers/bluetooth/bluesleep.c:		bluesleep_sleep_wakeup();
NeoLKernel/drivers/bluetooth/bluesleep.c:		gpio_set_value(bsi->ext_wake, 1);
NeoLKernel/drivers/bluetooth/bluesleep.c:static irqreturn_t bluesleep_hostwake_isr(int irq, void *dev_id)
NeoLKernel/drivers/bluetooth/bluesleep.c:	/* schedule a tasklet to handle the change in the host wake line */
NeoLKernel/drivers/bluetooth/bluesleep.c:	tasklet_schedule(&hostwake_task);
NeoLKernel/drivers/bluetooth/bluesleep.c:	gpio_set_value(bsi->ext_wake, 0);
NeoLKernel/drivers/bluetooth/bluesleep.c:	retval = request_irq(bsi->host_wake_irq, bluesleep_hostwake_isr,
NeoLKernel/drivers/bluetooth/bluesleep.c:				"bluetooth hostwake", NULL);
NeoLKernel/drivers/bluetooth/bluesleep.c:	retval = enable_irq_wake(bsi->host_wake_irq);
NeoLKernel/drivers/bluetooth/bluesleep.c:		BT_ERR("Couldn't enable BT_HOST_WAKE as wakeup interrupt");
NeoLKernel/drivers/bluetooth/bluesleep.c:		free_irq(bsi->host_wake_irq, NULL);
NeoLKernel/drivers/bluetooth/bluesleep.c:	gpio_set_value(bsi->ext_wake, 0);
NeoLKernel/drivers/bluetooth/bluesleep.c:	if (disable_irq_wake(bsi->host_wake_irq))
NeoLKernel/drivers/bluetooth/bluesleep.c:		BT_ERR("Couldn't disable hostwake IRQ wakeup mode\n");
NeoLKernel/drivers/bluetooth/bluesleep.c:	free_irq(bsi->host_wake_irq, NULL);
NeoLKernel/drivers/bluetooth/bluesleep.c:static int bluepower_read_proc_btwake(char *page, char **start, off_t offset,
NeoLKernel/drivers/bluetooth/bluesleep.c:	return sprintf(page, "btwake:%u\n", gpio_get_value(bsi->ext_wake));
NeoLKernel/drivers/bluetooth/bluesleep.c:static int bluepower_write_proc_btwake(struct file *file, const char *buffer,
NeoLKernel/drivers/bluetooth/bluesleep.c:		gpio_set_value(bsi->ext_wake, 0);
NeoLKernel/drivers/bluetooth/bluesleep.c:		gpio_set_value(bsi->ext_wake, 1);
NeoLKernel/drivers/bluetooth/bluesleep.c:static int bluepower_read_proc_hostwake(char *page, char **start, off_t offset,
NeoLKernel/drivers/bluetooth/bluesleep.c:	return sprintf(page, "hostwake: %u \n", gpio_get_value(bsi->host_wake));
NeoLKernel/drivers/bluetooth/bluesleep.c:				"gpio_host_wake");
NeoLKernel/drivers/bluetooth/bluesleep.c:		BT_ERR("couldn't find host_wake gpio\n");
NeoLKernel/drivers/bluetooth/bluesleep.c:	bsi->host_wake = res->start;
NeoLKernel/drivers/bluetooth/bluesleep.c:	ret = gpio_request(bsi->host_wake, "bt_host_wake");
NeoLKernel/drivers/bluetooth/bluesleep.c:	ret = gpio_direction_input(bsi->host_wake);
NeoLKernel/drivers/bluetooth/bluesleep.c:		goto free_bt_host_wake;
NeoLKernel/drivers/bluetooth/bluesleep.c:				"gpio_ext_wake");
NeoLKernel/drivers/bluetooth/bluesleep.c:		BT_ERR("couldn't find ext_wake gpio\n");
NeoLKernel/drivers/bluetooth/bluesleep.c:		goto free_bt_host_wake;
NeoLKernel/drivers/bluetooth/bluesleep.c:	bsi->ext_wake = res->start;
NeoLKernel/drivers/bluetooth/bluesleep.c:	ret = gpio_request(bsi->ext_wake, "bt_ext_wake");
NeoLKernel/drivers/bluetooth/bluesleep.c:		goto free_bt_host_wake;
NeoLKernel/drivers/bluetooth/bluesleep.c:	/* assert bt wake */
NeoLKernel/drivers/bluetooth/bluesleep.c:	ret = gpio_direction_output(bsi->ext_wake, 0);
NeoLKernel/drivers/bluetooth/bluesleep.c:		goto free_bt_ext_wake;
NeoLKernel/drivers/bluetooth/bluesleep.c:	bsi->host_wake_irq = platform_get_irq_byname(pdev, "host_wake");
NeoLKernel/drivers/bluetooth/bluesleep.c:	if (bsi->host_wake_irq < 0) {
NeoLKernel/drivers/bluetooth/bluesleep.c:		BT_ERR("couldn't find host_wake irq\n");
NeoLKernel/drivers/bluetooth/bluesleep.c:		goto free_bt_ext_wake;
NeoLKernel/drivers/bluetooth/bluesleep.c:free_bt_ext_wake:
NeoLKernel/drivers/bluetooth/bluesleep.c:	gpio_free(bsi->ext_wake);
NeoLKernel/drivers/bluetooth/bluesleep.c:free_bt_host_wake:
NeoLKernel/drivers/bluetooth/bluesleep.c:	gpio_free(bsi->host_wake);
NeoLKernel/drivers/bluetooth/bluesleep.c:	/* assert bt wake */
NeoLKernel/drivers/bluetooth/bluesleep.c:	gpio_set_value(bsi->ext_wake, 0);
NeoLKernel/drivers/bluetooth/bluesleep.c:		if (disable_irq_wake(bsi->host_wake_irq))
NeoLKernel/drivers/bluetooth/bluesleep.c:			BT_ERR("Couldn't disable hostwake IRQ wakeup mode \n");
NeoLKernel/drivers/bluetooth/bluesleep.c:		free_irq(bsi->host_wake_irq, NULL);
NeoLKernel/drivers/bluetooth/bluesleep.c:	gpio_free(bsi->host_wake);
NeoLKernel/drivers/bluetooth/bluesleep.c:	gpio_free(bsi->ext_wake);
NeoLKernel/drivers/bluetooth/bluesleep.c:	/* Creating read/write "btwake" entry */
NeoLKernel/drivers/bluetooth/bluesleep.c:	ent = create_proc_entry("btwake", 0, sleep_dir);
NeoLKernel/drivers/bluetooth/bluesleep.c:		BT_ERR("Unable to create /proc/%s/btwake entry", PROC_DIR);
NeoLKernel/drivers/bluetooth/bluesleep.c:	ent->read_proc = bluepower_read_proc_btwake;
NeoLKernel/drivers/bluetooth/bluesleep.c:	ent->write_proc = bluepower_write_proc_btwake;
NeoLKernel/drivers/bluetooth/bluesleep.c:	if (create_proc_read_entry("hostwake", 0, sleep_dir,
NeoLKernel/drivers/bluetooth/bluesleep.c:				bluepower_read_proc_hostwake, NULL) == NULL) {
NeoLKernel/drivers/bluetooth/bluesleep.c:		BT_ERR("Unable to create /proc/%s/hostwake entry", PROC_DIR);
NeoLKernel/drivers/bluetooth/bluesleep.c:	/* initialize host wake tasklet */
NeoLKernel/drivers/bluetooth/bluesleep.c:	tasklet_init(&hostwake_task, bluesleep_hostwake_task, 0);
NeoLKernel/drivers/bluetooth/bluesleep.c:	remove_proc_entry("hostwake", sleep_dir);
NeoLKernel/drivers/bluetooth/bluesleep.c:	remove_proc_entry("btwake", sleep_dir);
NeoLKernel/drivers/bluetooth/bluesleep.c:	remove_proc_entry("hostwake", sleep_dir);
NeoLKernel/drivers/bluetooth/bluesleep.c:	remove_proc_entry("btwake", sleep_dir);
NeoLKernel/drivers/bluetooth/bt3c_cs.c:static void bt3c_write_wakeup(bt3c_info_t *info)
NeoLKernel/drivers/bluetooth/bt3c_cs.c:				bt3c_write_wakeup(info);
NeoLKernel/drivers/bluetooth/bt3c_cs.c:	bt3c_write_wakeup(info);
NeoLKernel/drivers/bluetooth/btmrvl_debugfs.c:		wake_up_interruptible(&priv->main_thread.wait_q);
NeoLKernel/drivers/bluetooth/btmrvl_debugfs.c:		wake_up_interruptible(&priv->main_thread.wait_q);
NeoLKernel/drivers/bluetooth/btmrvl_debugfs.c:		wake_up_interruptible(&priv->main_thread.wait_q);
NeoLKernel/drivers/bluetooth/btmrvl_drv.h:	u8 wakeup_tries;
NeoLKernel/drivers/bluetooth/btmrvl_drv.h:	int (*hw_wakeup_firmware) (struct btmrvl_private *priv);
NeoLKernel/drivers/bluetooth/btmrvl_main.c: * It updates Power Save & Host Sleep states, and wakes up the main
NeoLKernel/drivers/bluetooth/btmrvl_main.c:	priv->adapter->wakeup_tries = 0;
NeoLKernel/drivers/bluetooth/btmrvl_main.c:	wake_up_interruptible(&priv->main_thread.wait_q);
NeoLKernel/drivers/bluetooth/btmrvl_main.c:			wake_up_interruptible(&priv->adapter->cmd_wait_q);
NeoLKernel/drivers/bluetooth/btmrvl_main.c:			wake_up_interruptible(&adapter->cmd_wait_q);
NeoLKernel/drivers/bluetooth/btmrvl_main.c:	wake_up_interruptible(&priv->main_thread.wait_q);
NeoLKernel/drivers/bluetooth/btmrvl_main.c:	wake_up_interruptible(&priv->main_thread.wait_q);
NeoLKernel/drivers/bluetooth/btmrvl_main.c:						priv->adapter->wakeup_tries);
NeoLKernel/drivers/bluetooth/btmrvl_main.c:			ret = priv->hw_wakeup_firmware(priv);
NeoLKernel/drivers/bluetooth/btmrvl_main.c:	wake_up_interruptible(&priv->main_thread.wait_q);
NeoLKernel/drivers/bluetooth/btmrvl_main.c:		if (adapter->wakeup_tries ||
NeoLKernel/drivers/bluetooth/btmrvl_main.c:			adapter->wakeup_tries++;
NeoLKernel/drivers/bluetooth/btmrvl_main.c:			priv->hw_wakeup_firmware(priv);
NeoLKernel/drivers/bluetooth/btmrvl_main.c:	wake_up_interruptible(&priv->adapter->cmd_wait_q);
NeoLKernel/drivers/bluetooth/btmrvl_sdio.c:static int btmrvl_sdio_wakeup_fw(struct btmrvl_private *priv)
NeoLKernel/drivers/bluetooth/btmrvl_sdio.c:	BT_DBG("wake up firmware");
NeoLKernel/drivers/bluetooth/btmrvl_sdio.c:	priv->hw_wakeup_firmware = btmrvl_sdio_wakeup_fw;
NeoLKernel/drivers/bluetooth/btuart_cs.c:static void btuart_write_wakeup(btuart_info_t *info)
NeoLKernel/drivers/bluetooth/btuart_cs.c:				btuart_write_wakeup(info);
NeoLKernel/drivers/bluetooth/btuart_cs.c:	btuart_write_wakeup(info);
NeoLKernel/drivers/bluetooth/btusb.c:	struct work_struct waker;
NeoLKernel/drivers/bluetooth/btusb.c:	data->intf->needs_remote_wakeup = 1;
NeoLKernel/drivers/bluetooth/btusb.c:	cancel_work_sync(&data->waker);
NeoLKernel/drivers/bluetooth/btusb.c:	data->intf->needs_remote_wakeup = 0;
NeoLKernel/drivers/bluetooth/btusb.c:		schedule_work(&data->waker);
NeoLKernel/drivers/bluetooth/btusb.c:static void btusb_waker(struct work_struct *work)
NeoLKernel/drivers/bluetooth/btusb.c:	struct btusb_data *data = container_of(work, struct btusb_data, waker);
NeoLKernel/drivers/bluetooth/btusb.c:	INIT_WORK(&data->waker, btusb_waker);
NeoLKernel/drivers/bluetooth/dtl1_cs.c:static void dtl1_write_wakeup(dtl1_info_t *info)
NeoLKernel/drivers/bluetooth/dtl1_cs.c:		dtl1_write_wakeup(info);
NeoLKernel/drivers/bluetooth/dtl1_cs.c:				dtl1_write_wakeup(info);
NeoLKernel/drivers/bluetooth/dtl1_cs.c:		dtl1_write_wakeup(info);
NeoLKernel/drivers/bluetooth/dtl1_cs.c:	dtl1_write_wakeup(info);
NeoLKernel/drivers/bluetooth/hci_bcsp.c:		hci_uart_tx_wakeup(hu);
NeoLKernel/drivers/bluetooth/hci_bcsp.c:		hci_uart_tx_wakeup(hu);
NeoLKernel/drivers/bluetooth/hci_bcsp.c:	hci_uart_tx_wakeup(hu);
NeoLKernel/drivers/bluetooth/hci_ibs.c:static unsigned long wake_retrans = 1;
NeoLKernel/drivers/bluetooth/hci_ibs.c:	struct	timer_list wake_retrans_timer;
NeoLKernel/drivers/bluetooth/hci_ibs.c:	unsigned long ibs_sent_wakes;
NeoLKernel/drivers/bluetooth/hci_ibs.c:	unsigned long ibs_recv_wakes;
NeoLKernel/drivers/bluetooth/hci_ibs.c:	hci_uart_tx_wakeup(hu);  /* run HCI tx handling unlocked */
NeoLKernel/drivers/bluetooth/hci_ibs.c:static void hci_ibs_wake_retrans_timeout(unsigned long arg)
NeoLKernel/drivers/bluetooth/hci_ibs.c:	BT_DBG("hu %p wake retransmit timeout in %lu state",
NeoLKernel/drivers/bluetooth/hci_ibs.c:			BT_ERR("cannot acknowledge device wake up");
NeoLKernel/drivers/bluetooth/hci_ibs.c:		ibs->ibs_sent_wakes++; /* debug */
NeoLKernel/drivers/bluetooth/hci_ibs.c:		mod_timer(&ibs->wake_retrans_timer, jiffies + wake_retrans);
NeoLKernel/drivers/bluetooth/hci_ibs.c:		hci_uart_tx_wakeup(hu);
NeoLKernel/drivers/bluetooth/hci_ibs.c:	/* Assume we start with both sides asleep -- extra wakes OK */
NeoLKernel/drivers/bluetooth/hci_ibs.c:	ibs->ibs_sent_wakes = 0;
NeoLKernel/drivers/bluetooth/hci_ibs.c:	ibs->ibs_recv_wakes = 0;
NeoLKernel/drivers/bluetooth/hci_ibs.c:	init_timer(&ibs->wake_retrans_timer);
NeoLKernel/drivers/bluetooth/hci_ibs.c:	ibs->wake_retrans_timer.function = hci_ibs_wake_retrans_timeout;
NeoLKernel/drivers/bluetooth/hci_ibs.c:	ibs->wake_retrans_timer.data     = (u_long) hu;
NeoLKernel/drivers/bluetooth/hci_ibs.c:	BT_INFO("HCI_IBS open, tx_idle_delay=%lu, wake_retrans=%lu",
NeoLKernel/drivers/bluetooth/hci_ibs.c:		tx_idle_delay, wake_retrans);
NeoLKernel/drivers/bluetooth/hci_ibs.c:	BT_INFO("HCI_IBS stats: tx_idle_delay=%lu, wake_retrans=%lu",
NeoLKernel/drivers/bluetooth/hci_ibs.c:		tx_idle_delay, wake_retrans);
NeoLKernel/drivers/bluetooth/hci_ibs.c:	BT_INFO("HCI_IBS stats: sent: sleep=%lu, wake=%lu, wake_ack=%lu",
NeoLKernel/drivers/bluetooth/hci_ibs.c:		ibs->ibs_sent_slps, ibs->ibs_sent_wakes, ibs->ibs_sent_wacks);
NeoLKernel/drivers/bluetooth/hci_ibs.c:	BT_INFO("HCI_IBS stats: recv: sleep=%lu, wake=%lu, wake_ack=%lu",
NeoLKernel/drivers/bluetooth/hci_ibs.c:		ibs->ibs_recv_slps, ibs->ibs_recv_wakes, ibs->ibs_recv_wacks);
NeoLKernel/drivers/bluetooth/hci_ibs.c:	del_timer(&ibs->wake_retrans_timer);
NeoLKernel/drivers/bluetooth/hci_ibs.c: * Called upon a wake-up-indication from the device
NeoLKernel/drivers/bluetooth/hci_ibs.c:static void ibs_device_want_to_wakeup(struct hci_uart *hu)
NeoLKernel/drivers/bluetooth/hci_ibs.c:	ibs->ibs_recv_wakes++;
NeoLKernel/drivers/bluetooth/hci_ibs.c:		 * receiving the wake up indicator
NeoLKernel/drivers/bluetooth/hci_ibs.c:		/* Always acknowledge device wake up,
NeoLKernel/drivers/bluetooth/hci_ibs.c:			BT_ERR("cannot acknowledge device wake up");
NeoLKernel/drivers/bluetooth/hci_ibs.c:	hci_uart_tx_wakeup(hu);
NeoLKernel/drivers/bluetooth/hci_ibs.c: * Called upon wake-up-acknowledgement from the device
NeoLKernel/drivers/bluetooth/hci_ibs.c:		/* This could be spurrious rx wake on the BT chip.
NeoLKernel/drivers/bluetooth/hci_ibs.c:		 * Send it another SLEEP othwise it will stay awake. */
NeoLKernel/drivers/bluetooth/hci_ibs.c:		del_timer(&ibs->wake_retrans_timer);
NeoLKernel/drivers/bluetooth/hci_ibs.c:	hci_uart_tx_wakeup(hu);
NeoLKernel/drivers/bluetooth/hci_ibs.c:		BT_DBG("device awake, sending normally");
NeoLKernel/drivers/bluetooth/hci_ibs.c:		/* awake device */
NeoLKernel/drivers/bluetooth/hci_ibs.c:		ibs->ibs_sent_wakes++; /* debug */
NeoLKernel/drivers/bluetooth/hci_ibs.c:		mod_timer(&ibs->wake_retrans_timer, jiffies + wake_retrans);
NeoLKernel/drivers/bluetooth/hci_ibs.c:			ibs_device_want_to_wakeup(hu);
NeoLKernel/drivers/bluetooth/hci_ibs.c:module_param(wake_retrans, ulong, 0644);
NeoLKernel/drivers/bluetooth/hci_ibs.c:MODULE_PARM_DESC(wake_retrans, "Delay (1/HZ) to retransmit WAKE_IND");
NeoLKernel/drivers/bluetooth/hci_ldisc.c:int hci_uart_tx_wakeup(struct hci_uart *hu)
NeoLKernel/drivers/bluetooth/hci_ldisc.c:	hci_uart_tx_wakeup(hu);
NeoLKernel/drivers/bluetooth/hci_ldisc.c:/* hci_uart_tty_wakeup()
NeoLKernel/drivers/bluetooth/hci_ldisc.c: *    Callback for transmit wakeup. Called when low level
NeoLKernel/drivers/bluetooth/hci_ldisc.c:static void hci_uart_tty_wakeup(struct tty_struct *tty)
NeoLKernel/drivers/bluetooth/hci_ldisc.c:		hci_uart_tx_wakeup(hu);
NeoLKernel/drivers/bluetooth/hci_ldisc.c:	hci_uart_ldisc.write_wakeup	= hci_uart_tty_wakeup;
NeoLKernel/drivers/bluetooth/hci_ll.c: * internal function, which does common work of the device wake up process:
NeoLKernel/drivers/bluetooth/hci_ll.c:static void __ll_do_awake(struct ll_struct *ll)
NeoLKernel/drivers/bluetooth/hci_ll.c: * Called upon a wake-up-indication from the device
NeoLKernel/drivers/bluetooth/hci_ll.c:static void ll_device_want_to_wakeup(struct hci_uart *hu)
NeoLKernel/drivers/bluetooth/hci_ll.c:		 * have simultaneously sent a wake-up-indication packet.
NeoLKernel/drivers/bluetooth/hci_ll.c:		 * Traditionaly, in this case, receiving a wake-up-indication
NeoLKernel/drivers/bluetooth/hci_ll.c:		 * was enough and an additional wake-up-ack wasn't needed.
NeoLKernel/drivers/bluetooth/hci_ll.c:		 * explicit wake-up-ack. Other BRF versions, which do not
NeoLKernel/drivers/bluetooth/hci_ll.c:		BT_DBG("dual wake-up-indication");
NeoLKernel/drivers/bluetooth/hci_ll.c:		 * receiving the wake up indicator
NeoLKernel/drivers/bluetooth/hci_ll.c:		/* acknowledge device wake up */
NeoLKernel/drivers/bluetooth/hci_ll.c:			BT_ERR("cannot acknowledge device wake up");
NeoLKernel/drivers/bluetooth/hci_ll.c:	__ll_do_awake(ll);
NeoLKernel/drivers/bluetooth/hci_ll.c:	hci_uart_tx_wakeup(hu);
NeoLKernel/drivers/bluetooth/hci_ll.c:	hci_uart_tx_wakeup(hu);
NeoLKernel/drivers/bluetooth/hci_ll.c: * Called upon wake-up-acknowledgement from the device
NeoLKernel/drivers/bluetooth/hci_ll.c:	__ll_do_awake(ll);
NeoLKernel/drivers/bluetooth/hci_ll.c:	hci_uart_tx_wakeup(hu);
NeoLKernel/drivers/bluetooth/hci_ll.c:		BT_DBG("device awake, sending normally");
NeoLKernel/drivers/bluetooth/hci_ll.c:		/* awake device */
NeoLKernel/drivers/bluetooth/hci_ll.c:			BT_ERR("cannot wake up device");
NeoLKernel/drivers/bluetooth/hci_ll.c:			ll_device_want_to_wakeup(hu);
NeoLKernel/drivers/bluetooth/hci_uart.h:int hci_uart_tx_wakeup(struct hci_uart *hu);
NeoLKernel/drivers/bluetooth/hci_vhci.c:	wake_up_interruptible(&data->read_wait);
NeoLKernel/drivers/cdrom/gdrom.c:	wake_up_interruptible(&command_queue);
NeoLKernel/drivers/cdrom/gdrom.c:	wake_up_interruptible(&request_queue);
NeoLKernel/drivers/char/amiserial.c:		wake_up_interruptible(&info->delta_msr_wait);
NeoLKernel/drivers/char/amiserial.c:			wake_up_interruptible(&info->open_wait);
NeoLKernel/drivers/char/amiserial.c:		tty_wakeup(tty);
NeoLKernel/drivers/char/amiserial.c:	 * here so the queue might never be waken up
NeoLKernel/drivers/char/amiserial.c:	wake_up_interruptible(&info->delta_msr_wait);
NeoLKernel/drivers/char/amiserial.c:	tty_wakeup(tty);
NeoLKernel/drivers/char/amiserial.c:	 * No need to wake up processes in open wait, since they
NeoLKernel/drivers/char/amiserial.c:		wake_up_interruptible(&info->open_wait);
NeoLKernel/drivers/char/amiserial.c:		wake_up_interruptible(&info->open_wait);
NeoLKernel/drivers/char/amiserial.c:	wake_up_interruptible(&info->close_wait);
NeoLKernel/drivers/char/amiserial.c:	wake_up_interruptible(&info->open_wait);
NeoLKernel/drivers/char/apm-emulation.c:	wake_up_interruptible(&apm_waitqueue);
NeoLKernel/drivers/char/apm-emulation.c:			wake_up(&apm_suspend_waitqueue);
NeoLKernel/drivers/char/apm-emulation.c:	wake_up(&apm_suspend_waitqueue);
NeoLKernel/drivers/char/apm-emulation.c:		wake_up_interruptible(&apm_waitqueue);
NeoLKernel/drivers/char/apm-emulation.c:		 * Send a message so everyone knows we're now awake again.
NeoLKernel/drivers/char/apm-emulation.c:		 * Finally, wake up anyone who is sleeping on the suspend.
NeoLKernel/drivers/char/apm-emulation.c:		wake_up(&apm_suspend_waitqueue);
NeoLKernel/drivers/char/apm-emulation.c:	wake_up_process(kapmd_tsk);
NeoLKernel/drivers/char/apm-emulation.c:	wake_up_interruptible(&kapmd_wait);
NeoLKernel/drivers/char/n_hdlc.c: * @tbusy - reentrancy flag for tx wakeup code
NeoLKernel/drivers/char/n_hdlc.c:static void n_hdlc_tty_wakeup(struct tty_struct *tty);
NeoLKernel/drivers/char/n_hdlc.c:	.write_wakeup	= n_hdlc_tty_wakeup,
NeoLKernel/drivers/char/n_hdlc.c:	wake_up_interruptible (&tty->read_wait);
NeoLKernel/drivers/char/n_hdlc.c:	wake_up_interruptible (&tty->write_wait);
NeoLKernel/drivers/char/n_hdlc.c: * list and by the tty wakeup callback.
NeoLKernel/drivers/char/n_hdlc.c:			wake_up_interruptible(&tty->write_wait);
NeoLKernel/drivers/char/n_hdlc.c: * n_hdlc_tty_wakeup - Callback for transmit wakeup
NeoLKernel/drivers/char/n_hdlc.c:static void n_hdlc_tty_wakeup(struct tty_struct *tty)
NeoLKernel/drivers/char/n_hdlc.c:		printk("%s(%d)n_hdlc_tty_wakeup() called\n",__FILE__,__LINE__);
NeoLKernel/drivers/char/n_hdlc.c:}	/* end of n_hdlc_tty_wakeup() */
NeoLKernel/drivers/char/n_hdlc.c:	/* wake up any blocked reads and perform async signalling */
NeoLKernel/drivers/char/n_hdlc.c:	wake_up_interruptible (&tty->read_wait);
NeoLKernel/drivers/char/n_hdlc.c:		/* may awaken in the future (read and write) */
NeoLKernel/drivers/char/n_r3964.c:		wake_up_interruptible(&pInfo->read_wait);
NeoLKernel/drivers/char/n_r3964.c:	wake_up_interruptible(&pInfo->read_wait);
NeoLKernel/drivers/char/n_r3964.c:	wake_up_interruptible(&pInfo->read_wait);
NeoLKernel/drivers/char/n_tty.c: * 2002/03/18   Implemented n_tty_wakeup to send SIGIO POLL_OUTs to
NeoLKernel/drivers/char/n_tty.c:		wake_up_interruptible(&tty->link->read_wait);
NeoLKernel/drivers/char/n_tty.c:	wake_up_interruptible(&tty->read_wait);
NeoLKernel/drivers/char/n_tty.c:	wake_up_interruptible(&tty->read_wait);
NeoLKernel/drivers/char/n_tty.c:				wake_up_interruptible(&tty->read_wait);
NeoLKernel/drivers/char/n_tty.c: *	n_tty_write_wakeup	-	asynchronous I/O notifier
NeoLKernel/drivers/char/n_tty.c:static void n_tty_write_wakeup(struct tty_struct *tty)
NeoLKernel/drivers/char/n_tty.c:	if (!tty->icanon && (tty->read_cnt >= tty->minimum_to_wake)) {
NeoLKernel/drivers/char/n_tty.c:			wake_up_interruptible(&tty->read_wait);
NeoLKernel/drivers/char/n_tty.c:		wake_up_interruptible(&tty->read_wait);
NeoLKernel/drivers/char/n_tty.c:	wake_up_interruptible(&tty->write_wait);
NeoLKernel/drivers/char/n_tty.c:	wake_up_interruptible(&tty->read_wait);
NeoLKernel/drivers/char/n_tty.c:	tty->minimum_to_wake = 1;
NeoLKernel/drivers/char/n_tty.c:				tty->minimum_to_wake = 1;
NeoLKernel/drivers/char/n_tty.c:				 (tty->minimum_to_wake > minimum))
NeoLKernel/drivers/char/n_tty.c:				tty->minimum_to_wake = minimum;
NeoLKernel/drivers/char/n_tty.c:			tty->minimum_to_wake = minimum = 1;
NeoLKernel/drivers/char/n_tty.c:		if (((minimum - (b - buf)) < tty->minimum_to_wake) &&
NeoLKernel/drivers/char/n_tty.c:			tty->minimum_to_wake = (minimum - (b - buf));
NeoLKernel/drivers/char/n_tty.c:		tty->minimum_to_wake = minimum;
NeoLKernel/drivers/char/n_tty.c:			tty->minimum_to_wake = MIN_CHAR(tty);
NeoLKernel/drivers/char/n_tty.c:			tty->minimum_to_wake = 1;
NeoLKernel/drivers/char/n_tty.c:	.write_wakeup    = n_tty_write_wakeup
NeoLKernel/drivers/char/pcmcia/cm4000_cs.c:	wait_queue_head_t readq;	/* used by write to wake blk.read */
NeoLKernel/drivers/char/pcmcia/cm4000_cs.c:		/* close et al. are sleeping on devq, so wake it */
NeoLKernel/drivers/char/pcmcia/cm4000_cs.c:		wake_up_interruptible(&dev->devq);
NeoLKernel/drivers/char/pcmcia/cm4000_cs.c:					wake_up_interruptible(&dev->atrq);
NeoLKernel/drivers/char/pcmcia/cm4000_cs.c:				wake_up_interruptible(&dev->atrq);
NeoLKernel/drivers/char/pcmcia/cm4000_cs.c:			wake_up_interruptible(&dev->atrq);
NeoLKernel/drivers/char/pcmcia/cm4000_cs.c:			wake_up_interruptible(&dev->atrq);	/* wake open */
NeoLKernel/drivers/char/pcmcia/cm4000_cs.c:	wake_up_interruptible(&dev->ioq);	/* whoever needs IO */
NeoLKernel/drivers/char/pcmcia/cm4000_cs.c:	wake_up_interruptible(&dev->ioq);
NeoLKernel/drivers/char/pcmcia/cm4000_cs.c:	 * atr-queue.  if *then* the monitor detects atr valid, it will wake up
NeoLKernel/drivers/char/pcmcia/cm4000_cs.c:	 * wake_up and the calling process would sleep forever (until
NeoLKernel/drivers/char/pcmcia/cm4000_cs.c:	wake_up_interruptible(&dev->ioq);
NeoLKernel/drivers/char/pcmcia/cm4000_cs.c:	wake_up_interruptible(&dev->readq);	/* tell read we have data */
NeoLKernel/drivers/char/pcmcia/cm4000_cs.c:		wake_up_interruptible(&dev->ioq);
NeoLKernel/drivers/char/pcmcia/cm4000_cs.c:			wake_up_interruptible(&dev->ioq);
NeoLKernel/drivers/char/pcmcia/cm4000_cs.c:	wake_up(&dev->devq);	/* socket removed? */
NeoLKernel/drivers/char/pcmcia/cm4040_cs.c:		wake_up_interruptible(&dev->read_wait);
NeoLKernel/drivers/char/pcmcia/cm4040_cs.c:		wake_up_interruptible(&dev->write_wait);
NeoLKernel/drivers/char/pcmcia/cm4040_cs.c:		wake_up_interruptible(&dev->poll_wait);
NeoLKernel/drivers/char/pcmcia/cm4040_cs.c:	wake_up(&dev->devq);
NeoLKernel/drivers/char/pcmcia/ipwireless/network.c:			ppp_output_wakeup(network->ppp_channel);
NeoLKernel/drivers/char/pcmcia/synclink_cs.c:		tty_wakeup(tty);
NeoLKernel/drivers/char/pcmcia/synclink_cs.c:	wake_up_interruptible(&info->status_event_wait_q);
NeoLKernel/drivers/char/pcmcia/synclink_cs.c:	wake_up_interruptible(&info->event_wait_q);
NeoLKernel/drivers/char/pcmcia/synclink_cs.c:	wake_up_interruptible(&info->status_event_wait_q);
NeoLKernel/drivers/char/pcmcia/synclink_cs.c:	wake_up_interruptible(&info->event_wait_q);
NeoLKernel/drivers/char/pcmcia/synclink_cs.c:			wake_up_interruptible(&info->port.open_wait);
NeoLKernel/drivers/char/pcmcia/synclink_cs.c:	wake_up_interruptible(&info->status_event_wait_q);
NeoLKernel/drivers/char/pcmcia/synclink_cs.c:	wake_up_interruptible(&info->event_wait_q);
NeoLKernel/drivers/char/pcmcia/synclink_cs.c:	wake_up_interruptible(&info->status_event_wait_q);
NeoLKernel/drivers/char/pcmcia/synclink_cs.c:	wake_up_interruptible(&info->event_wait_q);
NeoLKernel/drivers/char/pcmcia/synclink_cs.c:				wake_up_interruptible(&info->event_wait_q);
NeoLKernel/drivers/char/pcmcia/synclink_cs.c:	wake_up_interruptible(&info->status_event_wait_q);
NeoLKernel/drivers/char/pcmcia/synclink_cs.c:	wake_up_interruptible(&info->event_wait_q);
NeoLKernel/drivers/char/pcmcia/synclink_cs.c:	wake_up_interruptible(&tty->write_wait);
NeoLKernel/drivers/char/pcmcia/synclink_cs.c:	tty_wakeup(tty);
NeoLKernel/drivers/char/pcmcia/synclink_cs.c:	netif_wake_queue(dev);
NeoLKernel/drivers/char/pcmcia/synclink_cs.c:		netif_wake_queue(info->netdev);
NeoLKernel/drivers/char/ppdev.c:	wake_up_interruptible (&pp->irq_wait);
NeoLKernel/drivers/char/pty.c:	wake_up_interruptible(&tty->read_wait);
NeoLKernel/drivers/char/pty.c:	wake_up_interruptible(&tty->write_wait);
NeoLKernel/drivers/char/pty.c:	wake_up_interruptible(&tty->link->read_wait);
NeoLKernel/drivers/char/pty.c:	wake_up_interruptible(&tty->link->write_wait);
NeoLKernel/drivers/char/pty.c: * happens, we need to wake up any sleeping processes that could be
NeoLKernel/drivers/char/pty.c:	tty_wakeup(tty->link);
NeoLKernel/drivers/char/pty.c:			tty_wakeup(tty);
NeoLKernel/drivers/char/pty.c:		wake_up_interruptible(&to->read_wait);
NeoLKernel/drivers/char/random.c: * The minimum number of bits of entropy before we wake up a read on
NeoLKernel/drivers/char/random.c:static int random_read_wakeup_thresh = 64;
NeoLKernel/drivers/char/random.c: * should wake up processes which are selecting or polling on write
NeoLKernel/drivers/char/random.c:static int random_write_wakeup_thresh = 128;
NeoLKernel/drivers/char/random.c:	/* should we wake readers? */
NeoLKernel/drivers/char/random.c:	if (r == &input_pool && entropy_count >= random_read_wakeup_thresh) {
NeoLKernel/drivers/char/random.c:		wake_up_interruptible(&random_read_wait);
NeoLKernel/drivers/char/random.c:		/* If we're limited, always leave two wakeup worth's BITS */
NeoLKernel/drivers/char/random.c:		int rsvd = r->limit ? 0 : random_read_wakeup_thresh/4;
NeoLKernel/drivers/char/random.c:		/* pull at least as many as BYTES as wakeup BITS */
NeoLKernel/drivers/char/random.c:		bytes = max_t(int, bytes, random_read_wakeup_thresh / 8);
NeoLKernel/drivers/char/random.c:					random_read_wakeup_thresh / 8, rsvd);
NeoLKernel/drivers/char/random.c:		if (r->entropy_count < random_write_wakeup_thresh) {
NeoLKernel/drivers/char/random.c:			wake_up_interruptible(&random_write_wait);
NeoLKernel/drivers/char/random.c:						 random_read_wakeup_thresh);
NeoLKernel/drivers/char/random.c:			DEBUG_ENT("awake\n");
NeoLKernel/drivers/char/random.c:	if (input_pool.entropy_count >= random_read_wakeup_thresh)
NeoLKernel/drivers/char/random.c:	if (input_pool.entropy_count < random_write_wakeup_thresh)
NeoLKernel/drivers/char/random.c:		.procname	= "read_wakeup_threshold",
NeoLKernel/drivers/char/random.c:		.data		= &random_read_wakeup_thresh,
NeoLKernel/drivers/char/random.c:		.procname	= "write_wakeup_threshold",
NeoLKernel/drivers/char/random.c:		.data		= &random_write_wakeup_thresh,
NeoLKernel/drivers/char/rio/cirrus.h:/* "Command" packet that could go either way - handshake wake-up */
NeoLKernel/drivers/char/rio/riocmd.c:			rio_dprintk(RIO_DEBUG_CMD, "Mark status & wakeup\n");
NeoLKernel/drivers/char/rio/riocmd.c:			   wakeup( &PortP->PortState );
NeoLKernel/drivers/char/rio/riocmd.c:							 ** wakeup anyone in WOPEN
NeoLKernel/drivers/char/rio/riocmd.c:								wake_up_interruptible(&PortP->gs.port.open_wait);
NeoLKernel/drivers/char/rio/riocmd.c:			 ** So, wakeup whoever is waiting for it (and tell them
NeoLKernel/drivers/char/rio/riocmd.c:	   wakeup( (caddr_t)&(PortP->InUse) );
NeoLKernel/drivers/char/rio/riointr.c:	if (PortP->gs.xmit_cnt <= (PortP->gs.wakeup_chars + 2 * PKT_MAX_DATA_LEN))
NeoLKernel/drivers/char/rio/riointr.c:		tty_wakeup(PortP->gs.port.tty);
NeoLKernel/drivers/char/rio/riointr.c:			 ** the buffer, then we must issue a wakeup( ) on OUT.
NeoLKernel/drivers/char/rio/riointr.c:			 ** a wakeup( ) on IN.
NeoLKernel/drivers/char/rio/riotable.c:							   wakeup( &PortP->TxBufferIn );
NeoLKernel/drivers/char/rio/riotable.c:							   wakeup( &PortP->TxBufferOut);
NeoLKernel/drivers/char/rio/riotable.c:							   wakeup( &PortP->InUse );
NeoLKernel/drivers/char/rio/riotty.c:		   wakeup((caddr_t) &tp->tm.c_canq);
NeoLKernel/drivers/char/rio/riotty.c:		wake_up_interruptible(&PortP->gs.port.open_wait);
NeoLKernel/drivers/char/rio/rio_linux.c:				/* how much data left before wakeup */
NeoLKernel/drivers/char/riscom8.c:	if (tty && port->xmit_cnt <= port->wakeup_chars)
NeoLKernel/drivers/char/riscom8.c:		tty_wakeup(tty);
NeoLKernel/drivers/char/riscom8.c:			wake_up_interruptible(&port->port.open_wait);
NeoLKernel/drivers/char/riscom8.c:				if (port->xmit_cnt <= port->wakeup_chars)
NeoLKernel/drivers/char/riscom8.c:					tty_wakeup(tty);
NeoLKernel/drivers/char/riscom8.c:				if (port->xmit_cnt <= port->wakeup_chars)
NeoLKernel/drivers/char/riscom8.c:					tty_wakeup(tty);
NeoLKernel/drivers/char/riscom8.c:	/* Two timer ticks seems enough to wakeup something like SLIP driver */
NeoLKernel/drivers/char/riscom8.c:	port->wakeup_chars = (tmp < 0) ? 0 : ((tmp >= SERIAL_XMIT_SIZE) ?
NeoLKernel/drivers/char/riscom8.c:	tty_wakeup(tty);
NeoLKernel/drivers/char/riscom8.h:	short			wakeup_chars;
NeoLKernel/drivers/char/rocket.c:		tty_wakeup(tty);
NeoLKernel/drivers/char/rocket.c:		wake_up_interruptible(&tty->poll_wait);
NeoLKernel/drivers/char/rocket.c:		wake_up_interruptible(&info->port.open_wait);
NeoLKernel/drivers/char/rocket.c:		wake_up_interruptible(&port->open_wait);
NeoLKernel/drivers/char/rocket.c:	wake_up_interruptible(&port->close_wait);
NeoLKernel/drivers/char/rocket.c:	wake_up_interruptible(&info->port.open_wait);
NeoLKernel/drivers/char/rocket.c: 		tty_wakeup(tty);
NeoLKernel/drivers/char/rocket.c:		wake_up_interruptible(&tty->poll_wait);
NeoLKernel/drivers/char/rocket.c:	wake_up_interruptible(&tty->poll_wait);
NeoLKernel/drivers/char/rocket.c:	tty_wakeup(tty);
NeoLKernel/drivers/char/rtc.c:	wake_up_interruptible(&rtc_wait);
NeoLKernel/drivers/char/rtc.c:	wake_up_interruptible(&rtc_wait);
NeoLKernel/drivers/char/serial167.c:				wake_up_interruptible(&info->open_wait);
NeoLKernel/drivers/char/serial167.c:				wake_up_interruptible(&info->open_wait);
NeoLKernel/drivers/char/serial167.c:					tty_wakeup(info->tty);
NeoLKernel/drivers/char/serial167.c:		tty_wakeup(info->tty);
NeoLKernel/drivers/char/serial167.c:	tty_wakeup(tty);
NeoLKernel/drivers/char/serial167.c:		wake_up_interruptible(&info->open_wait);
NeoLKernel/drivers/char/serial167.c:		wake_up_interruptible(&info->open_wait);
NeoLKernel/drivers/char/serial167.c:	wake_up_interruptible(&info->close_wait);
NeoLKernel/drivers/char/serial167.c:	wake_up_interruptible(&info->open_wait);
NeoLKernel/drivers/char/ser_a2232.c:				if ((port->gs.xmit_cnt <= port->gs.wakeup_chars) && port->gs.port.tty) {
NeoLKernel/drivers/char/ser_a2232.c:					tty_wakeup(port->gs.port.tty);
NeoLKernel/drivers/char/ser_a2232.c:							wake_up_interruptible(&port->gs.port.open_wait);
NeoLKernel/drivers/char/snsc.c:			wake_up(&sd->sd_rq);
NeoLKernel/drivers/char/snsc.c:			wake_up(&sd->sd_wq);
NeoLKernel/drivers/char/snsc.c:	/* release the read buffer and wake anyone who might be
NeoLKernel/drivers/char/snsc.c:	/* release the write buffer and wake anyone who's waiting for it */
NeoLKernel/drivers/char/hvsi.c:	wake_up_all(&hp->stateq);
NeoLKernel/drivers/char/hvsi.c:		wake_up_all(&hp->emptyq);
NeoLKernel/drivers/char/hvsi.c:		tty_wakeup(hp->tty);
NeoLKernel/drivers/char/hw_random/mxc-rnga.c:	/* wake up */
NeoLKernel/drivers/char/ip2/i2lib.c:			// this ultimatly gets more data or wakes write output
NeoLKernel/drivers/char/ip2/i2lib.c:	wake_up_interruptible( &pCh->pBookmarkWait );
NeoLKernel/drivers/char/ip2/i2lib.c:ip2_owake( PTTY tp)
NeoLKernel/drivers/char/ip2/i2lib.c:	tty_wakeup(tp);
NeoLKernel/drivers/char/ip2/i2lib.c:							wake_up_interruptible( &pCh->pBookmarkWait );
NeoLKernel/drivers/char/ip2/i2lib.c:								ip2_owake(pCh->pTTY);
NeoLKernel/drivers/char/ip2/i2lib.c:							wake_up_interruptible ( &pCh->dss_now_wait );
NeoLKernel/drivers/char/ip2/i2lib.c:				ip2_owake(pCh->pTTY);
NeoLKernel/drivers/char/ip2/i2pack.h:// error. At startup, this process is dormant. The host can wake it up by
NeoLKernel/drivers/char/ip2/ip2main.c:			wake_up_interruptible(&pCh->pTTY->read_wait);
NeoLKernel/drivers/char/ip2/ip2main.c:		wake_up_interruptible(&pCh->delta_msr_wait);
NeoLKernel/drivers/char/ip2/ip2main.c:					wake_up_interruptible ( &pCh->open_wait );
NeoLKernel/drivers/char/ip2/ip2main.c:		wake_up_interruptible(&pCh->open_wait);
NeoLKernel/drivers/char/ip2/ip2main.c:	wake_up_interruptible(&pCh->close_wait);
NeoLKernel/drivers/char/ip2/ip2main.c:	DBG_CNT("ip2_close: after wakeups--");
NeoLKernel/drivers/char/ip2/ip2main.c:	wake_up_interruptible ( &pCh->delta_msr_wait );
NeoLKernel/drivers/char/ip2/ip2main.c:	wake_up_interruptible ( &pCh->open_wait );
NeoLKernel/drivers/char/ip2/ip2main.c:	ip2_owake(tty);
NeoLKernel/drivers/char/ipmi/ipmi_devintf.c:		wake_up_interruptible(&priv->wait);
NeoLKernel/drivers/char/ipmi/ipmi_msghandler.c:	/* Used for wake ups at startup. */
NeoLKernel/drivers/char/ipmi/ipmi_msghandler.c:	wake_up(&intf->waitq);
NeoLKernel/drivers/char/ipmi/ipmi_msghandler.c:				wake_up(&intf->waitq);
NeoLKernel/drivers/char/ipmi/ipmi_msghandler.c:			wake_up(&intf->waitq);
NeoLKernel/drivers/char/ipmi/ipmi_msghandler.c:			wake_up(&intf->waitq);
NeoLKernel/drivers/char/ipmi/ipmi_watchdog.c:			wake_up_interruptible(&read_q);
NeoLKernel/drivers/char/isicom.c:			tty_wakeup(tty);
NeoLKernel/drivers/char/isicom.c:					wake_up_interruptible(&port->port.open_wait);
NeoLKernel/drivers/char/isicom.c:						tty_wakeup(tty);
NeoLKernel/drivers/char/isicom.c:	tty_wakeup(tty);
NeoLKernel/drivers/char/istallion.c:		wake_up_interruptible(&portp->raw_wait);
NeoLKernel/drivers/char/istallion.c:		wake_up_interruptible(&portp->port.open_wait);
NeoLKernel/drivers/char/istallion.c:	tty_wakeup(tty);
NeoLKernel/drivers/char/istallion.c:			wake_up_interruptible(&portp->raw_wait);
NeoLKernel/drivers/char/istallion.c:			wake_up_interruptible(&portp->raw_wait);
NeoLKernel/drivers/char/istallion.c:			wake_up_interruptible(&portp->raw_wait);
NeoLKernel/drivers/char/istallion.c:				wake_up_interruptible(&portp->port.open_wait);
NeoLKernel/drivers/char/istallion.c:				tty_wakeup(tty);
NeoLKernel/drivers/char/mbcs.c:		wake_up(&soft->dmaread_queue);
NeoLKernel/drivers/char/mbcs.c:		wake_up(&soft->dmawrite_queue);
NeoLKernel/drivers/char/mbcs.c:		wake_up(&soft->algo_queue);
NeoLKernel/drivers/char/moxa.c:	tty_wakeup(tty);
NeoLKernel/drivers/char/moxa.c:		 * Make it possible to wakeup anything waiting for output
NeoLKernel/drivers/char/moxa.c:		wake_up_interruptible(&ch->port.open_wait);
NeoLKernel/drivers/char/moxa.c:	wake_up_interruptible(&ch->port.open_wait);
NeoLKernel/drivers/char/moxa.c:			tty_wakeup(tty);
NeoLKernel/drivers/char/moxa.c:			tty_wakeup(tty);
NeoLKernel/drivers/char/msm_rotator.c:		wake_up(&msm_rotator_dev->wq);
NeoLKernel/drivers/char/mwave/mwavedd.c:					wake_up_interruptible(&pDrvData->IPCs[ipcnum].ipc_wait_queue);
NeoLKernel/drivers/char/mwave/tp3780i.c:					wake_up_interruptible(&pDrvData->IPCs[usPCNum - 1].ipc_wait_queue);
NeoLKernel/drivers/char/mxser.c:					tty_wakeup(tty);
NeoLKernel/drivers/char/mxser.c:	wake_up_interruptible(&port->port.delta_msr_wait);
NeoLKernel/drivers/char/mxser.c:			wake_up_interruptible(&port->port.open_wait);
NeoLKernel/drivers/char/mxser.c:				tty_wakeup(tty);
NeoLKernel/drivers/char/mxser.c:	 * here so the queue might never be waken up
NeoLKernel/drivers/char/mxser.c:	wake_up_interruptible(&info->port.delta_msr_wait);
NeoLKernel/drivers/char/mxser.c:	tty_wakeup(tty);
NeoLKernel/drivers/char/mxser.c:		tty_wakeup(tty);
NeoLKernel/drivers/char/nozomi.c:		tty_wakeup(tty);
NeoLKernel/drivers/char/nozomi.c:	wake_up_interruptible(&dc->port[port].tty_wait);
NeoLKernel/drivers/char/sonypi.c:	wake_up_interruptible(&sonypi_device.fifo_proc_list);
NeoLKernel/drivers/char/specialix.c:	if (port->xmit_cnt <= port->wakeup_chars)
NeoLKernel/drivers/char/specialix.c:		tty_wakeup(tty);
NeoLKernel/drivers/char/specialix.c:			wake_up_interruptible(&port->port.open_wait);
NeoLKernel/drivers/char/specialix.c:			if (port->xmit_cnt <= port->wakeup_chars)
NeoLKernel/drivers/char/specialix.c:				tty_wakeup(tty);
NeoLKernel/drivers/char/specialix.c:			if (port->xmit_cnt <= port->wakeup_chars)
NeoLKernel/drivers/char/specialix.c:				tty_wakeup(tty);
NeoLKernel/drivers/char/specialix.c:	/* Two timer ticks seems enough to wakeup something like SLIP driver */
NeoLKernel/drivers/char/specialix.c:	port->wakeup_chars = (tmp < 0) ? 0 : ((tmp >= SERIAL_XMIT_SIZE) ?
NeoLKernel/drivers/char/specialix.c:	tty_wakeup(tty);
NeoLKernel/drivers/char/specialix.c:		wake_up_interruptible(&port->port.open_wait);
NeoLKernel/drivers/char/specialix.c:	wake_up_interruptible(&port->port.close_wait);
NeoLKernel/drivers/char/specialix.c:	wake_up_interruptible(&port->port.open_wait);
NeoLKernel/drivers/char/specialix_io8.h:	short			wakeup_chars;
NeoLKernel/drivers/char/stallion.c:		wake_up_interruptible(&portp->port.open_wait);
NeoLKernel/drivers/char/stallion.c:	tty_wakeup(tty);
NeoLKernel/drivers/char/stallion.c:		wake_up_interruptible(&portp->port.open_wait);
NeoLKernel/drivers/char/stallion.c:			tty_wakeup(tty);
NeoLKernel/drivers/char/stallion.c:			tty_wakeup(tty);
NeoLKernel/drivers/char/sx.c:	if ((port->gs.xmit_cnt <= port->gs.wakeup_chars) && port->gs.port.tty) {
NeoLKernel/drivers/char/sx.c:		tty_wakeup(port->gs.port.tty);
NeoLKernel/drivers/char/sx.c:				port->gs.wakeup_chars);
NeoLKernel/drivers/char/sx.c:					wake_up_interruptible(&port->gs.port.
NeoLKernel/drivers/char/synclink.c:		tty_wakeup(tty);
NeoLKernel/drivers/char/synclink.c:		wake_up_interruptible(&info->event_wait_q);
NeoLKernel/drivers/char/synclink.c:		wake_up_interruptible(&info->status_event_wait_q);
NeoLKernel/drivers/char/synclink.c:		wake_up_interruptible(&info->event_wait_q);
NeoLKernel/drivers/char/synclink.c:				wake_up_interruptible(&info->port.open_wait);
NeoLKernel/drivers/char/synclink.c:	wake_up_interruptible(&info->status_event_wait_q);
NeoLKernel/drivers/char/synclink.c:	wake_up_interruptible(&info->event_wait_q);
NeoLKernel/drivers/char/synclink.c:	tty_wakeup(tty);
NeoLKernel/drivers/char/synclink.c:	wake_up_interruptible(&info->port.open_wait);
NeoLKernel/drivers/char/synclink.c:	netif_wake_queue(dev);
NeoLKernel/drivers/char/synclink.c:		netif_wake_queue(info->netdev);
NeoLKernel/drivers/char/synclinkmp.c:	wake_up_interruptible(&info->port.open_wait);
NeoLKernel/drivers/char/synclinkmp.c:	tty_wakeup(tty);
NeoLKernel/drivers/char/synclinkmp.c:	netif_wake_queue(dev);
NeoLKernel/drivers/char/synclinkmp.c:		netif_wake_queue(info->netdev);
NeoLKernel/drivers/char/synclinkmp.c:		tty_wakeup(tty);
NeoLKernel/drivers/char/synclinkmp.c:			wake_up_interruptible(&info->event_wait_q);
NeoLKernel/drivers/char/synclinkmp.c:		wake_up_interruptible(&info->status_event_wait_q);
NeoLKernel/drivers/char/synclinkmp.c:		wake_up_interruptible(&info->event_wait_q);
NeoLKernel/drivers/char/synclinkmp.c:				wake_up_interruptible(&info->port.open_wait);
NeoLKernel/drivers/char/synclinkmp.c:	wake_up_interruptible(&info->status_event_wait_q);
NeoLKernel/drivers/char/synclinkmp.c:	wake_up_interruptible(&info->event_wait_q);
NeoLKernel/drivers/char/synclink_gt.c:	wake_up_interruptible(&info->port.open_wait);
NeoLKernel/drivers/char/synclink_gt.c:	tty_wakeup(tty);
NeoLKernel/drivers/char/synclink_gt.c:	netif_wake_queue(dev);
NeoLKernel/drivers/char/synclink_gt.c:		netif_wake_queue(info->netdev);
NeoLKernel/drivers/char/synclink_gt.c:		tty_wakeup(tty);
NeoLKernel/drivers/char/synclink_gt.c:	wake_up_interruptible(&info->status_event_wait_q);
NeoLKernel/drivers/char/synclink_gt.c:	wake_up_interruptible(&info->event_wait_q);
NeoLKernel/drivers/char/synclink_gt.c:	wake_up_interruptible(&info->status_event_wait_q);
NeoLKernel/drivers/char/synclink_gt.c:	wake_up_interruptible(&info->event_wait_q);
NeoLKernel/drivers/char/synclink_gt.c:	wake_up_interruptible(&info->status_event_wait_q);
NeoLKernel/drivers/char/synclink_gt.c:	wake_up_interruptible(&info->event_wait_q);
NeoLKernel/drivers/char/synclink_gt.c:			wake_up_interruptible(&info->port.open_wait);
NeoLKernel/drivers/char/synclink_gt.c:	wake_up_interruptible(&info->status_event_wait_q);
NeoLKernel/drivers/char/synclink_gt.c:	wake_up_interruptible(&info->event_wait_q);
NeoLKernel/drivers/char/synclink_gt.c:			wake_up_interruptible(&info->event_wait_q);
NeoLKernel/drivers/char/synclink_gt.c:	/* wake processes waiting for specific transitions */
NeoLKernel/drivers/char/synclink_gt.c:			wake_up_interruptible(&w->q);
NeoLKernel/drivers/char/synclink_gt.c:	wake_up_interruptible(&info->status_event_wait_q);
NeoLKernel/drivers/char/synclink_gt.c:	wake_up_interruptible(&info->event_wait_q);
NeoLKernel/drivers/char/synclink_gt.c:		wake_up_interruptible(&(*head)->q);
NeoLKernel/drivers/char/tlclk.c:	/* Alarm processing is done, wake up read task */
NeoLKernel/drivers/char/tlclk.c:	wake_up(&wq);
NeoLKernel/drivers/char/tlclk.c:		wake_up(&wq);
NeoLKernel/drivers/char/tpm/tpm_nsc.c:	dev_dbg(&pdev->dev, "NSC Interrupt number and wakeup 0x%x\n",
NeoLKernel/drivers/char/tpm/tpm_tis.c:		wake_up_interruptible(&chip->vendor.read_queue);
NeoLKernel/drivers/char/tpm/tpm_tis.c:		wake_up_interruptible(&chip->vendor.int_queue);
NeoLKernel/drivers/char/tty_buffer.c:		wake_up(&tty->read_wait);
NeoLKernel/drivers/char/dtlk.c:	wake_up_interruptible(&dtlk_process_list);
NeoLKernel/drivers/char/dtlk.c:						   could be awakened
NeoLKernel/drivers/char/efirtc.c:			status = efi.set_wakeup_time((efi_bool_t)enabled, &eft);
NeoLKernel/drivers/char/efirtc.c:			status = efi.get_wakeup_time((efi_bool_t *)&enabled, (efi_bool_t *)&pending, &eft);
NeoLKernel/drivers/char/efirtc.c:	efi.get_wakeup_time(&enabled, &pending, &alm);
NeoLKernel/drivers/char/epca.c:		 * Make it possible to wakeup anything waiting for output in
NeoLKernel/drivers/char/epca.c:	tty_wakeup(tty);
NeoLKernel/drivers/char/epca.c:					wake_up_interruptible(&ch->port.open_wait);
NeoLKernel/drivers/char/epca.c:					tty_wakeup(tty);
NeoLKernel/drivers/char/epca.c:					tty_wakeup(tty);
NeoLKernel/drivers/char/epca.c:			wake_up_interruptible(&ch->port.open_wait);
NeoLKernel/drivers/char/epca.c:				wake_up_interruptible(&ch->port.open_wait);
NeoLKernel/drivers/char/esp.c:			tty_wakeup(info->port.tty);
NeoLKernel/drivers/char/esp.c:			tty_wakeup(info->port.tty);
NeoLKernel/drivers/char/esp.c:		wake_up_interruptible(&info->port.delta_msr_wait);
NeoLKernel/drivers/char/esp.c:			wake_up_interruptible(&info->port.open_wait);
NeoLKernel/drivers/char/esp.c:			wake_up_interruptible(&info->break_wait);
NeoLKernel/drivers/char/esp.c:	 * here so the queue might never be waken up
NeoLKernel/drivers/char/esp.c:	wake_up_interruptible(&info->port.delta_msr_wait);
NeoLKernel/drivers/char/esp.c:	wake_up_interruptible(&info->break_wait);
NeoLKernel/drivers/char/esp.c:	tty_wakeup(tty);
NeoLKernel/drivers/char/esp.c:			/* FIXME: convert to new style wakeup */
NeoLKernel/drivers/char/esp.c:		wake_up_interruptible(&info->port.open_wait);
NeoLKernel/drivers/char/esp.c:	wake_up_interruptible(&info->port.close_wait);
NeoLKernel/drivers/char/esp.c:	wake_up_interruptible(&info->port.open_wait);
NeoLKernel/drivers/char/generic_serial.c:	tty_wakeup(tty);
NeoLKernel/drivers/char/generic_serial.c:	wake_up_interruptible(&port->port.open_wait);
NeoLKernel/drivers/char/generic_serial.c:		wake_up_interruptible(&port->port.open_wait);
NeoLKernel/drivers/char/generic_serial.c:	wake_up_interruptible(&port->port.close_wait);
NeoLKernel/drivers/char/generic_serial.c:	/* Two timer ticks seems enough to wakeup something like SLIP driver */
NeoLKernel/drivers/char/generic_serial.c:	port->wakeup_chars = tmp;
NeoLKernel/drivers/char/generic_serial.c:		wake_up_interruptible(&port->gs.open_wait);
NeoLKernel/drivers/char/genrtc.c:	wake_up_interruptible(&gen_rtc_wait);
NeoLKernel/drivers/char/hpet.c:	wake_up_interruptible(&devp->hd_waitqueue);
NeoLKernel/drivers/char/hvcs.c: * already awake but potentially shifted to TASK_INTERRUPTIBLE state.
NeoLKernel/drivers/char/hvcs.c:	wake_up_process(hvcs_task);
NeoLKernel/drivers/char/hvcs.c:			 * we commited to delivering it.  But don't try to wake
NeoLKernel/drivers/char/hvcs.c:				tty_wakeup(tty);
NeoLKernel/drivers/char/hvcs.c:	 * This synchronous operation  will wake the khvcsd kthread if it is
NeoLKernel/drivers/char/hvc_console.c:	wake_up_process(hvc_task);
NeoLKernel/drivers/char/hvc_console.c:	/* Force wakeup of the polling thread */
NeoLKernel/drivers/char/hvc_console.c:			hp->do_wakeup = 1;
NeoLKernel/drivers/char/hvc_console.c:		hp->do_wakeup = 1;
NeoLKernel/drivers/char/hvc_console.c:	if (hp->do_wakeup) {
NeoLKernel/drivers/char/hvc_console.c:		hp->do_wakeup = 0;
NeoLKernel/drivers/char/hvc_console.c:		tty_wakeup(tty);
NeoLKernel/drivers/char/hvc_console.h:	int do_wakeup;
NeoLKernel/drivers/char/hvc_iucv.c: * the HVC layer to hang up the tty and, if so, wake up the HVC thread
NeoLKernel/drivers/char/hvc_iucv.c:	hvc_kick();	/* wake up hvc thread */
NeoLKernel/drivers/char/hvc_iucv.c:	wake_up(&priv->sndbuf_waitq);
NeoLKernel/drivers/char/applicom.c:				wake_up_interruptible(&FlagSleepRec);
NeoLKernel/drivers/char/applicom.c:					wake_up_interruptible(&apbs[i].FlagSleepSend);
NeoLKernel/drivers/char/nwbutton.c:	wake_up_interruptible (&button_wait_queue);
NeoLKernel/drivers/char/tty_io.c: *	tty_wakeup	-	request more data
NeoLKernel/drivers/char/tty_io.c: *	Internal and external helper for wakeups of tty. This function
NeoLKernel/drivers/char/tty_io.c:void tty_wakeup(struct tty_struct *tty)
NeoLKernel/drivers/char/tty_io.c:			if (ld->ops->write_wakeup)
NeoLKernel/drivers/char/tty_io.c:				ld->ops->write_wakeup(tty);
NeoLKernel/drivers/char/tty_io.c:	wake_up_interruptible_poll(&tty->write_wait, POLLOUT);
NeoLKernel/drivers/char/tty_io.c:EXPORT_SYMBOL_GPL(tty_wakeup);
NeoLKernel/drivers/char/tty_io.c:		wake_up_interruptible_poll(&tty->link->read_wait, POLLIN);
NeoLKernel/drivers/char/tty_io.c: *	any necessary wakeups and propagate the TIOCPKT status. If this
NeoLKernel/drivers/char/tty_io.c:		wake_up_interruptible_poll(&tty->link->read_wait, POLLIN);
NeoLKernel/drivers/char/tty_io.c:	tty_wakeup(tty);
NeoLKernel/drivers/char/tty_io.c:	wake_up_interruptible_poll(&tty->write_wait, POLLOUT);
NeoLKernel/drivers/char/tty_io.c:				wake_up_poll(&tty->read_wait, POLLIN);
NeoLKernel/drivers/char/tty_io.c:				wake_up_poll(&tty->write_wait, POLLOUT);
NeoLKernel/drivers/char/tty_io.c:				wake_up_poll(&o_tty->read_wait, POLLIN);
NeoLKernel/drivers/char/tty_io.c:				wake_up_poll(&o_tty->write_wait, POLLOUT);
NeoLKernel/drivers/char/tty_io.c:			tty->minimum_to_wake = 1;
NeoLKernel/drivers/char/tty_io.c:			tty->minimum_to_wake = N_TTY_BUF_SIZE;
NeoLKernel/drivers/char/bfin_jtag_comm.c:					tty_wakeup(tty);
NeoLKernel/drivers/char/bfin_jtag_comm.c:	wake_up_process(bfin_jc_kthread);
NeoLKernel/drivers/char/bfin_jtag_comm.c:	wake_up_process(bfin_jc_kthread);
NeoLKernel/drivers/char/bfin_jtag_comm.c:	wake_up_process(bfin_jc_kthread);
NeoLKernel/drivers/char/bfin_jtag_comm.c:	wake_up_process(bfin_jc_kthread);
NeoLKernel/drivers/char/ChangeLog:		select on /dev/random for writing; wake up the daemon when
NeoLKernel/drivers/char/ChangeLog:	* serial.c (shutdown, rs_ioctl) : when port shuts down wakeup processes
NeoLKernel/drivers/char/ChangeLog:	* serial.c (rs_set_termios): Don't wake up processes blocked in
NeoLKernel/drivers/char/cyclades.c:	tty_wakeup(tty);
NeoLKernel/drivers/char/cyclades.c:		wake_up_interruptible(&info->port.delta_msr_wait);
NeoLKernel/drivers/char/cyclades.c:			wake_up_interruptible(&info->port.open_wait);
NeoLKernel/drivers/char/cyclades.c:				tty_wakeup(tty);
NeoLKernel/drivers/char/cyclades.c:		tty_wakeup(tty);
NeoLKernel/drivers/char/cyclades.c:					wake_up_interruptible(&info->port.open_wait);
NeoLKernel/drivers/char/cyclades.c:			wake_up_interruptible(&info->port.delta_msr_wait);
NeoLKernel/drivers/char/cyclades.c:		wake_up_interruptible(&info->port.delta_msr_wait);
NeoLKernel/drivers/char/cyclades.c:	tty_wakeup(tty);
NeoLKernel/drivers/char/cyclades.c:	 * No need to wake up processes in open wait, since they
NeoLKernel/drivers/char/cyclades.c:		wake_up_interruptible(&info->port.open_wait);
NeoLKernel/drivers/char/dcc_tty.c:					tty_wakeup(g_dcc_tty);
NeoLKernel/drivers/char/diag/diagchar_core.c:		wake_up_interruptible(&driver->wait_q);
NeoLKernel/drivers/char/diag/diagchar_core.c:		/* In case, the thread wakes up and the logging mode is
NeoLKernel/drivers/char/diag/diagfwd.c:			wake_up_interruptible(&driver->wait_q);
NeoLKernel/drivers/char/diag/diagfwd.c:	wake_up_interruptible(&driver->wait_q);
NeoLKernel/drivers/char/diag/diagfwd.c:	wake_up_interruptible(&driver->wait_q);
NeoLKernel/drivers/char/tty_ioctl.c:	 *	the user their platform maintainer needs to wake up if not.
NeoLKernel/drivers/char/tty_ioctl.c:			wake_up_interruptible(&tty->link->read_wait);
NeoLKernel/drivers/char/tty_ldisc.c: *	again. Do necessary wakeups for existing sleepers. Clear the LDISC
NeoLKernel/drivers/char/tty_ldisc.c:	wake_up(&tty_ldisc_wait);
NeoLKernel/drivers/char/tty_ldisc.c:		    ld->ops->write_wakeup)
NeoLKernel/drivers/char/tty_ldisc.c:			ld->ops->write_wakeup(tty);
NeoLKernel/drivers/char/tty_ldisc.c:	wake_up_interruptible_poll(&tty->write_wait, POLLOUT);
NeoLKernel/drivers/char/tty_ldisc.c:	wake_up_interruptible_poll(&tty->read_wait, POLLIN);
NeoLKernel/drivers/char/tty_port.c:	wake_up_interruptible(&port->open_wait);
NeoLKernel/drivers/char/tty_port.c:	wake_up_interruptible(&port->delta_msr_wait);
NeoLKernel/drivers/char/tty_port.c:		wake_up_interruptible(&port->open_wait);
NeoLKernel/drivers/char/tty_port.c:	wake_up_interruptible(&port->close_wait);
NeoLKernel/drivers/char/vme_scc.c:	if (port->gs.port.tty && port->gs.xmit_cnt <= port->gs.wakeup_chars)
NeoLKernel/drivers/char/vme_scc.c:		tty_wakeup(port->gs.port.tty);
NeoLKernel/drivers/char/vme_scc.c:			wake_up_interruptible(&port->gs.port.open_wait);
NeoLKernel/drivers/char/vt.c:	wake_up_interruptible(&vc->paste_wait);
NeoLKernel/drivers/char/vt_ioctl.c:	int wake = 0;
NeoLKernel/drivers/char/vt_ioctl.c:		wake = 1;
NeoLKernel/drivers/char/vt_ioctl.c:	if (wake)
NeoLKernel/drivers/char/vt_ioctl.c:		wake_up_interruptible(&vt_event_waitqueue);
NeoLKernel/drivers/cpufreq/cpufreq_ondemandx.c:                pr_info("[imoseyon] ondemandx awake at %d\n", dbs_info->cur_policy->cur);
NeoLKernel/drivers/cpufreq/cpufreq_savagedzen.c: * by this frequency. Also will wake up at max frequency of policy
NeoLKernel/drivers/cpufreq/cpufreq_savagedzen.c: * to minimize wakeup issues.
NeoLKernel/drivers/cpufreq/cpufreq_savagedzen.c:static unsigned int sleep_wakeup_freq;
NeoLKernel/drivers/cpufreq/cpufreq_savagedzen.c: * When awake_min_freq>0 the frequency when not suspended will not
NeoLKernel/drivers/cpufreq/cpufreq_savagedzen.c: * Set awake_min_freq=0 to disable this behavior.
NeoLKernel/drivers/cpufreq/cpufreq_savagedzen.c:static unsigned int awake_min_freq;
NeoLKernel/drivers/cpufreq/cpufreq_savagedzen.c:                this_savagedzen->min_speed = // awake_min_freq; but make sure it obeys the policy min/max
NeoLKernel/drivers/cpufreq/cpufreq_savagedzen.c:                        policy->min < awake_min_freq ? (awake_min_freq < policy->max ? awake_min_freq : policy->max) : policy->min;
NeoLKernel/drivers/cpufreq/cpufreq_savagedzen.c:static ssize_t show_sleep_wakeup_freq(struct cpufreq_policy *policy, char *buf)
NeoLKernel/drivers/cpufreq/cpufreq_savagedzen.c:        return sprintf(buf, "%u\n", sleep_wakeup_freq);
NeoLKernel/drivers/cpufreq/cpufreq_savagedzen.c:static ssize_t store_sleep_wakeup_freq(struct cpufreq_policy *policy, const char *buf, size_t count)
NeoLKernel/drivers/cpufreq/cpufreq_savagedzen.c:          sleep_wakeup_freq = input;
NeoLKernel/drivers/cpufreq/cpufreq_savagedzen.c:static struct freq_attr sleep_wakeup_freq_attr = __ATTR(sleep_wakeup_freq, 0644,
NeoLKernel/drivers/cpufreq/cpufreq_savagedzen.c:                show_sleep_wakeup_freq, store_sleep_wakeup_freq);
NeoLKernel/drivers/cpufreq/cpufreq_savagedzen.c:static ssize_t show_awake_min_freq(struct cpufreq_policy *policy, char *buf)
NeoLKernel/drivers/cpufreq/cpufreq_savagedzen.c:        return sprintf(buf, "%u\n", awake_min_freq);
NeoLKernel/drivers/cpufreq/cpufreq_savagedzen.c:static ssize_t store_awake_min_freq(struct cpufreq_policy *policy, const char *buf, size_t count)
NeoLKernel/drivers/cpufreq/cpufreq_savagedzen.c:          awake_min_freq = input;
NeoLKernel/drivers/cpufreq/cpufreq_savagedzen.c:static struct freq_attr awake_min_freq_attr = __ATTR(awake_min_freq, 0644,
NeoLKernel/drivers/cpufreq/cpufreq_savagedzen.c:                show_awake_min_freq, store_awake_min_freq);
NeoLKernel/drivers/cpufreq/cpufreq_savagedzen.c:        &sleep_wakeup_freq_attr.attr,
NeoLKernel/drivers/cpufreq/cpufreq_savagedzen.c:        &awake_min_freq_attr.attr,
NeoLKernel/drivers/cpufreq/cpufreq_savagedzen.c:                new_freq = validate_freq(this_savagedzen,sleep_wakeup_freq);
NeoLKernel/drivers/cpufreq/cpufreq_savagedzen.c:        sleep_wakeup_freq = DEFAULT_SLEEP_WAKEUP_FREQ;
NeoLKernel/drivers/cpufreq/cpufreq_savagedzen.c:        awake_min_freq = DEFAULT_AWAKE_MIN_FREQ;
NeoLKernel/drivers/cpufreq/cpufreq_smartass.c: * by this frequency. Also will wake up at max frequency of policy
NeoLKernel/drivers/cpufreq/cpufreq_smartass.c: * to minimize wakeup issues.
NeoLKernel/drivers/cpufreq/cpufreq_smartass.c:static unsigned int sleep_wakeup_freq;
NeoLKernel/drivers/cpufreq/cpufreq_smartass.c: * When awake_min_freq>0 the frequency when not suspended will not
NeoLKernel/drivers/cpufreq/cpufreq_smartass.c: * Set awake_min_freq=0 to disable this behavior.
NeoLKernel/drivers/cpufreq/cpufreq_smartass.c:static unsigned int awake_min_freq;
NeoLKernel/drivers/cpufreq/cpufreq_smartass.c:                this_smartass->min_speed = // awake_min_freq; but make sure it obeys the policy min/max
NeoLKernel/drivers/cpufreq/cpufreq_smartass.c:                        policy->min < awake_min_freq ? (awake_min_freq < policy->max ? awake_min_freq : policy->max) : policy->min;
NeoLKernel/drivers/cpufreq/cpufreq_smartass.c:static ssize_t show_sleep_wakeup_freq(struct cpufreq_policy *policy, char *buf)
NeoLKernel/drivers/cpufreq/cpufreq_smartass.c:        return sprintf(buf, "%u\n", sleep_wakeup_freq);
NeoLKernel/drivers/cpufreq/cpufreq_smartass.c:static ssize_t store_sleep_wakeup_freq(struct cpufreq_policy *policy, const char *buf, size_t count)
NeoLKernel/drivers/cpufreq/cpufreq_smartass.c:          sleep_wakeup_freq = input;
NeoLKernel/drivers/cpufreq/cpufreq_smartass.c:static struct freq_attr sleep_wakeup_freq_attr = __ATTR(sleep_wakeup_freq, 0644,
NeoLKernel/drivers/cpufreq/cpufreq_smartass.c:                show_sleep_wakeup_freq, store_sleep_wakeup_freq);
NeoLKernel/drivers/cpufreq/cpufreq_smartass.c:static ssize_t show_awake_min_freq(struct cpufreq_policy *policy, char *buf)
NeoLKernel/drivers/cpufreq/cpufreq_smartass.c:        return sprintf(buf, "%u\n", awake_min_freq);
NeoLKernel/drivers/cpufreq/cpufreq_smartass.c:static ssize_t store_awake_min_freq(struct cpufreq_policy *policy, const char *buf, size_t count)
NeoLKernel/drivers/cpufreq/cpufreq_smartass.c:          awake_min_freq = input;
NeoLKernel/drivers/cpufreq/cpufreq_smartass.c:static struct freq_attr awake_min_freq_attr = __ATTR(awake_min_freq, 0644,
NeoLKernel/drivers/cpufreq/cpufreq_smartass.c:                show_awake_min_freq, store_awake_min_freq);
NeoLKernel/drivers/cpufreq/cpufreq_smartass.c:        &sleep_wakeup_freq_attr.attr,
NeoLKernel/drivers/cpufreq/cpufreq_smartass.c:        &awake_min_freq_attr.attr,
NeoLKernel/drivers/cpufreq/cpufreq_smartass.c:                new_freq = validate_freq(this_smartass,sleep_wakeup_freq);
NeoLKernel/drivers/cpufreq/cpufreq_smartass.c:                // to avoid wakeup issues with quick sleep/wakeup don't change actual frequency when entering sleep
NeoLKernel/drivers/cpufreq/cpufreq_smartass.c:        sleep_wakeup_freq = DEFAULT_SLEEP_WAKEUP_FREQ;
NeoLKernel/drivers/cpufreq/cpufreq_smartass.c:        awake_min_freq = DEFAULT_AWAKE_MIN_FREQ;
NeoLKernel/drivers/cpufreq/cpufreq_smartass2.c: * The "ideal" frequency to use when awake. The governor will ramp up faster
NeoLKernel/drivers/cpufreq/cpufreq_smartass2.c:static unsigned int awake_ideal_freq;
NeoLKernel/drivers/cpufreq/cpufreq_smartass2.c: * that practically when sleep_ideal_freq==0 the awake_ideal_freq is used
NeoLKernel/drivers/cpufreq/cpufreq_smartass2.c:static unsigned int sleep_wakeup_freq;
NeoLKernel/drivers/cpufreq/cpufreq_smartass2.c:		this_smartass->ideal_speed = // awake_ideal_freq; but make sure it obeys the policy min/max
NeoLKernel/drivers/cpufreq/cpufreq_smartass2.c:			policy->min < awake_ideal_freq ?
NeoLKernel/drivers/cpufreq/cpufreq_smartass2.c:			(awake_ideal_freq < policy->max ? awake_ideal_freq : policy->max) : policy->min;
NeoLKernel/drivers/cpufreq/cpufreq_smartass2.c:		// (idle cycles wake up the timer when the timer comes)
NeoLKernel/drivers/cpufreq/cpufreq_smartass2.c:static ssize_t show_sleep_wakeup_freq(struct kobject *kobj, struct attribute *attr, char *buf)
NeoLKernel/drivers/cpufreq/cpufreq_smartass2.c:	return sprintf(buf, "%u\n", sleep_wakeup_freq);
NeoLKernel/drivers/cpufreq/cpufreq_smartass2.c:static ssize_t store_sleep_wakeup_freq(struct kobject *kobj, struct attribute *attr, const char *buf, size_t count)
NeoLKernel/drivers/cpufreq/cpufreq_smartass2.c:		sleep_wakeup_freq = input;
NeoLKernel/drivers/cpufreq/cpufreq_smartass2.c:static ssize_t show_awake_ideal_freq(struct kobject *kobj, struct attribute *attr, char *buf)
NeoLKernel/drivers/cpufreq/cpufreq_smartass2.c:	return sprintf(buf, "%u\n", awake_ideal_freq);
NeoLKernel/drivers/cpufreq/cpufreq_smartass2.c:static ssize_t store_awake_ideal_freq(struct kobject *kobj, struct attribute *attr, const char *buf, size_t count)
NeoLKernel/drivers/cpufreq/cpufreq_smartass2.c:		awake_ideal_freq = input;
NeoLKernel/drivers/cpufreq/cpufreq_smartass2.c:define_global_rw_attr(sleep_wakeup_freq);
NeoLKernel/drivers/cpufreq/cpufreq_smartass2.c:define_global_rw_attr(awake_ideal_freq);
NeoLKernel/drivers/cpufreq/cpufreq_smartass2.c:	&sleep_wakeup_freq_attr.attr,
NeoLKernel/drivers/cpufreq/cpufreq_smartass2.c:	&awake_ideal_freq_attr.attr,
NeoLKernel/drivers/cpufreq/cpufreq_smartass2.c:		new_freq = validate_freq(policy,sleep_wakeup_freq);
NeoLKernel/drivers/cpufreq/cpufreq_smartass2.c:		// to avoid wakeup issues with quick sleep/wakeup don't change actual frequency when entering sleep
NeoLKernel/drivers/cpufreq/cpufreq_smartass2.c:	sleep_wakeup_freq = DEFAULT_SLEEP_WAKEUP_FREQ;
NeoLKernel/drivers/cpufreq/cpufreq_smartass2.c:	awake_ideal_freq = DEFAULT_AWAKE_IDEAL_FREQ;
NeoLKernel/drivers/cpufreq/cpufreq_smoothass.c: * by this frequency. Also will wake up at max frequency of policy
NeoLKernel/drivers/cpufreq/cpufreq_smoothass.c: * to minimize wakeup issues.
NeoLKernel/drivers/cpufreq/cpufreq_smoothass.c:			// jump straight to sleep_max_freq to avoid wakeup problems
NeoLKernel/drivers/cpufreq/cpufreq_superbad.c: * by this frequency. Also will wake up at max frequency of policy
NeoLKernel/drivers/cpufreq/cpufreq_superbad.c: * to minimize wakeup issues.
NeoLKernel/drivers/cpufreq/cpufreq_superbad.c:			// jump straight to sleep_max_freq to avoid wakeup problems
NeoLKernel/drivers/cpufreq/cpufreq_virtuous.c: * by this frequency. Also will wake up at max frequency of policy
NeoLKernel/drivers/cpufreq/cpufreq_virtuous.c: * to minimize wakeup issues.
NeoLKernel/drivers/cpufreq/cpufreq_virtuous.c:                        // jump straight to sleep_max_freq to avoid wakeup problems
NeoLKernel/drivers/cpufreq/cpufreq_brazilianwax.c: * by this frequency. Also will wake up at max frequency of policy
NeoLKernel/drivers/cpufreq/cpufreq_brazilianwax.c: * to minimize wakeup issues.
NeoLKernel/drivers/cpufreq/cpufreq_brazilianwax.c:static unsigned int sleep_wakeup_freq;
NeoLKernel/drivers/cpufreq/cpufreq_brazilianwax.c: * When awake_min_freq>0 the frequency when not suspended will not
NeoLKernel/drivers/cpufreq/cpufreq_brazilianwax.c: * Set awake_min_freq=0 to disable this behavior.
NeoLKernel/drivers/cpufreq/cpufreq_brazilianwax.c:static unsigned int awake_min_freq;
NeoLKernel/drivers/cpufreq/cpufreq_brazilianwax.c:                this_brazilianwax->min_speed = // awake_min_freq; but make sure it obeys the policy min/max
NeoLKernel/drivers/cpufreq/cpufreq_brazilianwax.c:                        policy->min < awake_min_freq ? (awake_min_freq < policy->max ? awake_min_freq : policy->max) : policy->min;
NeoLKernel/drivers/cpufreq/cpufreq_brazilianwax.c:				new_freq = awake_min_freq;
NeoLKernel/drivers/cpufreq/cpufreq_brazilianwax.c:static ssize_t show_sleep_wakeup_freq(struct cpufreq_policy *policy, char *buf)
NeoLKernel/drivers/cpufreq/cpufreq_brazilianwax.c:        return sprintf(buf, "%u\n", sleep_wakeup_freq);
NeoLKernel/drivers/cpufreq/cpufreq_brazilianwax.c:static ssize_t store_sleep_wakeup_freq(struct cpufreq_policy *policy, const char *buf, size_t count)
NeoLKernel/drivers/cpufreq/cpufreq_brazilianwax.c:          sleep_wakeup_freq = input;
NeoLKernel/drivers/cpufreq/cpufreq_brazilianwax.c:static struct freq_attr sleep_wakeup_freq_attr = __ATTR(sleep_wakeup_freq, 0644,
NeoLKernel/drivers/cpufreq/cpufreq_brazilianwax.c:                show_sleep_wakeup_freq, store_sleep_wakeup_freq);
NeoLKernel/drivers/cpufreq/cpufreq_brazilianwax.c:static ssize_t show_awake_min_freq(struct cpufreq_policy *policy, char *buf)
NeoLKernel/drivers/cpufreq/cpufreq_brazilianwax.c:        return sprintf(buf, "%u\n", awake_min_freq);
NeoLKernel/drivers/cpufreq/cpufreq_brazilianwax.c:static ssize_t store_awake_min_freq(struct cpufreq_policy *policy, const char *buf, size_t count)
NeoLKernel/drivers/cpufreq/cpufreq_brazilianwax.c:          awake_min_freq = input;
NeoLKernel/drivers/cpufreq/cpufreq_brazilianwax.c:static struct freq_attr awake_min_freq_attr = __ATTR(awake_min_freq, 0644,
NeoLKernel/drivers/cpufreq/cpufreq_brazilianwax.c:                show_awake_min_freq, store_awake_min_freq);
NeoLKernel/drivers/cpufreq/cpufreq_brazilianwax.c:        &sleep_wakeup_freq_attr.attr,
NeoLKernel/drivers/cpufreq/cpufreq_brazilianwax.c:        &awake_min_freq_attr.attr,
NeoLKernel/drivers/cpufreq/cpufreq_brazilianwax.c:                new_freq = validate_freq(this_brazilianwax,sleep_wakeup_freq);
NeoLKernel/drivers/cpufreq/cpufreq_brazilianwax.c:        	pr_info("[imoseyon] brazilianwax awake at %d\n", policy->cur);
NeoLKernel/drivers/cpufreq/cpufreq_brazilianwax.c:                // to avoid wakeup issues with quick sleep/wakeup don't change actual frequency when entering sleep
NeoLKernel/drivers/cpufreq/cpufreq_brazilianwax.c:        sleep_wakeup_freq = DEFAULT_SLEEP_WAKEUP_FREQ;
NeoLKernel/drivers/cpufreq/cpufreq_brazilianwax.c:        awake_min_freq = DEFAULT_AWAKE_MIN_FREQ;
NeoLKernel/drivers/cpufreq/cpufreq_darkside.c: * by this frequency. Also will wake up at max frequency of policy
NeoLKernel/drivers/cpufreq/cpufreq_darkside.c: * to minimize wakeup issues.
NeoLKernel/drivers/cpufreq/cpufreq_darkside.c:static unsigned int sleep_wakeup_freq;
NeoLKernel/drivers/cpufreq/cpufreq_darkside.c: * When awake_min_freq>0 the frequency when not suspended will not
NeoLKernel/drivers/cpufreq/cpufreq_darkside.c: * Set awake_min_freq=0 to disable this behavior.
NeoLKernel/drivers/cpufreq/cpufreq_darkside.c:static unsigned int awake_min_freq;
NeoLKernel/drivers/cpufreq/cpufreq_darkside.c:                this_darkside->min_speed = // awake_min_freq; but make sure it obeys the policy min/max
NeoLKernel/drivers/cpufreq/cpufreq_darkside.c:                        policy->min < awake_min_freq ? (awake_min_freq < policy->max ? awake_min_freq : policy->max) : policy->min;
NeoLKernel/drivers/cpufreq/cpufreq_darkside.c:				new_freq = awake_min_freq;
NeoLKernel/drivers/cpufreq/cpufreq_darkside.c:static ssize_t show_sleep_wakeup_freq(struct cpufreq_policy *policy, char *buf)
NeoLKernel/drivers/cpufreq/cpufreq_darkside.c:        return sprintf(buf, "%u\n", sleep_wakeup_freq);
NeoLKernel/drivers/cpufreq/cpufreq_darkside.c:static ssize_t store_sleep_wakeup_freq(struct cpufreq_policy *policy, const char *buf, size_t count)
NeoLKernel/drivers/cpufreq/cpufreq_darkside.c:          sleep_wakeup_freq = input;
NeoLKernel/drivers/cpufreq/cpufreq_darkside.c:static struct freq_attr sleep_wakeup_freq_attr = __ATTR(sleep_wakeup_freq, 0644,
NeoLKernel/drivers/cpufreq/cpufreq_darkside.c:                show_sleep_wakeup_freq, store_sleep_wakeup_freq);
NeoLKernel/drivers/cpufreq/cpufreq_darkside.c:static ssize_t show_awake_min_freq(struct cpufreq_policy *policy, char *buf)
NeoLKernel/drivers/cpufreq/cpufreq_darkside.c:        return sprintf(buf, "%u\n", awake_min_freq);
NeoLKernel/drivers/cpufreq/cpufreq_darkside.c:static ssize_t store_awake_min_freq(struct cpufreq_policy *policy, const char *buf, size_t count)
NeoLKernel/drivers/cpufreq/cpufreq_darkside.c:          awake_min_freq = input;
NeoLKernel/drivers/cpufreq/cpufreq_darkside.c:static struct freq_attr awake_min_freq_attr = __ATTR(awake_min_freq, 0644,
NeoLKernel/drivers/cpufreq/cpufreq_darkside.c:                show_awake_min_freq, store_awake_min_freq);
NeoLKernel/drivers/cpufreq/cpufreq_darkside.c:        &sleep_wakeup_freq_attr.attr,
NeoLKernel/drivers/cpufreq/cpufreq_darkside.c:        &awake_min_freq_attr.attr,
NeoLKernel/drivers/cpufreq/cpufreq_darkside.c:                new_freq = validate_freq(this_darkside,sleep_wakeup_freq);
NeoLKernel/drivers/cpufreq/cpufreq_darkside.c:        	pr_info("[imoseyon] darkside awake at %d\n", policy->cur);
NeoLKernel/drivers/cpufreq/cpufreq_darkside.c:                // to avoid wakeup issues with quick sleep/wakeup don't change actual frequency when entering sleep
NeoLKernel/drivers/cpufreq/cpufreq_darkside.c:        sleep_wakeup_freq = DEFAULT_SLEEP_WAKEUP_FREQ;
NeoLKernel/drivers/cpufreq/cpufreq_darkside.c:        awake_min_freq = DEFAULT_AWAKE_MIN_FREQ;
NeoLKernel/drivers/cpufreq/cpufreq_interactive.c:		wake_up_process(up_task);
NeoLKernel/drivers/cpufreq/cpufreq_interactivex.c: * Author: Mike Chan (mike@android.com) - modified for suspend/wake by imoseyon
NeoLKernel/drivers/cpufreq/cpufreq_interactivex.c:                pr_info("[imoseyon] interactiveX awake at %d\n", policy->cur);
NeoLKernel/drivers/cpufreq/cpufreq_lulzactive.c:		wake_up_process(up_task);
NeoLKernel/drivers/cpuidle/cpuidle.c: * wakes them all right up.
NeoLKernel/drivers/cpuidle/governors/menu.c: * Since there are other source of wakeups (interrupts for example) than
NeoLKernel/drivers/crypto/mv_cesa.c:	wake_up_process(cpg->queue_th);
NeoLKernel/drivers/crypto/mv_cesa.c:	wake_up_process(cpg->queue_th);
NeoLKernel/drivers/edac/e752x_edac.c:	/* wake up and enable device */
NeoLKernel/drivers/edac/e7xxx_edac.c:	/* wake up and enable device */
NeoLKernel/drivers/edac/i5000_edac.c:	/* wake up device */
NeoLKernel/drivers/edac/i5400_edac.c:	/* wake up device */
NeoLKernel/drivers/eisa/eisa-bus.c:		 * This ugly stuff is used to wake up VL-bus cards
NeoLKernel/drivers/message/fusion/mptbase.c:	pci_enable_wake(pdev, PCI_D0, 0);
NeoLKernel/drivers/message/fusion/mptbase.c:/* wake up mptbase_cmds */
NeoLKernel/drivers/message/fusion/mptbase.c:/* wake up taskmgmt_cmds */
NeoLKernel/drivers/message/fusion/mptctl.c:	/* We are done, issue wake up
NeoLKernel/drivers/message/fusion/mptlan.c:static void mpt_lan_wake_post_buckets_task(struct net_device *dev,
NeoLKernel/drivers/message/fusion/mptlan.c:		netif_wake_queue(dev);
NeoLKernel/drivers/message/fusion/mptlan.c:		dlprintk (("mptlan/tx_timeout: calling netif_wake_queue for %s.\n", dev->name));
NeoLKernel/drivers/message/fusion/mptlan.c:		netif_wake_queue(dev);
NeoLKernel/drivers/message/fusion/mptlan.c:	netif_wake_queue(dev);
NeoLKernel/drivers/message/fusion/mptlan.c:	netif_wake_queue(dev);
NeoLKernel/drivers/message/fusion/mptlan.c:mpt_lan_wake_post_buckets_task(struct net_device *dev, int priority)
NeoLKernel/drivers/message/fusion/mptlan.c:		mpt_lan_wake_post_buckets_task(dev, 1);
NeoLKernel/drivers/message/fusion/mptlan.c:		mpt_lan_wake_post_buckets_task(dev, 0);
NeoLKernel/drivers/message/i2o/exec-osm.c: *	and the task will be waked up. The task is now responsible for returning
NeoLKernel/drivers/message/i2o/exec-osm.c:				wake_up_interruptible(wait->wq);
NeoLKernel/drivers/mfd/pmic8058.c:	u8	wake_enable[MAX_PM_IRQ];
NeoLKernel/drivers/mfd/pmic8058.c:	u16	count_wakeable;
NeoLKernel/drivers/mfd/pmic8058.c:static int pm8058_irq_set_wake(unsigned int irq, unsigned int on)
NeoLKernel/drivers/mfd/pmic8058.c:		if (!chip->wake_enable[irq]) {
NeoLKernel/drivers/mfd/pmic8058.c:			chip->wake_enable[irq] = 1;
NeoLKernel/drivers/mfd/pmic8058.c:			chip->count_wakeable++;
NeoLKernel/drivers/mfd/pmic8058.c:		if (chip->wake_enable[irq]) {
NeoLKernel/drivers/mfd/pmic8058.c:			chip->wake_enable[irq] = 0;
NeoLKernel/drivers/mfd/pmic8058.c:			chip->count_wakeable--;
NeoLKernel/drivers/mfd/pmic8058.c:	.set_wake  = pm8058_irq_set_wake,
NeoLKernel/drivers/mfd/pmic8058.c:	set_irq_wake(chip->dev->irq, 1);
NeoLKernel/drivers/mfd/pmic8058.c:			set_irq_wake(chip->dev->irq, 0);
NeoLKernel/drivers/mfd/pmic8058.c:		if (!chip->wake_enable[i] &&
NeoLKernel/drivers/mfd/pmic8058.c:	if (!chip->count_wakeable)
NeoLKernel/drivers/mfd/pmic8058.c:		if (!chip->wake_enable[i] &&
NeoLKernel/drivers/mfd/pmic8058.c:	if (!chip->count_wakeable)
NeoLKernel/drivers/mfd/dm355evm_msp.c:		bool can_wakeup, int irq)
NeoLKernel/drivers/mfd/dm355evm_msp.c:	device_init_wakeup(&pdev->dev, can_wakeup);
NeoLKernel/drivers/mfd/ezx-pcap.c:	set_irq_wake(spi->irq, 1);
NeoLKernel/drivers/mfd/htc-egpio.c:int htc_egpio_get_wakeup_irq(struct device *dev)
NeoLKernel/drivers/mfd/htc-egpio.c:EXPORT_SYMBOL(htc_egpio_get_wakeup_irq);
NeoLKernel/drivers/mfd/htc-egpio.c:		device_init_wakeup(&pdev->dev, 1);
NeoLKernel/drivers/mfd/htc-egpio.c:		device_init_wakeup(&pdev->dev, 0);
NeoLKernel/drivers/mfd/htc-egpio.c:	if (ei->chained_irq && device_may_wakeup(&pdev->dev))
NeoLKernel/drivers/mfd/htc-egpio.c:		enable_irq_wake(ei->chained_irq);
NeoLKernel/drivers/mfd/htc-egpio.c:	if (ei->chained_irq && device_may_wakeup(&pdev->dev))
NeoLKernel/drivers/mfd/htc-egpio.c:		disable_irq_wake(ei->chained_irq);
NeoLKernel/drivers/mfd/Kconfig:	  or reset when a sleep, wakeup or warm reset event occurs.
NeoLKernel/drivers/mfd/pmic8901.c:	u8	wake_enable[MAX_PM_IRQ];
NeoLKernel/drivers/mfd/pmic8901.c:	u16	count_wakeable;
NeoLKernel/drivers/mfd/pmic8901.c:static int pm8901_irq_set_wake(unsigned int irq, unsigned int on)
NeoLKernel/drivers/mfd/pmic8901.c:		if (!chip->wake_enable[irq]) {
NeoLKernel/drivers/mfd/pmic8901.c:			chip->wake_enable[irq] = 1;
NeoLKernel/drivers/mfd/pmic8901.c:			chip->count_wakeable++;
NeoLKernel/drivers/mfd/pmic8901.c:		if (chip->wake_enable[irq]) {
NeoLKernel/drivers/mfd/pmic8901.c:			chip->wake_enable[irq] = 0;
NeoLKernel/drivers/mfd/pmic8901.c:			chip->count_wakeable--;
NeoLKernel/drivers/mfd/pmic8901.c:	.set_wake  = pm8901_irq_set_wake,
NeoLKernel/drivers/mfd/pmic8901.c:	set_irq_wake(chip->dev->irq, 1);
NeoLKernel/drivers/mfd/pmic8901.c:			set_irq_wake(chip->dev->irq, 0);
NeoLKernel/drivers/mfd/pmic8901.c:		if (chip->config[i] && !chip->wake_enable[i]) {
NeoLKernel/drivers/mfd/pmic8901.c:	if (!chip->count_wakeable)
NeoLKernel/drivers/mfd/pmic8901.c:		if (chip->config[i] && !chip->wake_enable[i]) {
NeoLKernel/drivers/mfd/pmic8901.c:	if (!chip->count_wakeable)
NeoLKernel/drivers/mfd/twl4030-core.c:		bool can_wakeup, int irq0, int irq1)
NeoLKernel/drivers/mfd/twl4030-core.c:	device_init_wakeup(&pdev->dev, can_wakeup);
NeoLKernel/drivers/mfd/twl4030-core.c:		bool can_wakeup, int irq0, int irq1)
NeoLKernel/drivers/mfd/twl4030-core.c:		can_wakeup, irq0, irq1);
NeoLKernel/drivers/mfd/twl4030-irq.c: * thread.  All we do here is acknowledge and mask the interrupt and wakeup
NeoLKernel/drivers/mfd/twl4030-power.c:static int __init twl4030_config_wakeup3_sequence(u8 address)
NeoLKernel/drivers/mfd/twl4030-power.c:		pr_err("TWL4030 wakeup sequence for P3 config error\n");
NeoLKernel/drivers/mfd/twl4030-power.c:static int __init twl4030_config_wakeup12_sequence(u8 address)
NeoLKernel/drivers/mfd/twl4030-power.c:		pr_err("TWL4030 wakeup sequence for P1 and P2" \
NeoLKernel/drivers/mfd/twl4030-power.c:		err = twl4030_config_wakeup12_sequence(address);
NeoLKernel/drivers/mfd/twl4030-power.c:		err = twl4030_config_wakeup3_sequence(address);
NeoLKernel/drivers/mfd/twl4030-power.c:					"script before wakeup) Leads to boot"\
NeoLKernel/drivers/mfd/ucb1x00-ts.c:	wake_up(&ts->irq_wait);
NeoLKernel/drivers/mfd/ucb1x00-ts.c:		wake_up(&ts->irq_wait);
NeoLKernel/drivers/mfd/wm8350-core.c:	/* wake, codec, ext */
NeoLKernel/drivers/mfd/marimba-tsadc.c:	if (!(device_may_wakeup(dev) &&
NeoLKernel/drivers/mfd/marimba-tsadc.c:			device_may_wakeup(tsadc->child_tssc))) {
NeoLKernel/drivers/mfd/marimba-tsadc.c:	if (!(device_may_wakeup(dev) &&
NeoLKernel/drivers/mfd/marimba-tsadc.c:			device_may_wakeup(tsadc->child_tssc))) {
NeoLKernel/drivers/mfd/marimba-tsadc.c:	device_init_wakeup(&pdev->dev, pdata->can_wakeup);
NeoLKernel/drivers/mfd/marimba-tsadc.c:	device_init_wakeup(&pdev->dev, 0);
NeoLKernel/drivers/mfd/mc13783-core.c:/* set adc to ts interrupt mode, which generates touchscreen wakeup interrupt */
NeoLKernel/drivers/mfd/menelaus.c: * It supports alarms, including system wake alarms (from some modes);
NeoLKernel/drivers/mfd/menelaus.c:	/* support RTC alarm; it can issue wakeups */
NeoLKernel/drivers/mfd/menelaus.c:		device_init_wakeup(&m->client->dev, 1);
NeoLKernel/drivers/mfd/menelaus.c:			device_init_wakeup(&m->client->dev, 0);
NeoLKernel/drivers/mfd/pcf50633-core.c:	/* Write wakeup irq masks */
NeoLKernel/drivers/mfd/pcf50633-core.c:		dev_err(pcf->dev, "error writing wakeup irq masks\n");
NeoLKernel/drivers/mfd/pcf50633-core.c:	if (enable_irq_wake(client->irq) < 0)
NeoLKernel/drivers/mfd/pcf50633-core.c:		dev_err(pcf->dev, "IRQ %u cannot be enabled as wake-up source"
NeoLKernel/drivers/misc/apanic.c:#include <linux/wakelock.h>
NeoLKernel/drivers/misc/apanic.c:	wake_up(wait_q);
NeoLKernel/drivers/misc/hpilo.c:		/* wake up all ccbs if the device was reset */
NeoLKernel/drivers/misc/hpilo.c:			wake_up_interruptible(&hw->ccb_alloc[i]->ccb_waitq);
NeoLKernel/drivers/misc/ibmasm/command.c:		wake_up(&sp->current_command->wait);
NeoLKernel/drivers/misc/ibmasm/command.c:	wake_up(&sp->current_command->wait);
NeoLKernel/drivers/misc/ibmasm/event.c:static void wake_up_event_readers(struct service_processor *sp)
NeoLKernel/drivers/misc/ibmasm/event.c:                wake_up_interruptible(&reader->wait);
NeoLKernel/drivers/misc/ibmasm/event.c: * Store the event in the circular event buffer, wake up any sleeping
NeoLKernel/drivers/misc/ibmasm/event.c:	wake_up_event_readers(sp);
NeoLKernel/drivers/misc/ibmasm/event.c:        wake_up_interruptible(&reader->wait);
NeoLKernel/drivers/misc/ibmasm/ibmasmfs.c: *      write: wakeup sleeping event listener
NeoLKernel/drivers/misc/ibmasm/ibmasmfs.c: *      write: wakeup sleeping heartbeat listener
NeoLKernel/drivers/misc/ibmasm/r_heartbeat.c:	wake_up_interruptible(&rhb->wait);
NeoLKernel/drivers/misc/phantom.c:	wake_up_interruptible(&dev->wait);
NeoLKernel/drivers/misc/sgi-gru/grukservices.c: * 		  driver will do a wakeup on the event.
NeoLKernel/drivers/misc/sgi-gru/grutlbpurge.c:	wake_up_all(&gms->ms_wait_queue);
NeoLKernel/drivers/misc/sgi-xp/xpc.h:xpc_wakeup_channel_mgr(struct xpc_partition *part)
NeoLKernel/drivers/misc/sgi-xp/xpc.h:		wake_up(&part->channel_mgr_wq);
NeoLKernel/drivers/misc/sgi-xp/xpc.h:		xpc_wakeup_channel_mgr(&xpc_partitions[ch->partid]);
NeoLKernel/drivers/misc/sgi-xp/xpc.h:		wake_up(&part->teardown_wq);
NeoLKernel/drivers/misc/sgi-xp/xpc_channel.c:	/* wake those waiting for notify completion */
NeoLKernel/drivers/misc/sgi-xp/xpc_channel.c:	xpc_wakeup_channel_mgr(part);
NeoLKernel/drivers/misc/sgi-xp/xpc_channel.c:			xpc_wakeup_channel_mgr(part);
NeoLKernel/drivers/misc/sgi-xp/xpc_channel.c:	/* wake all idle kthreads so they can exit */
NeoLKernel/drivers/misc/sgi-xp/xpc_channel.c:		wake_up_all(&ch->idle_wq);
NeoLKernel/drivers/misc/sgi-xp/xpc_channel.c:	/* wake those waiting to allocate an entry from the local msg queue */
NeoLKernel/drivers/misc/sgi-xp/xpc_channel.c:		wake_up(&ch->msg_allocate_wq);
NeoLKernel/drivers/misc/sgi-xp/xpc_main.c:		wake_up_interruptible(&xpc_activate_IRQ_wq);
NeoLKernel/drivers/misc/sgi-xp/xpc_main.c:		 * The channel_mgr_requests is set to 1 after being awakened,
NeoLKernel/drivers/misc/sgi-xp/xpc_main.c:		 * wake him up.
NeoLKernel/drivers/misc/sgi-xp/xpc_main.c:	int wakeup;
NeoLKernel/drivers/misc/sgi-xp/xpc_main.c:		wakeup = (needed > idle) ? idle : needed;
NeoLKernel/drivers/misc/sgi-xp/xpc_main.c:		needed -= wakeup;
NeoLKernel/drivers/misc/sgi-xp/xpc_main.c:		dev_dbg(xpc_chan, "wakeup %d idle kthreads, partid=%d, "
NeoLKernel/drivers/misc/sgi-xp/xpc_main.c:			"channel=%d\n", wakeup, ch->partid, ch->number);
NeoLKernel/drivers/misc/sgi-xp/xpc_main.c:		/* only wakeup the requested number of kthreads */
NeoLKernel/drivers/misc/sgi-xp/xpc_main.c:		wake_up_nr(&ch->idle_wq, wakeup);
NeoLKernel/drivers/misc/sgi-xp/xpc_main.c:	int wakeup_channel_mgr;
NeoLKernel/drivers/misc/sgi-xp/xpc_main.c:		wakeup_channel_mgr = 0;
NeoLKernel/drivers/misc/sgi-xp/xpc_main.c:				wakeup_channel_mgr = 1;
NeoLKernel/drivers/misc/sgi-xp/xpc_main.c:		if (wakeup_channel_mgr)
NeoLKernel/drivers/misc/sgi-xp/xpc_main.c:			xpc_wakeup_channel_mgr(part);
NeoLKernel/drivers/misc/sgi-xp/xpc_main.c:	 * (if one is running) know that they should exit. Also wake up
NeoLKernel/drivers/misc/sgi-xp/xpc_main.c:	wake_up_interruptible(&xpc_activate_IRQ_wq);
NeoLKernel/drivers/misc/sgi-xp/xpc_partition.c:			xpc_wakeup_channel_mgr(part);
NeoLKernel/drivers/misc/sgi-xp/xpc_sn2.c:	wake_up_interruptible(&xpc_activate_IRQ_wq);
NeoLKernel/drivers/misc/sgi-xp/xpc_sn2.c:	wake_up_interruptible(&xpc_activate_IRQ_wq);
NeoLKernel/drivers/misc/sgi-xp/xpc_sn2.c:	xpc_wakeup_channel_mgr(part);
NeoLKernel/drivers/misc/sgi-xp/xpc_sn2.c: * whether a partition has sent an IRQ or not.  If it has, then wake up the
NeoLKernel/drivers/misc/sgi-xp/xpc_sn2.c:		 * available, wake them up.
NeoLKernel/drivers/misc/sgi-xp/xpc_sn2.c:			wake_up(&ch->msg_allocate_wq);
NeoLKernel/drivers/misc/sgi-xp/xpc_uv.c:			      int *wakeup_hb_checker)
NeoLKernel/drivers/misc/sgi-xp/xpc_uv.c:		(*wakeup_hb_checker)++;
NeoLKernel/drivers/misc/sgi-xp/xpc_uv.c:		(*wakeup_hb_checker)++;
NeoLKernel/drivers/misc/sgi-xp/xpc_uv.c:		xpc_wakeup_channel_mgr(part);
NeoLKernel/drivers/misc/sgi-xp/xpc_uv.c:		xpc_wakeup_channel_mgr(part);
NeoLKernel/drivers/misc/sgi-xp/xpc_uv.c:		xpc_wakeup_channel_mgr(part);
NeoLKernel/drivers/misc/sgi-xp/xpc_uv.c:		xpc_wakeup_channel_mgr(part);
NeoLKernel/drivers/misc/sgi-xp/xpc_uv.c:		xpc_wakeup_channel_mgr(part);
NeoLKernel/drivers/misc/sgi-xp/xpc_uv.c:		(*wakeup_hb_checker)++;
NeoLKernel/drivers/misc/sgi-xp/xpc_uv.c:		(*wakeup_hb_checker)++;
NeoLKernel/drivers/misc/sgi-xp/xpc_uv.c:	int wakeup_hb_checker = 0;
NeoLKernel/drivers/misc/sgi-xp/xpc_uv.c:						      &wakeup_hb_checker);
NeoLKernel/drivers/misc/sgi-xp/xpc_uv.c:	if (wakeup_hb_checker)
NeoLKernel/drivers/misc/sgi-xp/xpc_uv.c:		wake_up_interruptible(&xpc_activate_IRQ_wq);
NeoLKernel/drivers/misc/sgi-xp/xpc_uv.c:	wake_up_interruptible(&xpc_activate_IRQ_wq);
NeoLKernel/drivers/misc/sgi-xp/xpc_uv.c:	xpc_wakeup_channel_mgr(part);
NeoLKernel/drivers/misc/sgi-xp/xpc_uv.c:	/* wakeup anyone waiting for a free msg slot */
NeoLKernel/drivers/misc/sgi-xp/xpc_uv.c:		wake_up(&ch->msg_allocate_wq);
NeoLKernel/drivers/misc/sgi-xp/xpc_uv.c:		wake_up_interruptible(&xpc_activate_IRQ_wq);
NeoLKernel/drivers/misc/sgi-xp/xpc_uv.c:			wake_up_nr(&ch->idle_wq, 1);
NeoLKernel/drivers/misc/tifm_7xx1.c:	pci_enable_wake(dev, pci_choose_state(dev, state), 0);
NeoLKernel/drivers/misc/tsif.c:#include <linux/wakelock.h>
NeoLKernel/drivers/misc/tsif.c:	struct wake_lock wake_lock;
NeoLKernel/drivers/misc/tsif.c:			"Runtime PM: Unable to wake up the device, rc = %d\n",
NeoLKernel/drivers/misc/tsif.c:	wake_lock(&tsif_device->wake_lock);
NeoLKernel/drivers/misc/tsif.c:	wake_unlock(&tsif_device->wake_lock);
NeoLKernel/drivers/misc/tsif.c:	wake_lock_init(&tsif_device->wake_lock, WAKE_LOCK_SUSPEND,
NeoLKernel/drivers/misc/tsif.c:	wake_lock_destroy(&tsif_device->wake_lock);
NeoLKernel/drivers/misc/tsif_chrdev.c:	wake_up_interruptible(&the_dev->wq_read);
NeoLKernel/drivers/mmc/card/queue.c:		wake_up_process(mq->thread);
NeoLKernel/drivers/mmc/card/sdio_uart.c:		tty_wakeup(port->tty);
NeoLKernel/drivers/mmc/card/sdio_uart.c:					tty_wakeup(port->tty);
NeoLKernel/drivers/mmc/core/mmc.c:		/* Sleep / awake timeout in 100ns units */
NeoLKernel/drivers/mmc/core/mmc.c:		err = mmc_card_sleepawake(host, 1);
NeoLKernel/drivers/mmc/core/mmc.c:static int mmc_awake(struct mmc_host *host)
NeoLKernel/drivers/mmc/core/mmc.c:		err = mmc_card_sleepawake(host, 0);
NeoLKernel/drivers/mmc/core/mmc.c:	.awake = mmc_awake,
NeoLKernel/drivers/mmc/core/mmc.c:	.awake = mmc_awake,
NeoLKernel/drivers/mmc/core/mmc.c:	.awake = mmc_awake,
NeoLKernel/drivers/mmc/core/core.c:#include <linux/wakelock.h>
NeoLKernel/drivers/mmc/core/core.c:static struct wake_lock mmc_delayed_work_wake_lock;
NeoLKernel/drivers/mmc/core/core.c:	wake_lock(&mmc_delayed_work_wake_lock);
NeoLKernel/drivers/mmc/core/core.c:		wake_up(&host->wq);
NeoLKernel/drivers/mmc/core/core.c:		wake_up(&host->wq);
NeoLKernel/drivers/mmc/core/core.c:	wake_unlock(&mmc_delayed_work_wake_lock);
NeoLKernel/drivers/mmc/core/core.c:	int extend_wakelock = 0;
NeoLKernel/drivers/mmc/core/core.c:		 * as dead - extend the wakelock so userspace
NeoLKernel/drivers/mmc/core/core.c:			extend_wakelock = 1;
NeoLKernel/drivers/mmc/core/core.c:		extend_wakelock = 1;
NeoLKernel/drivers/mmc/core/core.c:		extend_wakelock = 1;
NeoLKernel/drivers/mmc/core/core.c:		extend_wakelock = 1;
NeoLKernel/drivers/mmc/core/core.c:	if (extend_wakelock)
NeoLKernel/drivers/mmc/core/core.c:		wake_lock_timeout(&mmc_delayed_work_wake_lock, HZ / 2);
NeoLKernel/drivers/mmc/core/core.c:		wake_unlock(&mmc_delayed_work_wake_lock);
NeoLKernel/drivers/mmc/core/core.c:int mmc_card_awake(struct mmc_host *host)
NeoLKernel/drivers/mmc/core/core.c:	if (host->bus_ops && !host->bus_dead && host->bus_ops->awake)
NeoLKernel/drivers/mmc/core/core.c:		err = host->bus_ops->awake(host);
NeoLKernel/drivers/mmc/core/core.c:EXPORT_SYMBOL(mmc_card_awake);
NeoLKernel/drivers/mmc/core/core.c:	if (host->bus_ops && !host->bus_dead && host->bus_ops->awake)
NeoLKernel/drivers/mmc/core/core.c:	wake_lock_init(&mmc_delayed_work_wake_lock, WAKE_LOCK_SUSPEND, "mmc_delayed_work");
NeoLKernel/drivers/mmc/core/core.c:	wake_lock_destroy(&mmc_delayed_work_wake_lock);
NeoLKernel/drivers/mmc/core/core.h:	int (*awake)(struct mmc_host *);
NeoLKernel/drivers/mmc/core/mmc_ops.c:int mmc_card_sleepawake(struct mmc_host *host, int sleep)
NeoLKernel/drivers/mmc/core/mmc_ops.c:	 * will have to wait the sleep/awake timeout.  Note, we cannot use the
NeoLKernel/drivers/mmc/core/mmc_ops.h:int mmc_card_sleepawake(struct mmc_host *host, int sleep);
NeoLKernel/drivers/mmc/host/omap.c:	wake_up(&host->slot_wq);
NeoLKernel/drivers/mmc/host/at91_mci.c:			device_init_wakeup(&pdev->dev, 1);
NeoLKernel/drivers/mmc/host/at91_mci.c:		if (device_can_wakeup(&pdev->dev))
NeoLKernel/drivers/mmc/host/at91_mci.c:		device_init_wakeup(&pdev->dev, 0);
NeoLKernel/drivers/mmc/host/at91_mci.c:	if (host->board->det_pin && device_may_wakeup(&pdev->dev))
NeoLKernel/drivers/mmc/host/at91_mci.c:		enable_irq_wake(host->board->det_pin);
NeoLKernel/drivers/mmc/host/at91_mci.c:	if (host->board->det_pin && device_may_wakeup(&pdev->dev))
NeoLKernel/drivers/mmc/host/at91_mci.c:		disable_irq_wake(host->board->det_pin);
NeoLKernel/drivers/mmc/host/msm_sdcc.c:#include <linux/wakelock.h>
NeoLKernel/drivers/mmc/host/msm_sdcc.c:				wake_lock(&host->sdio_suspend_wlock);
NeoLKernel/drivers/mmc/host/msm_sdcc.c:					!host->plat->sdiowakeup_irq) {
NeoLKernel/drivers/mmc/host/msm_sdcc.c:				disable_irq_wake(host->irqres->start);
NeoLKernel/drivers/mmc/host/msm_sdcc.c:				!host->plat->sdiowakeup_irq) {
NeoLKernel/drivers/mmc/host/msm_sdcc.c:			enable_irq_wake(host->irqres->start);
NeoLKernel/drivers/mmc/host/msm_sdcc.c:msmsdcc_platform_sdiowakeup_irq(int irq, void *dev_id)
NeoLKernel/drivers/mmc/host/msm_sdcc.c:			wake_lock(&host->sdio_wlock);
NeoLKernel/drivers/mmc/host/msm_sdcc.c:			disable_irq_wake(irq);
NeoLKernel/drivers/mmc/host/msm_sdcc.c:	if (plat->sdiowakeup_irq) {
NeoLKernel/drivers/mmc/host/msm_sdcc.c:		wake_lock_init(&host->sdio_wlock, WAKE_LOCK_SUSPEND,
NeoLKernel/drivers/mmc/host/msm_sdcc.c:		ret = request_irq(plat->sdiowakeup_irq,
NeoLKernel/drivers/mmc/host/msm_sdcc.c:			msmsdcc_platform_sdiowakeup_irq,
NeoLKernel/drivers/mmc/host/msm_sdcc.c:			DRIVER_NAME "sdiowakeup", host);
NeoLKernel/drivers/mmc/host/msm_sdcc.c:			pr_err("Unable to get sdio wakeup IRQ %d (%d)\n",
NeoLKernel/drivers/mmc/host/msm_sdcc.c:				plat->sdiowakeup_irq, ret);
NeoLKernel/drivers/mmc/host/msm_sdcc.c:			wake_lock_destroy(&host->sdio_wlock);
NeoLKernel/drivers/mmc/host/msm_sdcc.c:				disable_irq_nosync(plat->sdiowakeup_irq);
NeoLKernel/drivers/mmc/host/msm_sdcc.c:	wake_lock_init(&host->sdio_suspend_wlock, WAKE_LOCK_SUSPEND,
NeoLKernel/drivers/mmc/host/msm_sdcc.c:			goto sdiowakeup_irq_free;
NeoLKernel/drivers/mmc/host/msm_sdcc.c:		 * Due to that sdiowakeup_irq is not available for non-SDIO
NeoLKernel/drivers/mmc/host/msm_sdcc.c:		 * wake-up interrupt enables explicitly using enable_irq_wake.
NeoLKernel/drivers/mmc/host/msm_sdcc.c:		device_init_wakeup(&pdev->dev, 1);
NeoLKernel/drivers/mmc/host/msm_sdcc.c:		ret = enable_irq_wake(plat->status_irq);
NeoLKernel/drivers/mmc/host/msm_sdcc.c:			pr_err("enable_irq_wake failed, slot IRQ %d (%d)\n",
NeoLKernel/drivers/mmc/host/msm_sdcc.c: sdiowakeup_irq_free:
NeoLKernel/drivers/mmc/host/msm_sdcc.c:	wake_lock_destroy(&host->sdio_suspend_wlock);
NeoLKernel/drivers/mmc/host/msm_sdcc.c:	if (plat->sdiowakeup_irq)
NeoLKernel/drivers/mmc/host/msm_sdcc.c:		free_irq(plat->sdiowakeup_irq, host);
NeoLKernel/drivers/mmc/host/msm_sdcc.c:	if (plat->sdiowakeup_irq)
NeoLKernel/drivers/mmc/host/msm_sdcc.c:		wake_lock_destroy(&host->sdio_wlock);
NeoLKernel/drivers/mmc/host/msm_sdcc.c:	wake_lock_destroy(&host->sdio_suspend_wlock);
NeoLKernel/drivers/mmc/host/msm_sdcc.c:	if (plat->sdiowakeup_irq) {
NeoLKernel/drivers/mmc/host/msm_sdcc.c:		wake_lock_destroy(&host->sdio_wlock);
NeoLKernel/drivers/mmc/host/msm_sdcc.c:		set_irq_wake(plat->sdiowakeup_irq, 0);
NeoLKernel/drivers/mmc/host/msm_sdcc.c:		free_irq(plat->sdiowakeup_irq, host);
NeoLKernel/drivers/mmc/host/msm_sdcc.h:	struct wake_lock	sdio_wlock;
NeoLKernel/drivers/mmc/host/msm_sdcc.h:	struct wake_lock	sdio_suspend_wlock;
NeoLKernel/drivers/mmc/host/omap_hsmmc.c:		mmc_card_awake(host->mmc);
NeoLKernel/drivers/mmc/host/s3cmci.c: * 9) Driver wakes up and takes care of the request
NeoLKernel/drivers/mmc/host/sdhci-pci.c:	pci_enable_wake(pdev, pci_choose_state(pdev, state), 0);
NeoLKernel/drivers/mmc/host/via-sdmmc.c:	pci_enable_wake(pcidev, pci_choose_state(pcidev, state), 0);
NeoLKernel/drivers/mtd/mtdchar.c:	wake_up((wait_queue_head_t *)instr->priv);
NeoLKernel/drivers/mtd/mtdchar.c:			  callback routine tries to wake us up.
NeoLKernel/drivers/mtd/chips/cfi_cmdset_0001.c:				wake_up(&chip->wq);
NeoLKernel/drivers/mtd/chips/cfi_cmdset_0001.c:			wake_up(&chip->wq);
NeoLKernel/drivers/mtd/chips/cfi_cmdset_0001.c:	wake_up(&chip->wq);
NeoLKernel/drivers/mtd/chips/cfi_cmdset_0001.c:			/* No need to wake_up() on this state change -
NeoLKernel/drivers/mtd/chips/cfi_cmdset_0001.c:			wake_up(&chip->wq);
NeoLKernel/drivers/mtd/chips/cfi_cmdset_0001.c:				/* No need to wake_up() on this state change -
NeoLKernel/drivers/mtd/chips/cfi_cmdset_0001.c:				wake_up(&chip->wq);
NeoLKernel/drivers/mtd/chips/cfi_cmdset_0001.c:			wake_up(&chip->wq);
NeoLKernel/drivers/mtd/chips/cfi_cmdset_0002.c:	wake_up(&chip->wq);
NeoLKernel/drivers/mtd/chips/cfi_cmdset_0002.c:	wake_up(&chip->wq);
NeoLKernel/drivers/mtd/chips/cfi_cmdset_0002.c:			/* No need to wake_up() on this state change -
NeoLKernel/drivers/mtd/chips/cfi_cmdset_0002.c:			wake_up(&chip->wq);
NeoLKernel/drivers/mtd/chips/cfi_cmdset_0002.c:			/* No need to wake_up() on this state change -
NeoLKernel/drivers/mtd/chips/cfi_cmdset_0002.c:				wake_up(&chip->wq);
NeoLKernel/drivers/mtd/chips/cfi_cmdset_0002.c:			wake_up(&chip->wq);
NeoLKernel/drivers/mtd/chips/cfi_cmdset_0020.c:	wake_up(&chip->wq);
NeoLKernel/drivers/mtd/chips/cfi_cmdset_0020.c:		wake_up(&chip->wq);
NeoLKernel/drivers/mtd/chips/cfi_cmdset_0020.c:	wake_up(&chip->wq);
NeoLKernel/drivers/mtd/chips/cfi_cmdset_0020.c:	wake_up(&chip->wq);
NeoLKernel/drivers/mtd/chips/cfi_cmdset_0020.c:			/* No need to wake_up() on this state change -
NeoLKernel/drivers/mtd/chips/cfi_cmdset_0020.c:			wake_up(&chip->wq);
NeoLKernel/drivers/mtd/chips/cfi_cmdset_0020.c:	wake_up(&chip->wq);
NeoLKernel/drivers/mtd/chips/cfi_cmdset_0020.c:	wake_up(&chip->wq);
NeoLKernel/drivers/mtd/chips/cfi_cmdset_0020.c:			/* No need to wake_up() on this state change -
NeoLKernel/drivers/mtd/chips/cfi_cmdset_0020.c:				wake_up(&chip->wq);
NeoLKernel/drivers/mtd/chips/cfi_cmdset_0020.c:			wake_up(&chip->wq);
NeoLKernel/drivers/mtd/devices/msm_nand.c:	wake_up(&chip->wait_queue);
NeoLKernel/drivers/mtd/lpddr/lpddr_cmds.c:				wake_up(&chip->wq);
NeoLKernel/drivers/mtd/lpddr/lpddr_cmds.c:			wake_up(&chip->wq);
NeoLKernel/drivers/mtd/lpddr/lpddr_cmds.c:	wake_up(&chip->wq);
NeoLKernel/drivers/mtd/mtdblock.c:	wake_up(wait_q);
NeoLKernel/drivers/mtd/mtdconcat.c:	wake_up((wait_queue_head_t *) instr->priv);
NeoLKernel/drivers/mtd/mtdoops.c:	wake_up(wait_q);
NeoLKernel/drivers/mtd/mtd_blkdevs.c:	wake_up_process(tr->blkcore_priv->thread);
NeoLKernel/drivers/mtd/nand/fsl_elbc_nand.c:		wake_up(&ctrl->irq_wait);
NeoLKernel/drivers/mtd/nand/mxc_nand.c:	wake_up(&host->irq_waitq);
NeoLKernel/drivers/mtd/nand/nand_base.c: * Deselect, release chip lock and wake up anyone waiting on the device
NeoLKernel/drivers/mtd/nand/nand_base.c:	wake_up(&chip->controller->wq);
NeoLKernel/drivers/mtd/nand/nand_base.c:	/* Deselect and wake up anyone waiting on the device */
NeoLKernel/drivers/mtd/nand/tmio_nand.c:	wake_up(&nand_chip->controller->wq);
NeoLKernel/drivers/mtd/nand/tmio_nand.c:  *erase and write, we enable it to wake us up.  The irq handler
NeoLKernel/drivers/mtd/onenand/onenand_base.c: * Deselect, release chip lock and wake up anyone waiting on the device
NeoLKernel/drivers/mtd/onenand/onenand_base.c:	wake_up(&this->wq);
NeoLKernel/drivers/mtd/onenand/onenand_base.c:	/* Deselect and wake up anyone waiting on the device */
NeoLKernel/drivers/mtd/onenand/onenand_base.c:	/* Deselect and wake up anyone waiting on the device */
NeoLKernel/drivers/mtd/ubi/build.c:	 * checks @ubi->thread_enabled. Otherwise we may fail to wake it up.
NeoLKernel/drivers/mtd/ubi/build.c:	wake_up_process(ubi->bgt_thread);
NeoLKernel/drivers/mtd/ubi/io.c:	wake_up_interruptible((wait_queue_head_t *)ei->priv);
NeoLKernel/drivers/mtd/ubi/wl.c:		wake_up_process(ubi->bgt_thread);
NeoLKernel/drivers/net/3c501.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/3c501.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/3c501.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/3c501.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/3c505.c:					netif_wake_queue(dev);
NeoLKernel/drivers/net/3c505.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/ks8842.c:		netif_wake_queue(netdev);
NeoLKernel/drivers/net/ks8842.c:		netif_wake_queue(netdev);
NeoLKernel/drivers/net/ks8851.c:		netif_wake_queue(ks->netdev);
NeoLKernel/drivers/net/ks8851_mll.c:		netif_wake_queue(netdev);
NeoLKernel/drivers/net/ks8851_mll.c:	/* wake up powermode to normal mode */
NeoLKernel/drivers/net/lance.c:	netif_wake_queue (dev);
NeoLKernel/drivers/net/lance.c:				netif_wake_queue (dev);
NeoLKernel/drivers/net/lib82596.c:	netif_wake_queue (dev);
NeoLKernel/drivers/net/lib8390.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/lib8390.c: * stack. We also handle transmit completions and wake the transmit path if
NeoLKernel/drivers/net/lib8390.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/ll_temac_main.c:	netif_wake_queue(ndev);
NeoLKernel/drivers/net/lp486e.c:				netif_wake_queue(dev);
NeoLKernel/drivers/net/lp486e.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/lp486e.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/mac89x0.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/mac89x0.c:				netif_wake_queue(dev);
NeoLKernel/drivers/net/macb.c:		netif_wake_queue(bp->dev);
NeoLKernel/drivers/net/macb.c:			"BUG! Tx Ring full when queue awake!\n");
NeoLKernel/drivers/net/mace.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/mace.c:    netif_wake_queue(dev);
NeoLKernel/drivers/net/mace.h:#define RWAKE		0x02	/* remote wake function */
NeoLKernel/drivers/net/mace.h:#define AWAKE		0x01	/* auto wake function */
NeoLKernel/drivers/net/macmace.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/macmace.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/sh_eth.c:		/* wakeup */
NeoLKernel/drivers/net/sh_eth.c:		netif_wake_queue(ndev);
NeoLKernel/drivers/net/sh_eth.c:		netif_wake_queue(ndev);
NeoLKernel/drivers/net/sh_eth.c:	/* reset phy - this also wakes it from PDOWN */
NeoLKernel/drivers/net/sis190.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/sis190.c:			   "%s: BUG! Tx Ring full when queue awake!\n",
NeoLKernel/drivers/net/sis190.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/sis190.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/sis900.c:	netif_wake_queue(net_dev);
NeoLKernel/drivers/net/sis900.c:		 * more transmission by netif_wake_queue(net_dev) */
NeoLKernel/drivers/net/sis900.c:		netif_wake_queue (net_dev);
NeoLKernel/drivers/net/sis900.c: *	Process ethtool command "wol" to setup wake on lan features.
NeoLKernel/drivers/net/skge.c:	    || !device_can_wakeup(&hw->pdev->dev))
NeoLKernel/drivers/net/skge.c:	device_set_wakeup_enable(&hw->pdev->dev, skge->wol);
NeoLKernel/drivers/net/skge.c:	netif_wake_queue(skge->netdev);
NeoLKernel/drivers/net/skge.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/skge.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/skge.c:	if (device_can_wakeup(&hw->pdev->dev)) {
NeoLKernel/drivers/net/skge.c:		device_set_wakeup_enable(&hw->pdev->dev, skge->wol);
NeoLKernel/drivers/net/skge.c:	if (pci_enable_wake(pdev, PCI_D3cold, wol))
NeoLKernel/drivers/net/skge.c:		pci_enable_wake(pdev, PCI_D3hot, wol);
NeoLKernel/drivers/net/sky2.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/sky2.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/sky2.c:	    || !device_can_wakeup(&hw->pdev->dev))
NeoLKernel/drivers/net/sky2.c:	device_set_wakeup_enable(&hw->pdev->dev, sky2->wol);
NeoLKernel/drivers/net/sky2.c:		wake_up(&hw->msi_wait);
NeoLKernel/drivers/net/sky2.c:	wol_default = device_may_wakeup(&pdev->dev) ? WAKE_MAGIC : 0;
NeoLKernel/drivers/net/sky2.c:	pci_enable_wake(pdev, pci_choose_state(pdev, state), wol);
NeoLKernel/drivers/net/sky2.c:	pci_enable_wake(pdev, PCI_D0, 0);
NeoLKernel/drivers/net/sky2.c:	pci_enable_wake(pdev, PCI_D3hot, wol);
NeoLKernel/drivers/net/sky2.c:	pci_enable_wake(pdev, PCI_D3cold, wol);
NeoLKernel/drivers/net/slip.c:	netif_wake_queue(sl->dev);
NeoLKernel/drivers/net/slip.c:static void slip_write_wakeup(struct tty_struct *tty)
NeoLKernel/drivers/net/slip.c:	.write_wakeup	= slip_write_wakeup,
NeoLKernel/drivers/net/smc911x.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/smc911x.c:				netif_wake_queue(dev);
NeoLKernel/drivers/net/smc911x.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/smc911x.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/smc9194.c: .	the manual says that it will wake up in response to any I/O requests
NeoLKernel/drivers/net/smc9194.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/smc9194.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/smc9194.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/smc9194.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/smc9194.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/smc9194.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/smc9194.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/e1000/e1000.h:/* How many Tx Descriptors do we need to call netif_wake_queue ? */
NeoLKernel/drivers/net/e1000/e1000_ethtool.c:	    !device_can_wakeup(&adapter->pdev->dev))
NeoLKernel/drivers/net/e1000/e1000_ethtool.c:		/* KSP3 does not suppport UCAST wake-ups */
NeoLKernel/drivers/net/e1000/e1000_ethtool.c:		        "directed (unicast) frame wake-up packets\n");
NeoLKernel/drivers/net/e1000/e1000_ethtool.c:	    !device_can_wakeup(&adapter->pdev->dev))
NeoLKernel/drivers/net/e1000/e1000_ethtool.c:		        "directed (unicast) frame wake-up packets\n");
NeoLKernel/drivers/net/e1000/e1000_ethtool.c:	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);
NeoLKernel/drivers/net/e1000/e1000_hw.h:/* Four wakeup IP addresses are supported */
NeoLKernel/drivers/net/e1000/e1000_hw.h:/* Definitions for power management and wakeup registers */
NeoLKernel/drivers/net/e1000/e1000_hw.h:#define E1000_WUFC_ALL_FILTERS 0x000F00FF	/* Mask for all wakeup filters */
NeoLKernel/drivers/net/e1000/e1000_main.c:	netif_wake_queue(adapter->netdev);
NeoLKernel/drivers/net/e1000/e1000_main.c: * driver is unloaded and wake on lan is not enabled (among others)
NeoLKernel/drivers/net/e1000/e1000_main.c:	/* Just clear the power down bit to wake the phy back up */
NeoLKernel/drivers/net/e1000/e1000_main.c:	 * If APM wake is enabled in the EEPROM,
NeoLKernel/drivers/net/e1000/e1000_main.c:	 * wake on lan on a particular port */
NeoLKernel/drivers/net/e1000/e1000_main.c:	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);
NeoLKernel/drivers/net/e1000/e1000_main.c:			netif_wake_queue(netdev);
NeoLKernel/drivers/net/e1000/e1000_main.c:			netif_wake_queue(netdev);
NeoLKernel/drivers/net/e1000/e1000_main.c:static int __e1000_shutdown(struct pci_dev *pdev, bool *enable_wake)
NeoLKernel/drivers/net/e1000/e1000_main.c:		/* turn on all-multi mode if wake on multicast is enabled */
NeoLKernel/drivers/net/e1000/e1000_main.c:			/* advertise wake from D3Cold */
NeoLKernel/drivers/net/e1000/e1000_main.c:	*enable_wake = !!wufc;
NeoLKernel/drivers/net/e1000/e1000_main.c:		*enable_wake = true;
NeoLKernel/drivers/net/e1000/e1000_main.c:	bool wake;
NeoLKernel/drivers/net/e1000/e1000_main.c:	retval = __e1000_shutdown(pdev, &wake);
NeoLKernel/drivers/net/e1000/e1000_main.c:	if (wake) {
NeoLKernel/drivers/net/e1000/e1000_main.c:		pci_wake_from_d3(pdev, false);
NeoLKernel/drivers/net/e1000/e1000_main.c:	pci_enable_wake(pdev, PCI_D3hot, 0);
NeoLKernel/drivers/net/e1000/e1000_main.c:	pci_enable_wake(pdev, PCI_D3cold, 0);
NeoLKernel/drivers/net/e1000/e1000_main.c:	bool wake;
NeoLKernel/drivers/net/e1000/e1000_main.c:	__e1000_shutdown(pdev, &wake);
NeoLKernel/drivers/net/e1000/e1000_main.c:		pci_wake_from_d3(pdev, wake);
NeoLKernel/drivers/net/e1000/e1000_main.c:	pci_enable_wake(pdev, PCI_D3hot, 0);
NeoLKernel/drivers/net/e1000/e1000_main.c:	pci_enable_wake(pdev, PCI_D3cold, 0);
NeoLKernel/drivers/net/e1000e/defines.h:/* Definitions for power management and wakeup registers */
NeoLKernel/drivers/net/e1000e/defines.h:#define E1000_WUC_PHY_WAKE   0x00000100 /* if PHY supports wakeup */
NeoLKernel/drivers/net/e1000e/e1000.h:/* How many Tx Descriptors do we need to call netif_wake_queue ? */
NeoLKernel/drivers/net/e1000e/ethtool.c:	    !device_can_wakeup(&adapter->pdev->dev))
NeoLKernel/drivers/net/e1000e/ethtool.c:			      "frame wake-up packets\n");
NeoLKernel/drivers/net/e1000e/ethtool.c:	    !device_can_wakeup(&adapter->pdev->dev))
NeoLKernel/drivers/net/e1000e/ethtool.c:	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);
NeoLKernel/drivers/net/e1000e/ich8lan.c:	/* Dummy read to clear the phy wakeup bit after lcd reset */
NeoLKernel/drivers/net/e1000e/ich8lan.c:	/* Dummy read to clear the phy wakeup bit after lcd reset */
NeoLKernel/drivers/net/e1000e/ich8lan.c:	 * The 82578 Rx buffer will stall if wakeup is enabled in host and
NeoLKernel/drivers/net/e1000e/ich8lan.c:	 * the ME.  Reading the BM_WUC register will clear the host wakeup bit.
NeoLKernel/drivers/net/e1000e/ich8lan.c:	 * Reset the phy after disabling host wakeup to reset the Rx buffer.
NeoLKernel/drivers/net/e1000e/netdev.c:			netif_wake_queue(netdev);
NeoLKernel/drivers/net/e1000e/netdev.c: * driver is unloaded and wake on lan is not enabled (among others)
NeoLKernel/drivers/net/e1000e/netdev.c:	/* Just clear the power down bit to wake the phy back up */
NeoLKernel/drivers/net/e1000e/netdev.c:	netif_wake_queue(adapter->netdev);
NeoLKernel/drivers/net/e1000e/netdev.c:static int e1000_init_phy_wakeup(struct e1000_adapter *adapter, u32 wufc)
NeoLKernel/drivers/net/e1000e/netdev.c:	/* enable PHY wakeup in MAC register */
NeoLKernel/drivers/net/e1000e/netdev.c:	/* configure and enable PHY wakeup in PHY registers */
NeoLKernel/drivers/net/e1000e/netdev.c:	/* activate PHY wakeup */
NeoLKernel/drivers/net/e1000e/netdev.c:static int __e1000_shutdown(struct pci_dev *pdev, bool *enable_wake)
NeoLKernel/drivers/net/e1000e/netdev.c:		/* turn on all-multi mode if wake on multicast is enabled */
NeoLKernel/drivers/net/e1000e/netdev.c:		/* advertise wake from D3Cold */
NeoLKernel/drivers/net/e1000e/netdev.c:			/* enable wakeup by the PHY */
NeoLKernel/drivers/net/e1000e/netdev.c:			retval = e1000_init_phy_wakeup(adapter, wufc);
NeoLKernel/drivers/net/e1000e/netdev.c:			/* enable wakeup by the MAC */
NeoLKernel/drivers/net/e1000e/netdev.c:	*enable_wake = !!wufc;
NeoLKernel/drivers/net/e1000e/netdev.c:		*enable_wake = true;
NeoLKernel/drivers/net/e1000e/netdev.c:static void e1000_power_off(struct pci_dev *pdev, bool sleep, bool wake)
NeoLKernel/drivers/net/e1000e/netdev.c:	if (sleep && wake) {
NeoLKernel/drivers/net/e1000e/netdev.c:	pci_wake_from_d3(pdev, wake);
NeoLKernel/drivers/net/e1000e/netdev.c:                                    bool wake)
NeoLKernel/drivers/net/e1000e/netdev.c:		e1000_power_off(pdev, sleep, wake);
NeoLKernel/drivers/net/e1000e/netdev.c:		e1000_power_off(pdev, sleep, wake);
NeoLKernel/drivers/net/e1000e/netdev.c:	bool wake;
NeoLKernel/drivers/net/e1000e/netdev.c:	retval = __e1000_shutdown(pdev, &wake);
NeoLKernel/drivers/net/e1000e/netdev.c:		e1000_complete_shutdown(pdev, true, wake);
NeoLKernel/drivers/net/e1000e/netdev.c:	pci_enable_wake(pdev, PCI_D3hot, 0);
NeoLKernel/drivers/net/e1000e/netdev.c:	pci_enable_wake(pdev, PCI_D3cold, 0);
NeoLKernel/drivers/net/e1000e/netdev.c:	/* report the system wakeup cause from S3/S4 */
NeoLKernel/drivers/net/e1000e/netdev.c:	bool wake = false;
NeoLKernel/drivers/net/e1000e/netdev.c:	__e1000_shutdown(pdev, &wake);
NeoLKernel/drivers/net/e1000e/netdev.c:		e1000_complete_shutdown(pdev, false, wake);
NeoLKernel/drivers/net/e1000e/netdev.c:		pci_enable_wake(pdev, PCI_D3hot, 0);
NeoLKernel/drivers/net/e1000e/netdev.c:		pci_enable_wake(pdev, PCI_D3cold, 0);
NeoLKernel/drivers/net/e1000e/netdev.c:	 * Initial Wake on LAN setting - If APM wake is enabled in
NeoLKernel/drivers/net/e1000e/netdev.c:	 * wake on lan on a particular port
NeoLKernel/drivers/net/e1000e/netdev.c:	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);
NeoLKernel/drivers/net/e1000e/phy.c:static s32 e1000_access_phy_wakeup_reg_bm(struct e1000_hw *hw, u32 offset,
NeoLKernel/drivers/net/e1000e/phy.c:		ret_val = e1000_access_phy_wakeup_reg_bm(hw, offset, &data,
NeoLKernel/drivers/net/e1000e/phy.c:		ret_val = e1000_access_phy_wakeup_reg_bm(hw, offset, data,
NeoLKernel/drivers/net/e1000e/phy.c:		ret_val = e1000_access_phy_wakeup_reg_bm(hw, offset, data,
NeoLKernel/drivers/net/e1000e/phy.c:		ret_val = e1000_access_phy_wakeup_reg_bm(hw, offset, &data,
NeoLKernel/drivers/net/e1000e/phy.c: *  e1000_access_phy_wakeup_reg_bm - Read BM PHY wakeup register
NeoLKernel/drivers/net/e1000e/phy.c: *  semaphores before exiting. Note that procedure to read the wakeup
NeoLKernel/drivers/net/e1000e/phy.c:static s32 e1000_access_phy_wakeup_reg_bm(struct e1000_hw *hw, u32 offset,
NeoLKernel/drivers/net/e1000e/phy.c:		ret_val = e1000_access_phy_wakeup_reg_bm(hw, offset,
NeoLKernel/drivers/net/e1000e/phy.c:		ret_val = e1000_access_phy_wakeup_reg_bm(hw, offset,
NeoLKernel/drivers/net/eepro.c:						netif_wake_queue(dev);\
NeoLKernel/drivers/net/eepro.c:		if (request_region(WakeupPort, 2, "eepro wakeup")) {
NeoLKernel/drivers/net/eepro.c:			printk(KERN_WARNING "PnP wakeup region busy!\n");
NeoLKernel/drivers/net/eepro.c:			/* we won't wake queue here because we're out of space */
NeoLKernel/drivers/net/eepro.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/eepro.c:		netif_wake_queue (dev);
NeoLKernel/drivers/net/eexpress.c:				netif_wake_queue(dev);
NeoLKernel/drivers/net/eexpress.c:						netif_wake_queue(dev);
NeoLKernel/drivers/net/eexpress.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/eexpress.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/eexpress.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/eexpress.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/eexpress.c:					netif_wake_queue(dev);
NeoLKernel/drivers/net/ehea/ehea_main.c:		netif_wake_queue(pr->port->netdev);
NeoLKernel/drivers/net/ehea/ehea_main.c:				netif_wake_queue(port->netdev);
NeoLKernel/drivers/net/ehea/ehea_main.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/ehea/ehea_main.c:							netif_wake_queue(dev);
NeoLKernel/drivers/net/enc28j60.c:	netif_wake_queue(ndev);
NeoLKernel/drivers/net/enic/enic_main.c:		netif_wake_queue(enic->netdev);
NeoLKernel/drivers/net/enic/enic_main.c:			"queue awake!\n", netdev->name);
NeoLKernel/drivers/net/enic/enic_main.c:	netif_wake_queue(netdev);
NeoLKernel/drivers/net/epic100.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/epic100.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/eth16i.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/eth16i.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/eth16i.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/eth16i.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/eth16i.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/ethoc.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/ethoc.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/ewrk3.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/ewrk3.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/fealnx.c:	netif_start_queue(dev); /* FIXME: or netif_wake_queue(dev); ? */
NeoLKernel/drivers/net/fealnx.c:	netif_wake_queue(dev); /* or .._start_.. ?? */
NeoLKernel/drivers/net/fealnx.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/fec.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/fec.c:				netif_wake_queue(dev);
NeoLKernel/drivers/net/fec_mpc52xx.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/fec_mpc52xx.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/fec_mpc52xx.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/forcedeth.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/forcedeth.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/forcedeth.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/forcedeth.c:	/* Workaround current PCI init glitch:  wakeup bits aren't
NeoLKernel/drivers/net/forcedeth.c:	device_init_wakeup(&pci_dev->dev, 1);
NeoLKernel/drivers/net/forcedeth.c:	pci_enable_wake(pdev, pci_choose_state(pdev, state), np->wolenabled);
NeoLKernel/drivers/net/forcedeth.c:	/* ack any pending wake events, disable PME */
NeoLKernel/drivers/net/forcedeth.c:	pci_enable_wake(pdev, PCI_D0, 0);
NeoLKernel/drivers/net/forcedeth.c:		if (pci_enable_wake(pdev, PCI_D3cold, np->wolenabled))
NeoLKernel/drivers/net/forcedeth.c:			pci_enable_wake(pdev, PCI_D3hot, np->wolenabled);
NeoLKernel/drivers/net/fs_enet/fs_enet-main.c:	int dirtyidx, do_wake, do_restart;
NeoLKernel/drivers/net/fs_enet/fs_enet-main.c:	do_wake = do_restart = 0;
NeoLKernel/drivers/net/fs_enet/fs_enet-main.c:			do_wake = 1;
NeoLKernel/drivers/net/fs_enet/fs_enet-main.c:	if (do_wake)
NeoLKernel/drivers/net/fs_enet/fs_enet-main.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/fs_enet/fs_enet-main.c:	int wake = 0;
NeoLKernel/drivers/net/fs_enet/fs_enet-main.c:	wake = fep->tx_free && !(CBDR_SC(fep->cur_tx) & BD_ENET_TX_READY);
NeoLKernel/drivers/net/fs_enet/fs_enet-main.c:	if (wake)
NeoLKernel/drivers/net/fs_enet/fs_enet-main.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/gianfar.c:	device_init_wakeup(&dev->dev,
NeoLKernel/drivers/net/gianfar.c:		/* Disable Tx, and Rx if wake-on-LAN is disabled. */
NeoLKernel/drivers/net/gianfar.c:	device_set_wakeup_enable(&dev->dev, priv->wol_en);
NeoLKernel/drivers/net/gianfar.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/bnx2.c:			netif_tx_wake_all_queues(bp->dev);
NeoLKernel/drivers/net/bnx2.c:		     (bnx2_tx_avail(bp, txr) > bp->tx_wake_thresh)) {
NeoLKernel/drivers/net/bnx2.c:		    (bnx2_tx_avail(bp, txr) > bp->tx_wake_thresh))
NeoLKernel/drivers/net/bnx2.c:			netif_tx_wake_queue(txq);
NeoLKernel/drivers/net/bnx2.c:	bp->tx_wake_thresh = bp->tx_ring_size / 2;
NeoLKernel/drivers/net/bnx2.c: * netif_wake_queue().
NeoLKernel/drivers/net/bnx2.c:		printk(KERN_ERR PFX "%s: BUG! Tx ring full when queue awake!\n",
NeoLKernel/drivers/net/bnx2.c:		if (bnx2_tx_avail(bp, txr) > bp->tx_wake_thresh)
NeoLKernel/drivers/net/bnx2.c:			netif_tx_wake_queue(txq);
NeoLKernel/drivers/net/bnx2.c:	/* enable device (incl. PCI PM wakeup), and bus-mastering */
NeoLKernel/drivers/net/bnx2.h:	u32		tx_wake_thresh;
NeoLKernel/drivers/net/bnx2x_main.c:			netif_tx_wake_queue(txq);
NeoLKernel/drivers/net/bnx2x_main.c:	netif_tx_wake_all_queues(bp->dev);
NeoLKernel/drivers/net/bnx2x_main.c:				netif_tx_wake_all_queues(bp->dev);
NeoLKernel/drivers/net/bnx2x_main.c:			netif_tx_wake_all_queues(bp->dev);
NeoLKernel/drivers/net/bnx2x_main.c: * netif_wake_queue()
NeoLKernel/drivers/net/bnx2x_main.c:		BNX2X_ERR("BUG! Tx ring full when queue awake!\n");
NeoLKernel/drivers/net/bnx2x_main.c:			netif_tx_wake_queue(txq);
NeoLKernel/drivers/net/can/at91_can.c:			"BUG! TX buffer full when queue awake!\n");
NeoLKernel/drivers/net/can/at91_can.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/can/at91_can.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/can/at91_can.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/can/sja1000/sja1000.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/can/sja1000/sja1000.c:			dev_warn(dev->dev.parent, "wakeup interrupt\n");
NeoLKernel/drivers/net/can/sja1000/sja1000.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/can/usb/ems_usb.c:		netif_wake_queue(netdev);
NeoLKernel/drivers/net/can/usb/ems_usb.c:			netif_wake_queue(netdev);
NeoLKernel/drivers/net/cassini.c: *       determining whether to do a netif_stop/wakeup
NeoLKernel/drivers/net/cassini.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/cassini.c:		       "queue awake!\n", dev->name);
NeoLKernel/drivers/net/chelsio/sge.c:			netif_wake_queue(nd);
NeoLKernel/drivers/net/chelsio/sge.c:			CH_ERR("%s: Tx ring full while queue awake!\n",
NeoLKernel/drivers/net/3c507.c:	netif_wake_queue (dev);
NeoLKernel/drivers/net/3c507.c:	  netif_wake_queue(dev);
NeoLKernel/drivers/net/3c507.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/bmac.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/bmac.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/e100.c: * 	o check for tx-no-resources/stop Q races with tx clean/wake Q
NeoLKernel/drivers/net/e100.c:	   link_status_wake:1), arp_wake:1), mcmatch_wake:1);
NeoLKernel/drivers/net/e100.c:/*19*/	u8 X(X(X(X(X(X(X(addr_wake:1, magic_packet_disable:1),
NeoLKernel/drivers/net/e100.c:		netif_wake_queue(nic->netdev);
NeoLKernel/drivers/net/e100.c:	netif_wake_queue(nic->netdev);
NeoLKernel/drivers/net/e100.c:	    !device_can_wakeup(&nic->pdev->dev))
NeoLKernel/drivers/net/e100.c:	device_set_wakeup_enable(&nic->pdev->dev, wol->wolopts);
NeoLKernel/drivers/net/e100.c:		device_set_wakeup_enable(&pdev->dev, true);
NeoLKernel/drivers/net/e100.c:	/* ack any pending wake events, disable PME */
NeoLKernel/drivers/net/e100.c:static void __e100_shutdown(struct pci_dev *pdev, bool *enable_wake)
NeoLKernel/drivers/net/e100.c:		*enable_wake = true;
NeoLKernel/drivers/net/e100.c:		*enable_wake = false;
NeoLKernel/drivers/net/e100.c:static int __e100_power_off(struct pci_dev *pdev, bool wake)
NeoLKernel/drivers/net/e100.c:	if (wake)
NeoLKernel/drivers/net/e100.c:	pci_wake_from_d3(pdev, false);
NeoLKernel/drivers/net/e100.c:	bool wake;
NeoLKernel/drivers/net/e100.c:	__e100_shutdown(pdev, &wake);
NeoLKernel/drivers/net/e100.c:	return __e100_power_off(pdev, wake);
NeoLKernel/drivers/net/e100.c:	/* ack any pending wake events, disable PME */
NeoLKernel/drivers/net/e100.c:	pci_enable_wake(pdev, 0, 0);
NeoLKernel/drivers/net/e100.c:	bool wake;
NeoLKernel/drivers/net/e100.c:	__e100_shutdown(pdev, &wake);
NeoLKernel/drivers/net/e100.c:		__e100_power_off(pdev, wake);
NeoLKernel/drivers/net/e100.c:	/* ack any pending wake events, disable PME */
NeoLKernel/drivers/net/e100.c:	pci_enable_wake(pdev, 0, 0);
NeoLKernel/drivers/net/korina.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/meth.c:	/* wake up queue if it was stopped */
NeoLKernel/drivers/net/meth.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/meth.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/netxen/netxen_nic_init.c:				netif_wake_queue(netdev);
NeoLKernel/drivers/net/netxen/netxen_nic_main.c:		pci_enable_wake(pdev, PCI_D3cold, 1);
NeoLKernel/drivers/net/netxen/netxen_nic_main.c:		pci_enable_wake(pdev, PCI_D3hot, 1);
NeoLKernel/drivers/net/netxen/netxen_nic_main.c:			netif_wake_queue(netdev);
NeoLKernel/drivers/net/netxen/netxen_nic_main.c:		netif_wake_queue(adapter->netdev);
NeoLKernel/drivers/net/sgiseeq.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/sgiseeq.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/sgiseeq.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/sunbmac.c:		netif_wake_queue(bp->dev);
NeoLKernel/drivers/net/sunbmac.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/tun.c: *    Fixes in packet dropping, queue length setting and queue wakeup.
NeoLKernel/drivers/net/tun.c:		wake_up_all(&tun->socket.wait);
NeoLKernel/drivers/net/tun.c:	/* Notify and wake up reader process */
NeoLKernel/drivers/net/tun.c:	wake_up_interruptible(&tun->socket.wait);
NeoLKernel/drivers/net/tun.c:		netif_wake_queue(tun->dev);
NeoLKernel/drivers/net/tun.c:		wake_up_interruptible_sync(sk->sk_sleep);
NeoLKernel/drivers/net/tun.c:		netif_wake_queue(tun->dev);
NeoLKernel/drivers/net/ni5010.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/ni5010.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/ni5010.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/ni52.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/ni52.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/ni52.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/ni52.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/ni65.c:				netif_wake_queue(dev);
NeoLKernel/drivers/net/ni65.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/ni65.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/ni65.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/ni65.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/niu.c:			netif_tx_wake_queue(txq);
NeoLKernel/drivers/net/niu.c:	/* NOTE: unconditional netif_wake_queue is only appropriate
NeoLKernel/drivers/net/niu.c:	netif_tx_wake_all_queues(np->dev);
NeoLKernel/drivers/net/niu.c:			"queue awake!\n", dev->name);
NeoLKernel/drivers/net/niu.c:			netif_tx_wake_queue(txq);
NeoLKernel/drivers/net/ns83820.c:		netif_wake_queue(ndev);
NeoLKernel/drivers/net/ns83820.c:		netif_wake_queue(ndev);
NeoLKernel/drivers/net/pasemi_mac.c:	netif_wake_queue(mac->netdev);
NeoLKernel/drivers/net/pci-skeleton.c:	/* enable device (incl. PCI PM wakeup), and bus-mastering */
NeoLKernel/drivers/net/pci-skeleton.c:	netif_wake_queue (dev);
NeoLKernel/drivers/net/pci-skeleton.c:			netif_wake_queue (dev);
NeoLKernel/drivers/net/pcmcia/3c574_cs.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/pcmcia/3c574_cs.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/pcmcia/3c589_cs.c:    netif_wake_queue(dev);
NeoLKernel/drivers/net/pcmcia/3c589_cs.c:	    netif_wake_queue(dev);
NeoLKernel/drivers/net/pcmcia/axnet_cs.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/pcmcia/axnet_cs.c: * stack. We also handle transmit completions and wake the transmit path if
NeoLKernel/drivers/net/pcmcia/axnet_cs.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/pcmcia/fmvj18x_cs.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/pcmcia/fmvj18x_cs.c:    netif_wake_queue(dev);
NeoLKernel/drivers/net/pcmcia/fmvj18x_cs.c:	   has done a netif_wake_queue() for us and will work on them
NeoLKernel/drivers/net/pcmcia/nmclan_cs.c:  netif_wake_queue(dev);
NeoLKernel/drivers/net/pcmcia/nmclan_cs.c:      netif_wake_queue(dev);
NeoLKernel/drivers/net/pcmcia/smc91c92_cs.c:    netif_wake_queue(dev);
NeoLKernel/drivers/net/pcmcia/smc91c92_cs.c:	    netif_wake_queue(dev);
NeoLKernel/drivers/net/pcmcia/xirc2ps_cs.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/pcmcia/xirc2ps_cs.c:    netif_wake_queue(dev);
NeoLKernel/drivers/net/pcnet32.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/pcnet32.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/pcnet32.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/pcnet32.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/pcnet32.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/phy/mdio_bus.c:	 * Don't suspend PHY if the attched netdev parent may wakeup.
NeoLKernel/drivers/net/phy/mdio_bus.c:	if (netdev->dev.parent && device_may_wakeup(netdev->dev.parent))
NeoLKernel/drivers/net/phy/mdio_bus.c:	 * Also don't suspend PHY if the netdev itself may wakeup. This
NeoLKernel/drivers/net/phy/mdio_bus.c:	if (device_may_wakeup(&netdev->dev))
NeoLKernel/drivers/net/plip.c:static void plip_wakeup(void *handle);
NeoLKernel/drivers/net/plip.c:		netif_wake_queue (dev);
NeoLKernel/drivers/net/plip.c:		netif_wake_queue (dev);
NeoLKernel/drivers/net/plip.c:		netif_wake_queue (dev);
NeoLKernel/drivers/net/plip.c:plip_wakeup(void *handle)
NeoLKernel/drivers/net/plip.c:						 plip_wakeup, plip_interrupt,
NeoLKernel/drivers/net/ppp_async.c:ppp_asynctty_wakeup(struct tty_struct *tty)
NeoLKernel/drivers/net/ppp_async.c:	.write_wakeup = ppp_asynctty_wakeup,
NeoLKernel/drivers/net/ppp_async.c:		ppp_output_wakeup(&ap->chan);
NeoLKernel/drivers/net/ppp_async.c: * If the packet was not accepted, we will call ppp_output_wakeup
NeoLKernel/drivers/net/ppp_async.c:	 * function calls our wakeup function.  This can happen
NeoLKernel/drivers/net/ppp_async.c:		ppp_output_wakeup(&ap->chan);
NeoLKernel/drivers/net/ppp_generic.c:			netif_wake_queue(ppp->dev);
NeoLKernel/drivers/net/ppp_generic.c:			netif_wake_queue(ppp->dev);
NeoLKernel/drivers/net/ppp_generic.c:		wake_up_interruptible(&ppp->file.rwait);
NeoLKernel/drivers/net/ppp_generic.c:		wake_up_interruptible(&pch->file.rwait);
NeoLKernel/drivers/net/ppp_generic.c:		/* wake up any process polling or blocking on read */
NeoLKernel/drivers/net/ppp_generic.c:		wake_up_interruptible(&ppp->file.rwait);
NeoLKernel/drivers/net/ppp_generic.c:	wake_up_interruptible(&pch->file.rwait);
NeoLKernel/drivers/net/ppp_generic.c:ppp_output_wakeup(struct ppp_channel *chan)
NeoLKernel/drivers/net/ppp_generic.c:	wake_up_interruptible(&ppp->file.rwait);
NeoLKernel/drivers/net/ppp_generic.c:			wake_up_interruptible(&ppp->file.rwait);
NeoLKernel/drivers/net/ppp_generic.c:EXPORT_SYMBOL(ppp_output_wakeup);
NeoLKernel/drivers/net/sundance.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/sundance.c:			netif_wake_queue (dev);
NeoLKernel/drivers/net/sungem.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/sungem.c:		printk(KERN_ERR PFX "%s: BUG! Tx Ring full when queue awake!\n",
NeoLKernel/drivers/net/sungem.c:		/* Setup wake-on-lan for MAGIC packet */
NeoLKernel/drivers/net/sungem.c:	netif_wake_queue(gp->dev);
NeoLKernel/drivers/net/sungem.c:		netif_wake_queue(gp->dev);
NeoLKernel/drivers/net/sungem.c:	       (gp->wake_on_lan && gp->opened) ? "enabled" : "disabled");
NeoLKernel/drivers/net/sungem.c:		gp->asleep_wol = gp->wake_on_lan;
NeoLKernel/drivers/net/sungem.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/sungem.c:		wol->wolopts = gp->wake_on_lan;
NeoLKernel/drivers/net/sungem.c:	gp->wake_on_lan = wol->wolopts & WOL_SUPPORTED_MASK;
NeoLKernel/drivers/net/sungem.h:	unsigned int has_wol : 1;	/* chip supports wake-on-lan */
NeoLKernel/drivers/net/sungem.h:	int			wake_on_lan;
NeoLKernel/drivers/net/sunhme.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/sunhme.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/sunhme.c:		printk(KERN_ERR "%s: BUG! Tx Ring full when queue awake!\n",
NeoLKernel/drivers/net/sunhme.h:#define ETX_PENDING	0x00UL	/* Transmit pending/wakeup register */
NeoLKernel/drivers/net/sunlance.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/sunlance.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/sunlance.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/sunlance.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/sunlance.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/sunlance.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/sunqe.c:					netif_wake_queue(qep->dev);
NeoLKernel/drivers/net/sunqe.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/sunqe.c:		 * will wake up the queue and return us back to
NeoLKernel/drivers/net/sunqe.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/sunvnet.c:static void maybe_tx_wakeup(struct vnet *vp)
NeoLKernel/drivers/net/sunvnet.c:		int wake = 1;
NeoLKernel/drivers/net/sunvnet.c:				wake = 0;
NeoLKernel/drivers/net/sunvnet.c:		if (wake)
NeoLKernel/drivers/net/sunvnet.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/sunvnet.c:	int tx_wakeup, err;
NeoLKernel/drivers/net/sunvnet.c:	tx_wakeup = err = 0;
NeoLKernel/drivers/net/sunvnet.c:					tx_wakeup |= err;
NeoLKernel/drivers/net/sunvnet.c:	if (unlikely(tx_wakeup && err != -ECONNRESET))
NeoLKernel/drivers/net/sunvnet.c:		maybe_tx_wakeup(port->vp);
NeoLKernel/drivers/net/sunvnet.c:			       "queue awake!\n", dev->name);
NeoLKernel/drivers/net/sunvnet.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/tc35815.c:	/* enable device (incl. PCI PM wakeup), and bus-mastering */
NeoLKernel/drivers/net/tc35815.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/tc35815.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/tc35815.c:	 * wake up the queue.
NeoLKernel/drivers/net/tc35815.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/tehuti.c:			netif_wake_queue(priv->ndev);
NeoLKernel/drivers/net/tehuti.c:		netif_wake_queue(priv->ndev);
NeoLKernel/drivers/net/tg3.c:/* minimum number of free TX descriptors required to wake up TX process */
NeoLKernel/drivers/net/tg3.c:	/* NOTE: unconditional netif_tx_wake_all_queues is only
NeoLKernel/drivers/net/tg3.c:	netif_tx_wake_all_queues(tp->dev);
NeoLKernel/drivers/net/tg3.c:	bool device_should_wake, do_low_power;
NeoLKernel/drivers/net/tg3.c:		pci_enable_wake(tp->pdev, state, false);
NeoLKernel/drivers/net/tg3.c:	device_should_wake = pci_pme_capable(tp->pdev, state) &&
NeoLKernel/drivers/net/tg3.c:			     device_may_wakeup(&tp->pdev->dev) &&
NeoLKernel/drivers/net/tg3.c:			    device_should_wake) {
NeoLKernel/drivers/net/tg3.c:	if (device_should_wake) {
NeoLKernel/drivers/net/tg3.c:	if (!(device_should_wake) &&
NeoLKernel/drivers/net/tg3.c:	if (device_should_wake)
NeoLKernel/drivers/net/tg3.c:		pci_enable_wake(tp->pdev, state, true);
NeoLKernel/drivers/net/tg3.c:			netif_tx_wake_queue(txq);
NeoLKernel/drivers/net/tg3.c:			       "queue awake!\n", dev->name);
NeoLKernel/drivers/net/tg3.c:			netif_tx_wake_queue(txq);
NeoLKernel/drivers/net/tg3.c:		netif_wake_queue(tp->dev);
NeoLKernel/drivers/net/tg3.c:			       "queue awake!\n", dev->name);
NeoLKernel/drivers/net/tg3.c:			netif_wake_queue(tp->dev);
NeoLKernel/drivers/net/tg3.c:	    device_can_wakeup(&tp->pdev->dev))
NeoLKernel/drivers/net/tg3.c:	    device_can_wakeup(&tp->pdev->dev))
NeoLKernel/drivers/net/tg3.c:	    !((tp->tg3_flags & TG3_FLAG_WOL_CAP) && device_can_wakeup(dp)))
NeoLKernel/drivers/net/tg3.c:		device_set_wakeup_enable(dp, true);
NeoLKernel/drivers/net/tg3.c:		device_set_wakeup_enable(dp, false);
NeoLKernel/drivers/net/tg3.c:	device_init_wakeup(&tp->pdev->dev, tp->tg3_flags & TG3_FLAG_WOL_CAP);
NeoLKernel/drivers/net/tg3.c:	device_set_wakeup_enable(&tp->pdev->dev,
NeoLKernel/drivers/net/tg3.h:	 *                netif_wake_queue.
NeoLKernel/drivers/net/tlan.c:	netif_wake_queue( dev );
NeoLKernel/drivers/net/tlan.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/tokenring/3c359.c:		netif_wake_queue(dev) ; 
NeoLKernel/drivers/net/tokenring/3c359.c:	netif_wake_queue(dev) ; 
NeoLKernel/drivers/net/tokenring/ibmtr.c:		wake_up(&ti->wait_for_reset);
NeoLKernel/drivers/net/tokenring/ibmtr.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/tokenring/ibmtr.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/tokenring/ibmtr.c:				wake_up(&ti->wait_for_reset);
NeoLKernel/drivers/net/tokenring/ibmtr.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/tokenring/ibmtr.c:				netif_wake_queue(dev);
NeoLKernel/drivers/net/tokenring/ibmtr.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/tokenring/ibmtr.c:        if (ti->open_mode == MANUAL)	wake_up(&ti->wait_for_reset);
NeoLKernel/drivers/net/tokenring/ibmtr.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/tokenring/lanstreamer.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/tokenring/lanstreamer.c:				wake_up_interruptible(&streamer_priv->srb_wait);
NeoLKernel/drivers/net/tokenring/lanstreamer.c:				wake_up_interruptible(&streamer_priv->
NeoLKernel/drivers/net/tokenring/olympic.c:			wake_up_interruptible(&olympic_priv->srb_wait);
NeoLKernel/drivers/net/tokenring/olympic.c:				wake_up_interruptible(&olympic_priv->srb_wait);
NeoLKernel/drivers/net/tokenring/olympic.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/tokenring/olympic.c:				wake_up_interruptible(&olympic_priv->trb_wait);
NeoLKernel/drivers/net/tokenring/olympic.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/tokenring/smctr.c:        netif_wake_queue(dev);
NeoLKernel/drivers/net/tokenring/smctr.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/tokenring/smctr.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/tokenring/tms380tr.c:		wake_up_interruptible(&tp->wait_for_tok_int);
NeoLKernel/drivers/net/tokenring/tms380tr.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/tokenring/tms380tr.c:	    		wake_up_interruptible(&tp->wait_for_tok_int);
NeoLKernel/drivers/net/tokenring/tms380tr.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/tsi108_eth.c:				netif_wake_queue(dev);
NeoLKernel/drivers/net/tsi108_eth.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/tsi108_eth.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/tulip/de2104x.c:		netif_wake_queue(de->dev);
NeoLKernel/drivers/net/tulip/de2104x.c:static void de_adapter_wake (struct de_private *de)
NeoLKernel/drivers/net/tulip/de2104x.c:	de_adapter_wake(de);
NeoLKernel/drivers/net/tulip/de2104x.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/tulip/de2104x.c:	/* wake up device, assign resources */
NeoLKernel/drivers/net/tulip/de2104x.c:	de_adapter_wake(de);
NeoLKernel/drivers/net/tulip/de4x5.c:			  Fix sleep/wakeup calls for PCI cards, bug reported
NeoLKernel/drivers/net/tulip/de4x5.c:	    netif_wake_queue(dev);
NeoLKernel/drivers/net/tulip/de4x5.c:    netif_wake_queue(dev);
NeoLKernel/drivers/net/tulip/de4x5.c:	netif_wake_queue(dev);                      /* Unlock the TX ring */
NeoLKernel/drivers/net/tulip/dmfe.c:#define TX_WAKE_DESC_CNT (TX_DESC_CNT - 3)	/* TX wakeup count */
NeoLKernel/drivers/net/tulip/dmfe.c:#define DMFE_TIMER_WUT  (jiffies + HZ * 1)/* timer wakeup time : 1 second */
NeoLKernel/drivers/net/tulip/dmfe.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/tulip/dmfe.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/tulip/dmfe.c:		netif_wake_queue(dev);	/* Active upper layer, send again */
NeoLKernel/drivers/net/tulip/dmfe.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/tulip/dmfe.c:	pci_enable_wake(pci_dev, PCI_D3hot, 1);
NeoLKernel/drivers/net/tulip/dmfe.c:	pci_enable_wake(pci_dev, PCI_D3cold, 1);
NeoLKernel/drivers/net/tulip/dmfe.c:	pci_enable_wake(pci_dev, PCI_D3hot, 0);
NeoLKernel/drivers/net/tulip/dmfe.c:	pci_enable_wake(pci_dev, PCI_D3cold, 0);
NeoLKernel/drivers/net/tulip/interrupt.c:				netif_wake_queue(dev);
NeoLKernel/drivers/net/tulip/pnic.c:			printk(KERN_INFO "%s: sw timer wakeup.\n", dev->name);
NeoLKernel/drivers/net/tulip/tulip_core.c:	netif_wake_queue (dev);
NeoLKernel/drivers/net/tulip/uli526x.c:#define TX_WAKE_DESC_CNT (TX_DESC_CNT - 3)	/* TX wakeup count */
NeoLKernel/drivers/net/tulip/uli526x.c:#define ULI526X_TIMER_WUT  (jiffies + HZ * 1)/* timer wakeup time : 1 second */
NeoLKernel/drivers/net/tulip/uli526x.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/tulip/uli526x.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/tulip/uli526x.c:		netif_wake_queue(dev);	/* Active upper layer, send again */
NeoLKernel/drivers/net/tulip/uli526x.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/tulip/uli526x.c:	pci_enable_wake(pdev, power_state, 0);
NeoLKernel/drivers/net/tulip/uli526x.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/tulip/uli526x.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/tulip/winbond-840.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/tulip/winbond-840.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/tulip/winbond-840.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/tulip/xircom_cb.c:			netif_wake_queue (dev);
NeoLKernel/drivers/net/tulip/xircom_cb.c:			netif_wake_queue (dev);
NeoLKernel/drivers/net/gianfar_ethtool.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/gianfar_ethtool.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/gianfar_ethtool.c:	device_set_wakeup_enable(&dev->dev, priv->wol_en);
NeoLKernel/drivers/net/hamachi.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/hamachi.c:		netif_wake_queue(dev);  /* Typical path */
NeoLKernel/drivers/net/hamachi.c:					netif_wake_queue(dev);
NeoLKernel/drivers/net/hamachi.c:				netif_wake_queue(dev);
NeoLKernel/drivers/net/hamradio/6pack.c:static void sixpack_write_wakeup(struct tty_struct *tty)
NeoLKernel/drivers/net/hamradio/6pack.c:		netif_wake_queue(sp->dev);
NeoLKernel/drivers/net/hamradio/6pack.c:	.write_wakeup	= sixpack_write_wakeup,
NeoLKernel/drivers/net/hamradio/baycom_epp.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/hamradio/baycom_epp.c:static void epp_wakeup(void *handle)
NeoLKernel/drivers/net/hamradio/baycom_epp.c:        bc->pdev = parport_register_device(pp, dev->name, NULL, epp_wakeup, 
NeoLKernel/drivers/net/hamradio/baycom_par.c:static void par96_wakeup(void *handle)
NeoLKernel/drivers/net/hamradio/baycom_par.c:	bc->pdev = parport_register_device(pp, dev->name, NULL, par96_wakeup, 
NeoLKernel/drivers/net/hamradio/bpqether.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/hamradio/dmascc.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/hamradio/dmascc.c:			netif_wake_queue(priv->dev);
NeoLKernel/drivers/net/hamradio/hdlcdrv.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/hamradio/mkiss.c:static void mkiss_write_wakeup(struct tty_struct *tty)
NeoLKernel/drivers/net/hamradio/mkiss.c:		netif_wake_queue(ax->dev);
NeoLKernel/drivers/net/hamradio/mkiss.c:	.write_wakeup	= mkiss_write_wakeup
NeoLKernel/drivers/net/hamradio/scc.c:		netif_wake_queue(scc->dev);
NeoLKernel/drivers/net/hamradio/scc.c:	netif_wake_queue(scc->dev);
NeoLKernel/drivers/net/hamradio/scc.c:			netif_wake_queue(scc->dev);	/* t_maxkeyup locked it. */
NeoLKernel/drivers/net/hamradio/scc.c:	netif_wake_queue(scc->dev);
NeoLKernel/drivers/net/hamradio/scc.c:	netif_wake_queue(scc->dev);	
NeoLKernel/drivers/net/hamradio/scc.c:	netif_wake_queue(scc->dev);
NeoLKernel/drivers/net/ibmlana.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/ibmlana.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/ibm_newemac/core.c:/* minimum number of free TX descriptors required to wake up TX process */
NeoLKernel/drivers/net/ibm_newemac/core.c:	netif_wake_queue(dev->ndev);
NeoLKernel/drivers/net/ibm_newemac/core.c:	/* NOTE: unconditional netif_wake_queue is only appropriate
NeoLKernel/drivers/net/ibm_newemac/core.c:				netif_wake_queue(dev->ndev);
NeoLKernel/drivers/net/ibm_newemac/core.c:		wake_up_all(&emac_probe_wait);
NeoLKernel/drivers/net/ibm_newemac/core.c:	wake_up_all(&emac_probe_wait);
NeoLKernel/drivers/net/ibm_newemac/core.c:	 * wake up all waiters to notify them in case they were waiting
NeoLKernel/drivers/net/ibm_newemac/core.c:		wake_up_all(&emac_probe_wait);
NeoLKernel/drivers/net/ifb.c:				netif_wake_queue(_dev);
NeoLKernel/drivers/net/igb/e1000_defines.h:/* Definitions for power management and wakeup registers */
NeoLKernel/drivers/net/igb/igb.h:/* How many Tx Descriptors do we need to call netif_wake_queue ? */
NeoLKernel/drivers/net/igb/igb_ethtool.c:	    !device_can_wakeup(&adapter->pdev->dev))
NeoLKernel/drivers/net/igb/igb_ethtool.c:	    !device_can_wakeup(&adapter->pdev->dev))
NeoLKernel/drivers/net/igb/igb_ethtool.c:	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);
NeoLKernel/drivers/net/igb/igb_main.c:	/* Initial Wake on LAN setting If APM wake is enabled in the EEPROM,
NeoLKernel/drivers/net/igb/igb_main.c:	 * the eeprom may be wrong or the board simply won't support wake on
NeoLKernel/drivers/net/igb/igb_main.c:	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);
NeoLKernel/drivers/net/igb/igb_main.c:	netif_wake_subqueue(netdev, tx_ring->queue_index);
NeoLKernel/drivers/net/igb/igb_main.c:			netif_wake_subqueue(netdev, tx_ring->queue_index);
NeoLKernel/drivers/net/igb/igb_main.c:static int __igb_shutdown(struct pci_dev *pdev, bool *enable_wake)
NeoLKernel/drivers/net/igb/igb_main.c:		/* turn on all-multi mode if wake on multicast is enabled */
NeoLKernel/drivers/net/igb/igb_main.c:		/* advertise wake from D3Cold */
NeoLKernel/drivers/net/igb/igb_main.c:	*enable_wake = wufc || adapter->en_mng_pt;
NeoLKernel/drivers/net/igb/igb_main.c:	if (!*enable_wake)
NeoLKernel/drivers/net/igb/igb_main.c:	bool wake;
NeoLKernel/drivers/net/igb/igb_main.c:	retval = __igb_shutdown(pdev, &wake);
NeoLKernel/drivers/net/igb/igb_main.c:	if (wake) {
NeoLKernel/drivers/net/igb/igb_main.c:		pci_wake_from_d3(pdev, false);
NeoLKernel/drivers/net/igb/igb_main.c:	pci_enable_wake(pdev, PCI_D3hot, 0);
NeoLKernel/drivers/net/igb/igb_main.c:	pci_enable_wake(pdev, PCI_D3cold, 0);
NeoLKernel/drivers/net/igb/igb_main.c:	bool wake;
NeoLKernel/drivers/net/igb/igb_main.c:	__igb_shutdown(pdev, &wake);
NeoLKernel/drivers/net/igb/igb_main.c:		pci_wake_from_d3(pdev, wake);
NeoLKernel/drivers/net/igb/igb_main.c:		pci_enable_wake(pdev, PCI_D3hot, 0);
NeoLKernel/drivers/net/igb/igb_main.c:		pci_enable_wake(pdev, PCI_D3cold, 0);
NeoLKernel/drivers/net/igbvf/igbvf.h:/* How many Tx Descriptors do we need to call netif_wake_queue ? */
NeoLKernel/drivers/net/igbvf/netdev.c:			netif_wake_queue(netdev);
NeoLKernel/drivers/net/igbvf/netdev.c:			netif_wake_queue(netdev);
NeoLKernel/drivers/net/igbvf/netdev.c:	netif_wake_queue(netdev);
NeoLKernel/drivers/net/ioc3-eth.c:		netif_wake_queue(priv_netdev(ip));
NeoLKernel/drivers/net/ioc3-eth.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/ioc3-eth.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/ioc3-eth.c:	netif_wake_queue(dev);			/* Let us get going again. */
NeoLKernel/drivers/net/ipg.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/ipg.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/irda/mcs7780.c:	netif_wake_queue(netdev);
NeoLKernel/drivers/net/irda/mcs7780.c:		netif_wake_queue(ndev);
NeoLKernel/drivers/net/irda/ali-ircc.c:static void ali_ircc_sir_write_wakeup(struct ali_ircc_cb *self);
NeoLKernel/drivers/net/irda/ali-ircc.c:					ali_ircc_sir_write_wakeup(self);				
NeoLKernel/drivers/net/irda/ali-ircc.c: * Function ali_ircc_sir_write_wakeup (tty)
NeoLKernel/drivers/net/irda/ali-ircc.c:static void ali_ircc_sir_write_wakeup(struct ali_ircc_cb *self)
NeoLKernel/drivers/net/irda/ali-ircc.c:			netif_wake_queue(self->netdev);	
NeoLKernel/drivers/net/irda/ali-ircc.c:	netif_wake_queue(self->netdev);	
NeoLKernel/drivers/net/irda/ali-ircc.c:		netif_wake_queue(self->netdev);
NeoLKernel/drivers/net/irda/ali-ircc.c:		netif_wake_queue(self->netdev);
NeoLKernel/drivers/net/irda/au1k_ir.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/irda/au1k_ir.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/irda/bfin_sir.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/irda/bfin_sir.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/irda/bfin_sir.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/irda/donauboe.c:          netif_wake_queue(self->netdev);
NeoLKernel/drivers/net/irda/donauboe.c:toshoboe_wakeup (struct pci_dev *pci_dev)
NeoLKernel/drivers/net/irda/donauboe.c:  netif_wake_queue(self->netdev);
NeoLKernel/drivers/net/irda/donauboe.c:	.resume		= toshoboe_wakeup 
NeoLKernel/drivers/net/irda/irda-usb.c:	netif_wake_queue(self->netdev);
NeoLKernel/drivers/net/irda/irda-usb.c:			/* Will netif_wake_queue() in callback */
NeoLKernel/drivers/net/irda/irda-usb.c:			netif_wake_queue(self->netdev);
NeoLKernel/drivers/net/irda/irda-usb.c:		netif_wake_queue(self->netdev);
NeoLKernel/drivers/net/irda/irda-usb.c: * the packet has been sent (i.e. no call to netif_wake_queue()),
NeoLKernel/drivers/net/irda/irda-usb.c:			/* Note : above will  *NOT* call netif_wake_queue()
NeoLKernel/drivers/net/irda/irda-usb.c:			netif_wake_queue(self->netdev);
NeoLKernel/drivers/net/irda/irda-usb.c:			/* Note : above will  *NOT* call netif_wake_queue()
NeoLKernel/drivers/net/irda/irda-usb.c:			netif_wake_queue(self->netdev);
NeoLKernel/drivers/net/irda/irtty-sir.c: * Function irtty_write_wakeup (tty)
NeoLKernel/drivers/net/irda/irtty-sir.c:static void irtty_write_wakeup(struct tty_struct *tty) 
NeoLKernel/drivers/net/irda/irtty-sir.c:	.write_wakeup	= irtty_write_wakeup,
NeoLKernel/drivers/net/irda/kingsun-sir.c:	netif_wake_queue(netdev);
NeoLKernel/drivers/net/irda/ks959-sir.c:			/* All data sent, send next speed && wake network queue */
NeoLKernel/drivers/net/irda/ks959-sir.c:			netif_wake_queue(netdev);
NeoLKernel/drivers/net/irda/ksdazzle-sir.c:			/* All data sent, send next speed && wake network queue */
NeoLKernel/drivers/net/irda/ksdazzle-sir.c:			netif_wake_queue(netdev);
NeoLKernel/drivers/net/irda/nsc-ircc.c:	 * power mode (wake up from sleep mode) (bit 1) */
NeoLKernel/drivers/net/irda/nsc-ircc.c:	 * power mode (wake up from sleep mode) (bit 1) */
NeoLKernel/drivers/net/irda/nsc-ircc.c:				netif_wake_queue(dev);
NeoLKernel/drivers/net/irda/nsc-ircc.c:				netif_wake_queue(dev);
NeoLKernel/drivers/net/irda/nsc-ircc.c:		netif_wake_queue(self->netdev);
NeoLKernel/drivers/net/irda/nsc-ircc.c:		netif_wake_queue(self->netdev);
NeoLKernel/drivers/net/irda/nsc-ircc.c:			netif_wake_queue(self->netdev);
NeoLKernel/drivers/net/irda/nsc-ircc.c:			netif_wake_queue(self->netdev);
NeoLKernel/drivers/net/irda/nsc-ircc.c:		netif_wake_queue(self->netdev);
NeoLKernel/drivers/net/irda/nsc-ircc.h:#define CFG_39X_IRQNUM	0x70	/* Interrupt number & wake up enable */
NeoLKernel/drivers/net/irda/pxaficp_ir.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/irda/pxaficp_ir.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/irda/pxaficp_ir.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/irda/sa1100_ir.c:		 * This automatically wakes up the queue
NeoLKernel/drivers/net/irda/sa1100_ir.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/irda/sa1100_ir.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/irda/sir_dev.c:			netif_wake_queue(dev->netdev);
NeoLKernel/drivers/net/irda/sir_dev.c:			netif_wake_queue(dev->netdev);
NeoLKernel/drivers/net/irda/sir_dev.c:	 * if not we switch to rx mode and wake the queue for further
NeoLKernel/drivers/net/irda/sir_dev.c:			netif_wake_queue(dev->netdev);
NeoLKernel/drivers/net/irda/sir_dev.c:		netif_wake_queue(dev->netdev);
NeoLKernel/drivers/net/irda/sir_dev.c:				 * fsm completes and wakes the queue.
NeoLKernel/drivers/net/irda/sir_dev.c:		netif_wake_queue(ndev);
NeoLKernel/drivers/net/irda/sir_dev.c:	netif_wake_queue(ndev);
NeoLKernel/drivers/net/irda/smsc-ircc2.c:static void smsc_ircc_sir_write_wakeup(struct smsc_ircc_cb *self);
NeoLKernel/drivers/net/irda/smsc-ircc2.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/irda/smsc-ircc2.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/irda/smsc-ircc2.c:	netif_wake_queue(self->netdev);
NeoLKernel/drivers/net/irda/smsc-ircc2.c:				smsc_ircc_sir_write_wakeup(self);
NeoLKernel/drivers/net/irda/smsc-ircc2.c: * Function smsc_sir_write_wakeup (self)
NeoLKernel/drivers/net/irda/smsc-ircc2.c:static void smsc_ircc_sir_write_wakeup(struct smsc_ircc_cb *self)
NeoLKernel/drivers/net/irda/smsc-ircc2.c:			netif_wake_queue(self->netdev);
NeoLKernel/drivers/net/irda/stir4200.c:        wake_up_process(stir->thread);
NeoLKernel/drivers/net/irda/stir4200.c:	/* this should never happen unless stop/wakeup problem */
NeoLKernel/drivers/net/irda/stir4200.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/irda/stir4200.c:		wake_up_process(stir->thread);
NeoLKernel/drivers/net/irda/stir4200.c:	/* receiver restarted when send thread wakes up */
NeoLKernel/drivers/net/irda/via-ircc.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/irda/via-ircc.c://F01   if (self->tx_fifo.free < (MAX_TX_WINDOW -1 )) netif_wake_queue(self->netdev);
NeoLKernel/drivers/net/irda/via-ircc.c:	netif_wake_queue(self->netdev);
NeoLKernel/drivers/net/irda/vlsi_ir.c:	seq_printf(seq, "CLKCTL: PLL %s%s%s / clock %s / wakeup %s\n",
NeoLKernel/drivers/net/irda/vlsi_ir.c:			netif_wake_queue(ndev);
NeoLKernel/drivers/net/irda/vlsi_ir.c:		netif_wake_queue(ndev);
NeoLKernel/drivers/net/irda/vlsi_ir.h:	CLKCTL_WAKE		= 0x08		/* set to enable wakeup feature: whenever IR activity
NeoLKernel/drivers/net/irda/w83977af_ir.c:	netif_wake_queue(self->netdev);
NeoLKernel/drivers/net/irda/w83977af_ir.c:	netif_wake_queue(self->netdev);
NeoLKernel/drivers/net/irda/w83977af_ir.c:			netif_wake_queue(self->netdev);
NeoLKernel/drivers/net/isa-skeleton.c:	 * requests, wake up the queueing layer.  This would
NeoLKernel/drivers/net/isa-skeleton.c:	 * netif_wake_queue() call should be placed in the
NeoLKernel/drivers/net/isa-skeleton.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/isa-skeleton.c:	 * wake up the queue.
NeoLKernel/drivers/net/isa-skeleton.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/isa-skeleton.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/iseries_veth.c:static void veth_wake_queues(struct veth_lpar_connection *cnx);
NeoLKernel/drivers/net/iseries_veth.c:			veth_wake_queues(cnx);
NeoLKernel/drivers/net/iseries_veth.c:		veth_wake_queues(cnx);
NeoLKernel/drivers/net/iseries_veth.c:static void veth_wake_queues(struct veth_lpar_connection *cnx)
NeoLKernel/drivers/net/iseries_veth.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/ixgb/ixgb_ethtool.c:	netif_wake_queue(netdev);
NeoLKernel/drivers/net/ixgb/ixgb_main.c:	netif_wake_queue(netdev);
NeoLKernel/drivers/net/ixgb/ixgb_main.c:			netif_wake_queue(netdev);
NeoLKernel/drivers/net/ixgbe/ixgbe_ethtool.c:	    !device_can_wakeup(&adapter->pdev->dev))
NeoLKernel/drivers/net/ixgbe/ixgbe_ethtool.c:	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);
NeoLKernel/drivers/net/ixgbe/ixgbe_main.c:			netif_wake_subqueue(netdev, tx_ring->queue_index);
NeoLKernel/drivers/net/ixgbe/ixgbe_main.c:	pci_wake_from_d3(pdev, false);
NeoLKernel/drivers/net/ixgbe/ixgbe_main.c:static int __ixgbe_shutdown(struct pci_dev *pdev, bool *enable_wake)
NeoLKernel/drivers/net/ixgbe/ixgbe_main.c:		/* turn on all-multi mode if wake on multicast is enabled */
NeoLKernel/drivers/net/ixgbe/ixgbe_main.c:		pci_wake_from_d3(pdev, true);
NeoLKernel/drivers/net/ixgbe/ixgbe_main.c:		pci_wake_from_d3(pdev, false);
NeoLKernel/drivers/net/ixgbe/ixgbe_main.c:	*enable_wake = !!wufc;
NeoLKernel/drivers/net/ixgbe/ixgbe_main.c:	bool wake;
NeoLKernel/drivers/net/ixgbe/ixgbe_main.c:	retval = __ixgbe_shutdown(pdev, &wake);
NeoLKernel/drivers/net/ixgbe/ixgbe_main.c:	if (wake) {
NeoLKernel/drivers/net/ixgbe/ixgbe_main.c:		pci_wake_from_d3(pdev, false);
NeoLKernel/drivers/net/ixgbe/ixgbe_main.c:	bool wake;
NeoLKernel/drivers/net/ixgbe/ixgbe_main.c:	__ixgbe_shutdown(pdev, &wake);
NeoLKernel/drivers/net/ixgbe/ixgbe_main.c:		pci_wake_from_d3(pdev, wake);
NeoLKernel/drivers/net/ixgbe/ixgbe_main.c:		/* Enable ACPI wakeup in GRC */
NeoLKernel/drivers/net/ixgbe/ixgbe_main.c:	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);
NeoLKernel/drivers/net/ixgbe/ixgbe_main.c:		pci_wake_from_d3(pdev, false);
NeoLKernel/drivers/net/ixgbe/ixgbe_type.h:#define IXGBE_WUPM      0x05A00 /* wake up pkt memory 0x5A00-0x5A7C */
NeoLKernel/drivers/net/ixgbe/ixgbe_type.h:/* Definitions for power management and wakeup registers */
NeoLKernel/drivers/net/ixgbe/ixgbe_type.h:#define IXGBE_WUC_ADVD3WUC   0x00000010 /* D3Cold wake up cap. enable*/
NeoLKernel/drivers/net/ixgbe/ixgbe_type.h:#define IXGBE_WUFC_ALL_FILTERS     0x003F00FF /* Mask for all 6 wakeup filters*/
NeoLKernel/drivers/net/ixp2000/ixpdev.c:	u32 wake;
NeoLKernel/drivers/net/ixp2000/ixpdev.c:	wake = 0;
NeoLKernel/drivers/net/ixp2000/ixpdev.c:			wake |= 1 << channel;
NeoLKernel/drivers/net/ixp2000/ixpdev.c:	for (channel = 0; wake != 0; channel++) {
NeoLKernel/drivers/net/ixp2000/ixpdev.c:		if (wake & (1 << channel)) {
NeoLKernel/drivers/net/ixp2000/ixpdev.c:			netif_wake_queue(nds[channel]);
NeoLKernel/drivers/net/ixp2000/ixpdev.c:			wake &= ~(1 << channel);
NeoLKernel/drivers/net/jme.c:jme_setup_wakeup_frame(struct jme_adapter *jme,
NeoLKernel/drivers/net/jme.c:		jme_setup_wakeup_frame(jme, mask, crc, i);
NeoLKernel/drivers/net/jme.c:	pci_enable_wake(jme->pdev, PCI_D0, false);
NeoLKernel/drivers/net/jme.c:jme_wake_queue_if_stopped(struct jme_adapter *jme)
NeoLKernel/drivers/net/jme.c:	atomic_read(&txring->nr_free) >= (jme->tx_wake_threshold))) {
NeoLKernel/drivers/net/jme.c:		netif_wake_queue(jme->dev);
NeoLKernel/drivers/net/jme.c:	jme_wake_queue_if_stopped(jme);
NeoLKernel/drivers/net/jme.c:			>= (jme->tx_wake_threshold)) {
NeoLKernel/drivers/net/jme.c:			netif_wake_queue(jme->dev);
NeoLKernel/drivers/net/jme.c:		msg_tx_err(jme, "BUG! Tx ring full when queue awake!\n");
NeoLKernel/drivers/net/jme.c:	jme->tx_wake_threshold = 1 << 9;
NeoLKernel/drivers/net/jme.c:		pci_enable_wake(pdev, PCI_D3cold, true);
NeoLKernel/drivers/net/jme.h:	u32			tx_wake_threshold;
NeoLKernel/drivers/net/jme.h:	RXCS_WAKEUP	= 0x00000040, /* Enable receive wakeup packet */
NeoLKernel/drivers/net/Kconfig:	  Debug stats on wakeup counts.
NeoLKernel/drivers/net/amd8111e.c:			netif_wake_queue (dev);
NeoLKernel/drivers/net/amd8111e.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/amd8111e.c:		pci_enable_wake(pci_dev, PCI_D3hot, 1);
NeoLKernel/drivers/net/amd8111e.c:		pci_enable_wake(pci_dev, PCI_D3cold, 1);
NeoLKernel/drivers/net/amd8111e.c:		pci_enable_wake(pci_dev, PCI_D3hot, 0);
NeoLKernel/drivers/net/amd8111e.c:		pci_enable_wake(pci_dev, PCI_D3cold, 0);
NeoLKernel/drivers/net/amd8111e.c:	pci_enable_wake(pci_dev, PCI_D3hot, 0);
NeoLKernel/drivers/net/amd8111e.c:	pci_enable_wake(pci_dev, PCI_D3cold, 0); /* D3 cold */
NeoLKernel/drivers/net/appletalk/cops.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/appletalk/cops.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/appletalk/cops.c:                	netif_wake_queue(dev);
NeoLKernel/drivers/net/appletalk/cops.c:				netif_wake_queue(dev);
NeoLKernel/drivers/net/appletalk/cops.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/appletalk/ltpc.c: * Clean up initial probing -- sometimes the card wakes up latched in reset.
NeoLKernel/drivers/net/arcnet/arcnet.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/arcnet/arcnet.c:				netif_wake_queue(dev);
NeoLKernel/drivers/net/ariadne.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/ariadne.c:    netif_wake_queue(dev);
NeoLKernel/drivers/net/ariadne.c:    netif_wake_queue(dev);
NeoLKernel/drivers/net/arm/am79c961a.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/arm/am79c961a.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/arm/at91_ether.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/arm/ep93xx_eth.c:	int wake;
NeoLKernel/drivers/net/arm/ep93xx_eth.c:	wake = 0;
NeoLKernel/drivers/net/arm/ep93xx_eth.c:			wake = 1;
NeoLKernel/drivers/net/arm/ep93xx_eth.c:	if (wake)
NeoLKernel/drivers/net/arm/ep93xx_eth.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/arm/ether1.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/arm/ether1.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/arm/ether3.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/arm/ether3.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/arm/ixp4xx_eth.c:			netif_wake_queue(port->netdev);
NeoLKernel/drivers/net/arm/ixp4xx_eth.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/arm/ks8695net.c:	netif_wake_queue(ndev);
NeoLKernel/drivers/net/arm/w90p910_ether.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/arm/w90p910_ether.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/arm/w90p910_ether.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/at1700.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/at1700.c:				netif_wake_queue (dev);
NeoLKernel/drivers/net/at1700.c:				netif_wake_queue (dev);
NeoLKernel/drivers/net/atarilance.c:	netif_wake_queue (dev);
NeoLKernel/drivers/net/atarilance.c:				netif_wake_queue (dev);
NeoLKernel/drivers/net/atl1c/atl1c_ethtool.c:	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);
NeoLKernel/drivers/net/atl1c/atl1c_main.c:	pci_enable_wake(pdev, PCI_D3hot, 0);
NeoLKernel/drivers/net/atl1c/atl1c_main.c:	pci_enable_wake(pdev, PCI_D3cold, 0);
NeoLKernel/drivers/net/atl1c/atl1c_main.c:		netif_wake_queue(adapter->netdev);
NeoLKernel/drivers/net/atl1c/atl1c_main.c:			/* only link up can wake up */
NeoLKernel/drivers/net/atl1c/atl1c_main.c:		pci_enable_wake(pdev, pci_choose_state(pdev, state), 1);
NeoLKernel/drivers/net/atl1c/atl1c_main.c:	pci_enable_wake(pdev, pci_choose_state(pdev, state), 0);
NeoLKernel/drivers/net/atl1c/atl1c_main.c:	pci_enable_wake(pdev, PCI_D3hot, 0);
NeoLKernel/drivers/net/atl1c/atl1c_main.c:	pci_enable_wake(pdev, PCI_D3cold, 0);
NeoLKernel/drivers/net/atl1c/atl1c_main.c:	/* enable device (incl. PCI PM wakeup and hotplug setup) */
NeoLKernel/drivers/net/atl1c/atl1c_main.c:	device_init_wakeup(&pdev->dev, 1);
NeoLKernel/drivers/net/atl1c/atl1c_main.c:	pci_enable_wake(pdev, PCI_D3hot, 0);
NeoLKernel/drivers/net/atl1c/atl1c_main.c:	pci_enable_wake(pdev, PCI_D3cold, 0);
NeoLKernel/drivers/net/atl1e/atl1e_ethtool.c:	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);
NeoLKernel/drivers/net/atl1e/atl1e_main.c:			netif_wake_queue(netdev);
NeoLKernel/drivers/net/atl1e/atl1e_main.c:		netif_wake_queue(adapter->netdev);
NeoLKernel/drivers/net/atl1e/atl1e_main.c:			/* only link up can wake up */
NeoLKernel/drivers/net/atl1e/atl1e_main.c:		pci_enable_wake(pdev, pci_choose_state(pdev, state), 1);
NeoLKernel/drivers/net/atl1e/atl1e_main.c:	pci_enable_wake(pdev, pci_choose_state(pdev, state), 0);
NeoLKernel/drivers/net/atl1e/atl1e_main.c:	pci_enable_wake(pdev, PCI_D3hot, 0);
NeoLKernel/drivers/net/atl1e/atl1e_main.c:	pci_enable_wake(pdev, PCI_D3cold, 0);
NeoLKernel/drivers/net/atl1e/atl1e_main.c:	pci_enable_wake(pdev, PCI_D3hot, 0);
NeoLKernel/drivers/net/atl1e/atl1e_main.c:	pci_enable_wake(pdev, PCI_D3cold, 0);
NeoLKernel/drivers/net/atlx/atl1.c:		netif_wake_queue(adapter->netdev);
NeoLKernel/drivers/net/atlx/atl1.c:		pci_enable_wake(pdev, pci_choose_state(pdev, state), 1);
NeoLKernel/drivers/net/atlx/atl1.c:		pci_enable_wake(pdev, pci_choose_state(pdev, state), 1);
NeoLKernel/drivers/net/atlx/atl1.c:	pci_enable_wake(pdev, pci_choose_state(pdev, state), 0);
NeoLKernel/drivers/net/atlx/atl1.c:	pci_enable_wake(pdev, PCI_D3hot, 0);
NeoLKernel/drivers/net/atlx/atl1.c:	pci_enable_wake(pdev, PCI_D3cold, 0);
NeoLKernel/drivers/net/atlx/atl2.c:			netif_wake_queue(adapter->netdev);
NeoLKernel/drivers/net/atlx/atl2.c:			netif_wake_queue(netdev);
NeoLKernel/drivers/net/atlx/atl2.c:		pci_enable_wake(pdev, pci_choose_state(pdev, state), 1);
NeoLKernel/drivers/net/atlx/atl2.c:		pci_enable_wake(pdev, pci_choose_state(pdev, state), 1);
NeoLKernel/drivers/net/atlx/atl2.c:	pci_enable_wake(pdev, pci_choose_state(pdev, state), 0);
NeoLKernel/drivers/net/atlx/atl2.c:	pci_enable_wake(pdev, PCI_D3hot, 0);
NeoLKernel/drivers/net/atlx/atl2.c:	pci_enable_wake(pdev, PCI_D3cold, 0);
NeoLKernel/drivers/net/atp.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/atp.c:				netif_wake_queue(dev);	/* Inform upper layers. */
NeoLKernel/drivers/net/au1000_eth.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/au1000_eth.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/au1000_eth.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/b44.c:/* minimum number of free TX descriptors required to wake up TX process */
NeoLKernel/drivers/net/b44.c:		netif_wake_queue(bp->dev);
NeoLKernel/drivers/net/b44.c:		netif_wake_queue(bp->dev);
NeoLKernel/drivers/net/b44.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/b44.c:		printk(KERN_ERR PFX "%s: BUG! Tx Ring full when queue awake!\n",
NeoLKernel/drivers/net/b44.c:	/* enable wakeup pattern matching */
NeoLKernel/drivers/net/b44.c:	netif_wake_queue(bp->dev);
NeoLKernel/drivers/net/b44.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/bcm63xx_enet.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/benet/be_main.c:		 * tx compls of the current transmit which'll wake up the queue
NeoLKernel/drivers/net/benet/be_main.c:		/* As Tx wrbs have been freed up, wake up netdev queue if
NeoLKernel/drivers/net/benet/be_main.c:			netif_wake_queue(adapter->netdev);
NeoLKernel/drivers/net/bfin_mac.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/ppp_synctty.c:ppp_sync_wakeup(struct tty_struct *tty)
NeoLKernel/drivers/net/ppp_synctty.c:	.write_wakeup = ppp_sync_wakeup,
NeoLKernel/drivers/net/ppp_synctty.c:		ppp_output_wakeup(&ap->chan);
NeoLKernel/drivers/net/ppp_synctty.c: * If the packet was not accepted, we will call ppp_output_wakeup
NeoLKernel/drivers/net/ppp_synctty.c:		ppp_output_wakeup(&ap->chan);
NeoLKernel/drivers/net/ps3_gelic_net.c:static void gelic_card_wake_queues(struct gelic_card *card)
NeoLKernel/drivers/net/ps3_gelic_net.c:	netif_wake_queue(card->netdev[GELIC_PORT_ETHERNET]);
NeoLKernel/drivers/net/ps3_gelic_net.c:		netif_wake_queue(card->netdev[GELIC_PORT_WIRELESS]);
NeoLKernel/drivers/net/ps3_gelic_net.c:		gelic_card_wake_queues(card);
NeoLKernel/drivers/net/ps3_gelic_net.h:					       * wakeup trigger packet
NeoLKernel/drivers/net/qlge/qlge_main.c:			netif_wake_subqueue(qdev->ndev, tx_ring->wq_id);
NeoLKernel/drivers/net/qlge/qlge_main.c:	pci_enable_wake(pdev, PCI_D3hot, 0);
NeoLKernel/drivers/net/qlge/qlge_main.c:	pci_enable_wake(pdev, PCI_D3cold, 0);
NeoLKernel/drivers/net/qlge/qlge_mpi.c: * parameters, or loopback mode. We wake up a worker
NeoLKernel/drivers/net/qlge/qlge_mpi.c:	/* Load the mailbox registers and wake up MPI RISC. */
NeoLKernel/drivers/net/r6040.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/r8169.c:	BWF		= (1 << 6),	/* Accept Broadcast wakeup frame */
NeoLKernel/drivers/net/r8169.c:	MWF		= (1 << 5),	/* Accept Multicast wakeup frame */
NeoLKernel/drivers/net/r8169.c:	UWF		= (1 << 4),	/* Accept Unicast wakeup frame */
NeoLKernel/drivers/net/r8169.c:	device_set_wakeup_enable(&tp->pci_dev->dev, wol->wolopts);
NeoLKernel/drivers/net/r8169.c:	/* enable device (incl. PCI PM wakeup and hotplug setup) */
NeoLKernel/drivers/net/r8169.c:	device_set_wakeup_enable(&pdev->dev, tp->features & RTL_FEATURE_WOL);
NeoLKernel/drivers/net/r8169.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/r8169.c:			       "%s: BUG! Tx Ring full when queue awake!\n",
NeoLKernel/drivers/net/r8169.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/r8169.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/r8169.c:		pci_wake_from_d3(pdev, true);
NeoLKernel/drivers/net/rionet.c:		printk(KERN_ERR "%s: BUG! Tx Ring full when queue awake!\n",
NeoLKernel/drivers/net/rionet.c:		netif_wake_queue(ndev);
NeoLKernel/drivers/net/rrunner.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/rrunner.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/s2io.c:static inline void s2io_wake_all_tx_queue(struct s2io_nic *sp)
NeoLKernel/drivers/net/s2io.c:	netif_tx_wake_all_queues(sp->dev);
NeoLKernel/drivers/net/s2io.c:static inline void s2io_wake_tx_queue(
NeoLKernel/drivers/net/s2io.c:			netif_wake_subqueue(fifo->dev, fifo->fifo_no);
NeoLKernel/drivers/net/s2io.c:			netif_wake_queue(fifo->dev);
NeoLKernel/drivers/net/s2io.c:	s2io_wake_tx_queue(fifo_data, pkt_cnt, nic->config.multiq);
NeoLKernel/drivers/net/s2io.c:	wake_up(&sp->msi_wait);
NeoLKernel/drivers/net/s2io.c:		s2io_wake_all_tx_queue(sp);
NeoLKernel/drivers/net/s2io.c:	s2io_wake_all_tx_queue(sp);
NeoLKernel/drivers/net/s2io.c:			s2io_wake_all_tx_queue(sp);
NeoLKernel/drivers/net/s2io.c:	netif_tx_wake_all_queues(netdev);
NeoLKernel/drivers/net/s6gmac.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/s6gmac.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/sb1250-mac.c:	 * Decide if we should wake up the protocol or not.
NeoLKernel/drivers/net/sb1250-mac.c:		netif_wake_queue(d->sbdma_eth->sbm_dev);
NeoLKernel/drivers/net/sc92031.c:   Wakeup0    = 0x88,         // power Manager wakeup( Eight 64bit regiser)
NeoLKernel/drivers/net/sc92031.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/sc92031.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/sc92031.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/sc92031.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/seeq8005.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/seeq8005.c:			netif_wake_queue(dev);	/* Inform upper layers. */
NeoLKernel/drivers/net/sfc/efx.c:		efx_wake_queue(efx);
NeoLKernel/drivers/net/sfc/efx.h:extern void efx_wake_queue(struct efx_nic *efx);
NeoLKernel/drivers/net/sfc/falcon.c:		EFX_TRACE(efx, "channel %d RXQ %d wakeup event\n",
NeoLKernel/drivers/net/sfc/falcon.c:	/* Set the SRAM wake/sleep GPIO appropriately. */
NeoLKernel/drivers/net/sfc/tx.c:void efx_wake_queue(struct efx_nic *efx)
NeoLKernel/drivers/net/sfc/tx.c:		netif_wake_queue(efx->net_dev);
NeoLKernel/drivers/net/sfc/tx.c:				efx_wake_queue(efx);
NeoLKernel/drivers/net/sfc/tx.c:		efx_wake_queue(tx_queue->efx);
NeoLKernel/drivers/net/typhoon.c:	 * between marking the queue awake and updating the cleared index.
NeoLKernel/drivers/net/typhoon.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/typhoon.c:		netif_wake_queue(tp->dev);
NeoLKernel/drivers/net/typhoon.c:		printk(KERN_ERR "%s: typhoon_sleep(): wake events cmd err %d\n",
NeoLKernel/drivers/net/typhoon.c:	pci_enable_wake(tp->pdev, state, 1);
NeoLKernel/drivers/net/typhoon.c:typhoon_wakeup(struct typhoon *tp, int wait_type)
NeoLKernel/drivers/net/typhoon.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/typhoon.c:	err = typhoon_wakeup(tp, WaitSleep);
NeoLKernel/drivers/net/typhoon.c:		printk(KERN_ERR "%s: unable to wakeup device\n", dev->name);
NeoLKernel/drivers/net/typhoon.c:	if(typhoon_wakeup(tp, WaitNoSleep) < 0) {
NeoLKernel/drivers/net/typhoon.c:		printk(KERN_ERR "%s: critical: could not wake up in resume\n",
NeoLKernel/drivers/net/ucc_geth.c:	netif_tx_wake_all_queues(ugeth->ndev);
NeoLKernel/drivers/net/ucc_geth.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/ucc_geth.c:	device_set_wakeup_capable(&dev->dev,
NeoLKernel/drivers/net/ucc_geth.c:	device_set_wakeup_enable(&dev->dev, ugeth->wol_en);
NeoLKernel/drivers/net/ucc_geth.c:	 * Disable the controller, otherwise we'll wakeup on any network
NeoLKernel/drivers/net/ucc_geth_ethtool.c:	device_set_wakeup_enable(&netdev->dev, ugeth->wol_en);
NeoLKernel/drivers/net/usb/catc.c:		netif_wake_queue(catc->netdev);
NeoLKernel/drivers/net/usb/catc.c:	netif_wake_queue(catc->netdev);
NeoLKernel/drivers/net/usb/cdc-phonet.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/usb/cdc-phonet.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/usb/hso.c:	netif_wake_queue(odev->net);
NeoLKernel/drivers/net/usb/hso.c:		wake_up_interruptible(&tiocmget->waitq);
NeoLKernel/drivers/net/usb/hso.c:		tty_wakeup(tty);
NeoLKernel/drivers/net/usb/hso.c:			tty_wakeup(tty);
NeoLKernel/drivers/net/usb/hso.c:		wake_up_interruptible(&tiocmget->waitq);
NeoLKernel/drivers/net/usb/hso.c:	interface->needs_remote_wakeup = 1;
NeoLKernel/drivers/net/usb/kaweth.c:		wake_up(&kaweth->term_wait);
NeoLKernel/drivers/net/usb/kaweth.c:		/* we are killed - set a flag and wake the disconnect handler */
NeoLKernel/drivers/net/usb/kaweth.c:		wake_up(&kaweth->term_wait);
NeoLKernel/drivers/net/usb/kaweth.c:	netif_wake_queue(kaweth->net);
NeoLKernel/drivers/net/usb/kaweth.c:	netif_wake_queue(net);
NeoLKernel/drivers/net/usb/kaweth.c:	wake_up(&awd->wqh);
NeoLKernel/drivers/net/usb/pegasus.c:	wake_up(&pegasus->ctrl_wait);
NeoLKernel/drivers/net/usb/pegasus.c:	/* using ATOMIC, we'd never wake up if we slept */
NeoLKernel/drivers/net/usb/pegasus.c:	netif_wake_queue(net);
NeoLKernel/drivers/net/usb/rtl8150.c:	netif_wake_queue(dev->netdev);
NeoLKernel/drivers/net/usb/rtl8150.c:	netif_wake_queue(netdev);
NeoLKernel/drivers/net/usb/usbnet.c:// reawaken network queue this soon after stopping; else watchdog barks
NeoLKernel/drivers/net/usb/usbnet.c:// between wakeups
NeoLKernel/drivers/net/usb/usbnet.c:	DECLARE_WAIT_QUEUE_HEAD_ONSTACK (unlink_wakeup);
NeoLKernel/drivers/net/usb/usbnet.c:		add_wait_queue(&unlink_wakeup, &wait);
NeoLKernel/drivers/net/usb/usbnet.c:		dev->wait = &unlink_wakeup;
NeoLKernel/drivers/net/usb/usbnet.c:		remove_wait_queue(&unlink_wakeup, &wait);
NeoLKernel/drivers/net/usb/usbnet.c:				netif_wake_queue (dev->net);
NeoLKernel/drivers/net/usb/usbnet.c:			wake_up (dev->wait);
NeoLKernel/drivers/net/usb/usbnet.c:			netif_wake_queue (dev->net);
NeoLKernel/drivers/net/usb/usbnet.c:		 * wake the device
NeoLKernel/drivers/net/via-rhine.c:	/* Turn off EEPROM-controlled wake-up (magic packet) */
NeoLKernel/drivers/net/via-rhine.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/via-rhine.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/via-rhine.c:		 * Turn EEPROM-controlled wake-up back on -- some hardware may
NeoLKernel/drivers/net/via-rhine.c:	/* TODO: Check use of pci_enable_wake() */
NeoLKernel/drivers/net/via-velocity.c: *	Called after we drop out of wake on lan mode in order to
NeoLKernel/drivers/net/via-velocity.c: *	the rest of the logic from the result of sleep/wakeup
NeoLKernel/drivers/net/via-velocity.c:/* wol_opts[] is used for controlling wake on lan behavior.
NeoLKernel/drivers/net/via-velocity.c:		mac_rx_queue_wake(regs);
NeoLKernel/drivers/net/via-velocity.c:				netif_wake_queue(vptr->dev);
NeoLKernel/drivers/net/via-velocity.c:		mac_rx_queue_wake(regs);
NeoLKernel/drivers/net/via-velocity.c:				netif_wake_queue(vptr->dev);
NeoLKernel/drivers/net/via-velocity.c:			netif_wake_queue(vptr->dev);
NeoLKernel/drivers/net/via-velocity.c:		mac_rx_queue_wake(vptr->mac_regs);
NeoLKernel/drivers/net/via-velocity.c:		netif_wake_queue(vptr->dev);
NeoLKernel/drivers/net/via-velocity.c:		mac_tx_queue_wake(vptr->mac_regs, qnum);
NeoLKernel/drivers/net/via-velocity.c: *	Compute the wake on lan crc hashes for the packet header
NeoLKernel/drivers/net/via-velocity.c: *	velocity_set_wol	-	set up for wake on lan
NeoLKernel/drivers/net/via-velocity.c: *	Set a card up for wake on lan either by unicast or by
NeoLKernel/drivers/net/via-velocity.c:		pci_enable_wake(pdev, PCI_D3hot, 1);
NeoLKernel/drivers/net/via-velocity.c:	pci_enable_wake(pdev, 0, 0);
NeoLKernel/drivers/net/via-velocity.c:			mac_tx_queue_wake(vptr->mac_regs, i);
NeoLKernel/drivers/net/via-velocity.h:#define mac_rx_queue_wake(regs) {\
NeoLKernel/drivers/net/via-velocity.h:#define mac_tx_queue_wake(regs, n) {\
NeoLKernel/drivers/net/via-velocity.h: *	configure wakeup with WOL for ARP. If there are multiple IP
NeoLKernel/drivers/net/virtio_net.c:	netif_wake_queue(vi->dev);
NeoLKernel/drivers/net/virtio_net.c:		netif_wake_queue(vi->dev);
NeoLKernel/drivers/net/vmxnet3/vmxnet3_defs.h:#define VMXNET3_PM_WAKEUP_MAGIC       0x01  /* wake up on magic pkts */
NeoLKernel/drivers/net/vmxnet3/vmxnet3_defs.h:#define VMXNET3_PM_WAKEUP_FILTER      0x02  /* wake up on pkts matching
NeoLKernel/drivers/net/vmxnet3/vmxnet3_defs.h:	u16		wakeUpEvents;  /* VMXNET3_PM_WAKEUP_xxx */
NeoLKernel/drivers/net/vmxnet3/vmxnet3_drv.c:vmxnet3_tq_wake(struct vmxnet3_tx_queue *tq, struct vmxnet3_adapter *adapter)
NeoLKernel/drivers/net/vmxnet3/vmxnet3_drv.c:	netif_wake_queue(adapter->netdev);
NeoLKernel/drivers/net/vmxnet3/vmxnet3_drv.c:			vmxnet3_tq_wake(tq, adapter);
NeoLKernel/drivers/net/vmxnet3/vmxnet3_drv.c:	/* Create wake-up filters. */
NeoLKernel/drivers/net/vmxnet3/vmxnet3_drv.c:		pmConf->wakeUpEvents |= VMXNET3_PM_WAKEUP_FILTER;
NeoLKernel/drivers/net/vmxnet3/vmxnet3_drv.c:		pmConf->wakeUpEvents |= VMXNET3_PM_WAKEUP_FILTER;
NeoLKernel/drivers/net/vmxnet3/vmxnet3_drv.c:		pmConf->wakeUpEvents |= VMXNET3_PM_WAKEUP_MAGIC;
NeoLKernel/drivers/net/vmxnet3/vmxnet3_drv.c:	pci_enable_wake(pdev, pci_choose_state(pdev, PMSG_SUSPEND),
NeoLKernel/drivers/net/vmxnet3/vmxnet3_drv.c:	/* Destroy wake-up filters. */
NeoLKernel/drivers/net/vmxnet3/vmxnet3_drv.c:	pci_enable_wake(pdev, PCI_D0, 0);
NeoLKernel/drivers/net/vmxnet3/vmxnet3_ethtool.c:	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);
NeoLKernel/drivers/net/vmxnet3/vmxnet3_int.h:	VMNET_CAP_WAKE_PCKT_RCV = 0x0800, /* Can wake on network packet recv? */
NeoLKernel/drivers/net/vxge/vxge-main.c:static void vxge_wake_all_tx_queue(struct vxgedev *vdev)
NeoLKernel/drivers/net/vxge/vxge-main.c:	netif_tx_wake_all_queues(dev);
NeoLKernel/drivers/net/vxge/vxge-main.c:void vxge_wake_tx_queue(struct vxge_fifo *fifo, struct sk_buff *skb)
NeoLKernel/drivers/net/vxge/vxge-main.c:			netif_tx_wake_queue(txq);
NeoLKernel/drivers/net/vxge/vxge-main.c:				netif_tx_wake_queue(txq);
NeoLKernel/drivers/net/vxge/vxge-main.c:	vxge_wake_all_tx_queue(vdev);
NeoLKernel/drivers/net/vxge/vxge-main.c:	vxge_wake_tx_queue(fifo, skb);
NeoLKernel/drivers/net/vxge/vxge-main.c:	vxge_wake_tx_queue(&vdev->vpaths[vp_id].fifo, NULL);
NeoLKernel/drivers/net/vxge/vxge-main.c:		vxge_wake_all_tx_queue(vdev);
NeoLKernel/drivers/net/vxge/vxge-main.h:void vxge_wake_tx_queue(struct vxge_fifo *fifo, struct sk_buff *skb);
NeoLKernel/drivers/net/vxge/vxge-traffic.h: *            to awaken the VPATH).
NeoLKernel/drivers/net/wan/ixp4xx_hss.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/wan/ixp4xx_hss.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/wan/cosa.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/wan/cosa.c:	netif_wake_queue(chan->netdev);
NeoLKernel/drivers/net/wan/cosa.c:	wake_up_interruptible(&chan->rxwaitq);
NeoLKernel/drivers/net/wan/cosa.c:	wake_up_interruptible(&chan->txwaitq);
NeoLKernel/drivers/net/wan/cycx_x25.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/wan/cycx_x25.c:	wake_up_interruptible(&card->wait_stats);
NeoLKernel/drivers/net/wan/cycx_x25.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/wan/cycx_x25.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/wan/dscc4.c:				netif_wake_queue(dev);
NeoLKernel/drivers/net/wan/farsync.c:						netif_wake_queue(port_to_dev
NeoLKernel/drivers/net/wan/farsync.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/wan/farsync.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/wan/hd64570.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/wan/hd64572.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/wan/lmc/lmc_main.c:            netif_wake_queue(dev);
NeoLKernel/drivers/net/wan/lmc/lmc_main.c:    netif_wake_queue(dev);
NeoLKernel/drivers/net/wan/lmc/lmc_main.c:    netif_wake_queue(dev);
NeoLKernel/drivers/net/wan/lmc/lmc_main.c:            netif_wake_queue(dev);
NeoLKernel/drivers/net/wan/lmc/lmc_main.c:        netif_wake_queue(dev);
NeoLKernel/drivers/net/wan/lmc/lmc_main.c:        netif_wake_queue(dev);
NeoLKernel/drivers/net/wan/lmc/lmc_main.c:        netif_wake_queue(dev);
NeoLKernel/drivers/net/wan/pc300_drv.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/wan/pc300_drv.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/wan/pc300_drv.c:		netif_wake_queue(dev->dev);
NeoLKernel/drivers/net/wan/pc300_tty.c:	CPC_TTY_DBG("%s: call wake_up_interruptible\n",cpc_tty->name);
NeoLKernel/drivers/net/wan/pc300_tty.c:	tty_wakeup(tty);	
NeoLKernel/drivers/net/wan/pc300_tty.c: * o if need call line discipline wakeup
NeoLKernel/drivers/net/wan/pc300_tty.c: * o call wake_up_interruptible
NeoLKernel/drivers/net/wan/pc300_tty.c:	tty_wakeup(tty);
NeoLKernel/drivers/net/wan/sbni.c:				netif_wake_queue( nl->master );
NeoLKernel/drivers/net/wan/sbni.c:				netif_wake_queue( dev );
NeoLKernel/drivers/net/wan/sbni.c:	netif_wake_queue( dev );	/* Now we are able to transmit */
NeoLKernel/drivers/net/wan/sdla.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/wan/sdla.c:			netif_wake_queue(flp->master[i]);
NeoLKernel/drivers/net/wan/wanxl.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/wan/x25_asy.c:	netif_wake_queue(sl->dev);
NeoLKernel/drivers/net/wan/x25_asy.c:static void x25_asy_write_wakeup(struct tty_struct *tty)
NeoLKernel/drivers/net/wan/x25_asy.c:	.write_wakeup	= x25_asy_write_wakeup,
NeoLKernel/drivers/net/wan/z85230.c:	netif_wake_queue(c->netdevice);
NeoLKernel/drivers/net/wan/z85230.c: *	This is called when we complete a packet send. We wake the queue,
NeoLKernel/drivers/net/wimax/i2400m/control.c:		wake_up_all(&i2400m->state_wq);
NeoLKernel/drivers/net/wimax/i2400m/control.c:	 * in i2400m->ack_skb and wake us up. If we cancel the wait,
NeoLKernel/drivers/net/wimax/i2400m/i2400m.h:	struct work_struct wake_tx_ws;
NeoLKernel/drivers/net/wimax/i2400m/i2400m.h:	struct sk_buff *wake_tx_skb;
NeoLKernel/drivers/net/wimax/i2400m/i2400m.h:	/* wake_tx_ws is initialized in i2400m_tx_setup() */
NeoLKernel/drivers/net/wimax/i2400m/i2400m.h:extern void i2400m_wake_tx_work(struct work_struct *);
NeoLKernel/drivers/net/wimax/i2400m/netdev.c: *   i2400m_net_wake_tx	  Wake up device from basestation-IDLE & TX
NeoLKernel/drivers/net/wimax/i2400m/netdev.c: *     i2400m_wake_tx_work
NeoLKernel/drivers/net/wimax/i2400m/netdev.c: * we rely on wake_tx_skb() being non-NULL.
NeoLKernel/drivers/net/wimax/i2400m/netdev.c:	if (cancel_work_sync(&i2400m->wake_tx_ws) == 0
NeoLKernel/drivers/net/wimax/i2400m/netdev.c:	    && i2400m->wake_tx_skb != NULL) {
NeoLKernel/drivers/net/wimax/i2400m/netdev.c:		struct sk_buff *wake_tx_skb;
NeoLKernel/drivers/net/wimax/i2400m/netdev.c:		wake_tx_skb = i2400m->wake_tx_skb;	/* compat help */
NeoLKernel/drivers/net/wimax/i2400m/netdev.c:		i2400m->wake_tx_skb = NULL;	/* compat help */
NeoLKernel/drivers/net/wimax/i2400m/netdev.c:		kfree_skb(wake_tx_skb);
NeoLKernel/drivers/net/wimax/i2400m/netdev.c: * still wake the queue up to see if the next packet will be luckier.
NeoLKernel/drivers/net/wimax/i2400m/netdev.c:void i2400m_wake_tx_work(struct work_struct *ws)
NeoLKernel/drivers/net/wimax/i2400m/netdev.c:	struct i2400m *i2400m = container_of(ws, struct i2400m, wake_tx_ws);
NeoLKernel/drivers/net/wimax/i2400m/netdev.c:	struct sk_buff *skb = i2400m->wake_tx_skb;
NeoLKernel/drivers/net/wimax/i2400m/netdev.c:	skb = i2400m->wake_tx_skb;
NeoLKernel/drivers/net/wimax/i2400m/netdev.c:	i2400m->wake_tx_skb = NULL;
NeoLKernel/drivers/net/wimax/i2400m/netdev.c:	netif_wake_queue(i2400m->wimax_dev.net_dev);
NeoLKernel/drivers/net/wimax/i2400m/netdev.c: * When the device is in basestation-idle mode, we need to wake it up
NeoLKernel/drivers/net/wimax/i2400m/netdev.c:int i2400m_net_wake_tx(struct i2400m *i2400m, struct net_device *net_dev,
NeoLKernel/drivers/net/wimax/i2400m/netdev.c:	if (!work_pending(&i2400m->wake_tx_ws)) {
NeoLKernel/drivers/net/wimax/i2400m/netdev.c:		i2400m->wake_tx_skb = skb_get(skb);	/* transfer ref count */
NeoLKernel/drivers/net/wimax/i2400m/netdev.c:		result = schedule_work(&i2400m->wake_tx_ws);
NeoLKernel/drivers/net/wimax/i2400m/netdev.c: * If the device is idle, we need to wake it up; that is an operation
NeoLKernel/drivers/net/wimax/i2400m/netdev.c: * that will sleep. See i2400m_net_wake_tx() for details.
NeoLKernel/drivers/net/wimax/i2400m/netdev.c:		result = i2400m_net_wake_tx(i2400m, net_dev, skb);
NeoLKernel/drivers/net/wimax/i2400m/rx.c: * command, set or get, so wake up whoever is waiting for it from
NeoLKernel/drivers/net/wimax/i2400m/sdio-rx.c:		wake_up(&i2400ms->bm_wfa_wq);
NeoLKernel/drivers/net/wimax/i2400m/sdio-rx.c:	wake_up_all(&i2400ms->bm_wfa_wq);
NeoLKernel/drivers/net/wimax/i2400m/tx.c:	INIT_WORK(&i2400m->wake_tx_ws, i2400m_wake_tx_work);
NeoLKernel/drivers/net/wimax/i2400m/usb-rx.c: * we call i2400mu_rx_kick(); that wakes up the RX kthread, which
NeoLKernel/drivers/net/wimax/i2400m/usb-rx.c:	wake_up_all(&i2400mu->rx_wq);
NeoLKernel/drivers/net/wimax/i2400m/usb-tx.c:	wake_up_all(&i2400mu->tx_wq);
NeoLKernel/drivers/net/wimax/i2400m/usb.c:	iface->needs_remote_wakeup = 1;		/* autosuspend (15s delay) */
NeoLKernel/drivers/net/wimax/i2400m/usb.c:	device_init_wakeup(dev, 1);
NeoLKernel/drivers/net/wireless/adm8211.c:		ieee80211_wake_queue(dev, 0);
NeoLKernel/drivers/net/wireless/adm8211.c:	/* PCNT = 1 (MAC idle time awake/sleep, unit S)
NeoLKernel/drivers/net/wireless/adm8211.c:/* TODO: implement enable_wake */
NeoLKernel/drivers/net/wireless/airo.c:		wake_up_interruptible(&ai->thr_wait);
NeoLKernel/drivers/net/wireless/airo.c:	netif_wake_queue (dev);
NeoLKernel/drivers/net/wireless/airo.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/wireless/airo.c:		wake_up_interruptible(&priv->thr_wait);
NeoLKernel/drivers/net/wireless/airo.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/wireless/airo.c:		wake_up_interruptible(&priv->thr_wait);
NeoLKernel/drivers/net/wireless/airo.c:			wake_up_interruptible(&local->thr_wait);
NeoLKernel/drivers/net/wireless/airo.c:			wake_up_interruptible(&ai->thr_wait);
NeoLKernel/drivers/net/wireless/airo.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/wireless/airo.c:						unsigned long wake_at;
NeoLKernel/drivers/net/wireless/airo.c:							wake_at = max(ai->expires,
NeoLKernel/drivers/net/wireless/airo.c:							wake_at = min(ai->expires,
NeoLKernel/drivers/net/wireless/airo.c:						schedule_timeout(wake_at - jiffies);
NeoLKernel/drivers/net/wireless/airo.c:		wake_up_interruptible(&ai->thr_wait);
NeoLKernel/drivers/net/wireless/airo.c:			wake_up_process(ai->list_bss_task);
NeoLKernel/drivers/net/wireless/airo.c:			wake_up_interruptible(&ai->thr_wait);
NeoLKernel/drivers/net/wireless/airo.c:			wake_up_interruptible(&ai->thr_wait);
NeoLKernel/drivers/net/wireless/airo.c:			netif_wake_queue(ai->dev);
NeoLKernel/drivers/net/wireless/airo.c:				netif_wake_queue(ai->dev);
NeoLKernel/drivers/net/wireless/airo.c:				netif_wake_queue(ai->wifidev);
NeoLKernel/drivers/net/wireless/airo.c:	pci_enable_wake(pdev, pci_choose_state(pdev, state), 1);
NeoLKernel/drivers/net/wireless/airo.c:	pci_enable_wake(pdev, PCI_D0, 0);
NeoLKernel/drivers/net/wireless/airo.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/wireless/airo.c:	int wake = 0;
NeoLKernel/drivers/net/wireless/airo.c:	wake = 1;
NeoLKernel/drivers/net/wireless/airo.c:	if (wake)
NeoLKernel/drivers/net/wireless/airo.c:		wake_up_interruptible(&ai->thr_wait);
NeoLKernel/drivers/net/wireless/airo.c:			wake_up_interruptible(&local->thr_wait);
NeoLKernel/drivers/net/wireless/arlan-main.c:			netif_wake_queue (dev);
NeoLKernel/drivers/net/wireless/arlan-main.c:				netif_wake_queue (dev);
NeoLKernel/drivers/net/wireless/arlan-main.c:		netif_wake_queue (dev);
NeoLKernel/drivers/net/wireless/arlan-main.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/wireless/arlan-main.c:			netif_wake_queue (dev);
NeoLKernel/drivers/net/wireless/arlan-main.c:		netif_wake_queue (dev);
NeoLKernel/drivers/net/wireless/arlan-main.c:					netif_wake_queue (dev);
NeoLKernel/drivers/net/wireless/arlan-main.c:					netif_wake_queue (dev);
NeoLKernel/drivers/net/wireless/at76c50x-usb.c:	ieee80211_wake_queues(priv->hw);
NeoLKernel/drivers/net/wireless/at76c50x-usb.c:	ieee80211_wake_queues(priv->hw);
NeoLKernel/drivers/net/wireless/ath/ar9170/main.c:		printk(KERN_DEBUG "%s: wake queue %d\n",
NeoLKernel/drivers/net/wireless/ath/ar9170/main.c:		ieee80211_wake_queue(ar->hw, i);
NeoLKernel/drivers/net/wireless/ath/ar9170/main.c:		printk(KERN_DEBUG "%s: wake queue %d\n",
NeoLKernel/drivers/net/wireless/ath/ar9170/main.c:		ieee80211_wake_queue(ar->hw, queue);
NeoLKernel/drivers/net/wireless/ath/ar9170/main.c:			printk(KERN_DEBUG "%s: wake queue %d\n",
NeoLKernel/drivers/net/wireless/ath/ar9170/main.c:			ieee80211_wake_queue(ar->hw, i);
NeoLKernel/drivers/net/wireless/ath/ath5k/ath5k.h:extern int ath5k_hw_nic_wakeup(struct ath5k_hw *ah, int flags, bool initial);
NeoLKernel/drivers/net/wireless/ath/ath5k/attach.c:	ret = ath5k_hw_nic_wakeup(ah, 0, true);
NeoLKernel/drivers/net/wireless/ath/ath5k/base.c:static int ath5k_reset_wake(struct ath5k_softc *sc);
NeoLKernel/drivers/net/wireless/ath/ath5k/base.c:	ieee80211_wake_queues(sc->hw); /* XXX move to callers */
NeoLKernel/drivers/net/wireless/ath/ath5k/base.c:		ieee80211_wake_queues(sc->hw);
NeoLKernel/drivers/net/wireless/ath/ath5k/base.c:		 * during wakeup. I tested various cards with srev < 0x78
NeoLKernel/drivers/net/wireless/ath/ath5k/base.c:		 * and they don't wake up after module reload, a second
NeoLKernel/drivers/net/wireless/ath/ath5k/base.c:	ath5k_reset_wake(sc);
NeoLKernel/drivers/net/wireless/ath/ath5k/base.c:		ath5k_reset_wake(sc);
NeoLKernel/drivers/net/wireless/ath/ath5k/base.c:	ieee80211_wake_queues(sc->hw);
NeoLKernel/drivers/net/wireless/ath/ath5k/base.c:ath5k_reset_wake(struct ath5k_softc *sc)
NeoLKernel/drivers/net/wireless/ath/ath5k/base.c:		ieee80211_wake_queues(sc->hw);
NeoLKernel/drivers/net/wireless/ath/ath5k/pcu.c:		/* In STA mode timer1 is used as next wakeup
NeoLKernel/drivers/net/wireless/ath/ath5k/reg.h:#define AR5K_SLEEP_CTL_SLE_WAKE		0x00000000	/* Force chip awake */
NeoLKernel/drivers/net/wireless/ath/ath5k/reset.c:			/* Check if the chip did wake up */
NeoLKernel/drivers/net/wireless/ath/ath5k/reset.c:		/* Fail if the chip didn't wake up */
NeoLKernel/drivers/net/wireless/ath/ath5k/reset.c:	/* Make sure device is awake */
NeoLKernel/drivers/net/wireless/ath/ath5k/reset.c:		ATH5K_ERR(ah->ah_sc, "failed to wakeup the MAC Chip\n");
NeoLKernel/drivers/net/wireless/ath/ath5k/reset.c:	/* ...wakeup again!*/
NeoLKernel/drivers/net/wireless/ath/ath5k/reset.c:int ath5k_hw_nic_wakeup(struct ath5k_hw *ah, int flags, bool initial)
NeoLKernel/drivers/net/wireless/ath/ath5k/reset.c:		ATH5K_ERR(ah->ah_sc, "failed to wakeup the MAC Chip\n");
NeoLKernel/drivers/net/wireless/ath/ath5k/reset.c:	/* ...wakeup again!...*/
NeoLKernel/drivers/net/wireless/ath/ath5k/reset.c:	ret = ath5k_hw_nic_wakeup(ah, channel->hw_value, false);
NeoLKernel/drivers/net/wireless/ath/ath9k/ath9k.h:void ath9k_ps_wakeup(struct ath_softc *sc);
NeoLKernel/drivers/net/wireless/ath/ath9k/beacon.c: * handling, programs the sleep registers so the hardware will wakeup in
NeoLKernel/drivers/net/wireless/ath/ath9k/debug.c:	ath9k_ps_wakeup(sc);
NeoLKernel/drivers/net/wireless/ath/ath9k/hw.c:		DPRINTF(ah->ah_sc, ATH_DBG_FATAL, "Couldn't wakeup chip\n");
NeoLKernel/drivers/net/wireless/ath/ath9k/hw.c:static bool ath9k_hw_set_power_awake(struct ath_hw *ah, int setChip)
NeoLKernel/drivers/net/wireless/ath/ath9k/hw.c:				"Failed to wakeup in %uus\n", POWER_UP_TIME / 20);
NeoLKernel/drivers/net/wireless/ath/ath9k/hw.c:		status = ath9k_hw_set_power_awake(ah, setChip);
NeoLKernel/drivers/net/wireless/ath/ath9k/hw.c:void ath9k_ps_wakeup(struct ath_softc *sc)
NeoLKernel/drivers/net/wireless/ath/ath9k/hw.c:	ath9k_ps_wakeup(ah->ah_sc);
NeoLKernel/drivers/net/wireless/ath/ath9k/main.c:	ath9k_ps_wakeup(sc);
NeoLKernel/drivers/net/wireless/ath/ath9k/main.c:	/* Only calibrate if awake */
NeoLKernel/drivers/net/wireless/ath/ath9k/main.c:	ath9k_ps_wakeup(sc);
NeoLKernel/drivers/net/wireless/ath/ath9k/main.c:	ath9k_ps_wakeup(sc);
NeoLKernel/drivers/net/wireless/ath/ath9k/main.c:		 * TSF sync does not look correct; remain awake to sync with
NeoLKernel/drivers/net/wireless/ath/ath9k/main.c:	ath9k_ps_wakeup(sc);
NeoLKernel/drivers/net/wireless/ath/ath9k/main.c:	ieee80211_wake_queues(sc->hw);
NeoLKernel/drivers/net/wireless/ath/ath9k/main.c:	ath9k_ps_wakeup(sc);
NeoLKernel/drivers/net/wireless/ath/ath9k/main.c:	ath9k_ps_wakeup(sc);
NeoLKernel/drivers/net/wireless/ath/ath9k/main.c:			ieee80211_wake_queues(hw);
NeoLKernel/drivers/net/wireless/ath/ath9k/main.c:	ieee80211_wake_queues(hw);
NeoLKernel/drivers/net/wireless/ath/ath9k/main.c:		 * power save mode. Need to wake up hardware for the TX to be
NeoLKernel/drivers/net/wireless/ath/ath9k/main.c:		ath9k_ps_wakeup(sc);
NeoLKernel/drivers/net/wireless/ath/ath9k/main.c:	/* Ensure HW is awake when we try to shut it down. */
NeoLKernel/drivers/net/wireless/ath/ath9k/main.c:	ath9k_ps_wakeup(sc);
NeoLKernel/drivers/net/wireless/ath/ath9k/main.c:		ath9k_ps_wakeup(sc);
NeoLKernel/drivers/net/wireless/ath/ath9k/main.c:	ath9k_ps_wakeup(sc);
NeoLKernel/drivers/net/wireless/ath/ath9k/main.c:	ath9k_ps_wakeup(sc);
NeoLKernel/drivers/net/wireless/ath/ath9k/main.c:		ath9k_ps_wakeup(sc);
NeoLKernel/drivers/net/wireless/ath/ath9k/main.c:		ath9k_ps_wakeup(sc);
NeoLKernel/drivers/net/wireless/ath/ath9k/main.c:		ath9k_ps_wakeup(sc);
NeoLKernel/drivers/net/wireless/ath/ath9k/recv.c:		 * Remain awake waiting for buffered broadcast/multicast
NeoLKernel/drivers/net/wireless/ath/ath9k/virtual.c:	ieee80211_wake_queues(aphy->hw);
NeoLKernel/drivers/net/wireless/ath/ath9k/xmit.c:static void ath_wake_mac80211_queue(struct ath_softc *sc, struct ath_txq *txq)
NeoLKernel/drivers/net/wireless/ath/ath9k/xmit.c:			ieee80211_wake_queue(sc->hw, qnum);
NeoLKernel/drivers/net/wireless/ath/ath9k/xmit.c:		ath_wake_mac80211_queue(sc, txq);
NeoLKernel/drivers/net/wireless/ath/ath9k/xmit.c:		ath9k_ps_wakeup(sc);
NeoLKernel/drivers/net/wireless/atmel.c:			netif_wake_queue(priv->dev);
NeoLKernel/drivers/net/wireless/atmel.c:static int atmel_wakeup_firmware(struct atmel_private *priv)
NeoLKernel/drivers/net/wireless/atmel.c:	/* wake up on-board processor */
NeoLKernel/drivers/net/wireless/atmel.c:		if (atmel_wakeup_firmware(priv) == 0) {
NeoLKernel/drivers/net/wireless/atmel.c:	/* do everything necessary to wake up the hardware, including
NeoLKernel/drivers/net/wireless/atmel.c:	err = atmel_wakeup_firmware(priv);
NeoLKernel/drivers/net/wireless/b43/b43.h:#define B43_SHM_SH_SPUWKUP		0x0094	/* pre-wakeup for synth PU in us */
NeoLKernel/drivers/net/wireless/b43/b43.h:#define B43_HF_FWKUP		0x000000020000ULL /* Fast wake-up ucode */
NeoLKernel/drivers/net/wireless/b43/b43.h:#define B43_MACCTL_AWAKE		0x04000000	/* Device is awake */
NeoLKernel/drivers/net/wireless/b43/dma.c:		ieee80211_wake_queue(dev->wl->hw, ring->queue_prio);
NeoLKernel/drivers/net/wireless/b43/main.c:	bool awake;
NeoLKernel/drivers/net/wireless/b43/main.c:		awake = 1;
NeoLKernel/drivers/net/wireless/b43/main.c:		awake = 0;
NeoLKernel/drivers/net/wireless/b43/main.c:		//TODO: If the device is awake or this is an AP, or we are scanning, or FIXME,
NeoLKernel/drivers/net/wireless/b43/main.c:/* FIXME: For now we force awake-on and hwps-off */
NeoLKernel/drivers/net/wireless/b43/main.c:	awake = 1;
NeoLKernel/drivers/net/wireless/b43/main.c:	if (awake)
NeoLKernel/drivers/net/wireless/b43/main.c:	if (awake && dev->dev->id.revision >= 5) {
NeoLKernel/drivers/net/wireless/b43/main.c:		/* Wait for the microcode to wake up. */
NeoLKernel/drivers/net/wireless/b43/main.c:	ieee80211_wake_queues(dev->wl->hw);
NeoLKernel/drivers/net/wireless/b43/main.c:	ieee80211_wake_queues(dev->wl->hw);
NeoLKernel/drivers/net/wireless/b43/main.h:#define B43_PS_AWAKE	(1 << 2)	/* Force device awake */
NeoLKernel/drivers/net/wireless/b43/pio.c:		ieee80211_wake_queue(dev->wl->hw, q->queue_prio);
NeoLKernel/drivers/net/wireless/b43legacy/b43legacy.h:#define B43legacy_SHM_SH_SPUWKUP	0x0094 /* pre-wakeup for synth PU in us */
NeoLKernel/drivers/net/wireless/b43legacy/b43legacy.h:#define B43legacy_MACCTL_AWAKE		0x04000000 /* Device is awake */
NeoLKernel/drivers/net/wireless/b43legacy/dma.c:		ieee80211_wake_queue(dev->wl->hw, txring_to_priority(ring));
NeoLKernel/drivers/net/wireless/b43legacy/phy.c:		/* TODO: If the device is awake or this is an AP, or we are
NeoLKernel/drivers/net/wireless/bcm4329/dhd_linux.c:				/* If DTIM skip is set up as default, force it to wake
NeoLKernel/drivers/net/wireless/bcm4329/dhd_linux.c:		netif_wake_queue(net);
NeoLKernel/drivers/net/wireless/bcm4329/dhd_linux.c:	WAKE_LOCK_INIT(&dhd->pub, WAKE_LOCK_TMOUT, "dhd_wake_lock");
NeoLKernel/drivers/net/wireless/bcm4329/dhd_linux.c:	WAKE_LOCK_INIT(&dhd->pub, WAKE_LOCK_LINK_DOWN_TMOUT, "dhd_wake_lock_link_dw_event");
NeoLKernel/drivers/net/wireless/bcm4329/dhd_linux.c:	WAKE_LOCK_INIT(&dhd->pub, WAKE_LOCK_PNO_FIND_TMOUT, "dhd_wake_lock_link_pno_find_event");
NeoLKernel/drivers/net/wireless/bcm4329/dhd_linux.c:dhd_os_ioctl_resp_wake(dhd_pub_t *pub)
NeoLKernel/drivers/net/wireless/bcm4329/dhd_linux.c:		wake_up_interruptible(&dhd->ioctl_resp_wait);
NeoLKernel/drivers/net/wireless/bcm4329/dhd_linux.c:void dhd_wait_event_wakeup(dhd_pub_t *dhd)
NeoLKernel/drivers/net/wireless/bcm4329/dhd_linux.c:		wake_up_interruptible(&dhdinfo->ctrl_wait);
NeoLKernel/drivers/net/wireless/bcm4329/dhd_sdio.c:		/* Tell device to start using OOB wakeup */
NeoLKernel/drivers/net/wireless/bcm4329/dhd_sdio.c:		/* Tell device to start using OOB wakeup */
NeoLKernel/drivers/net/wireless/bcm4329/dhd_sdio.c:	/* Clear rx control and wake any waiters */
NeoLKernel/drivers/net/wireless/bcm4329/dhd_sdio.c:	dhd_os_ioctl_resp_wake(bus->dhd);
NeoLKernel/drivers/net/wireless/bcm4329/dhd_sdio.c:	/* Awake any waiters */
NeoLKernel/drivers/net/wireless/bcm4329/dhd_sdio.c:	dhd_os_ioctl_resp_wake(bus->dhd);
NeoLKernel/drivers/net/wireless/bcm4329/dhd_sdio.c:	/* Would be active due to wake-wlan in gSPI */
NeoLKernel/drivers/net/wireless/bcm4329/dhd_sdio.c:		dhd_wait_event_wakeup(bus->dhd);
NeoLKernel/drivers/net/wireless/bcm4329/include/bcmsdh_sdmmc.h:#define sd_wakeup(sd);
NeoLKernel/drivers/net/wireless/bcm4329/include/bcmsdstd.h:#define sd_wakeup(sd);
NeoLKernel/drivers/net/wireless/bcm4329/include/linuxver.h:#define netif_wake_queue(dev) \
NeoLKernel/drivers/net/wireless/bcm4329/include/spid.h:	uint8	config;			/* 0x00, len, endian, clock, speed, polarity, wakeup */
NeoLKernel/drivers/net/wireless/bcm4329/include/wlioctl.h:	uint8	pci_wakeind;	
NeoLKernel/drivers/net/wireless/bcm4329/include/wlioctl.h:	uint16	ucode_wakeind;	
NeoLKernel/drivers/net/wireless/bcm4329/include/wlioctl.h:} wl_wowl_wakeind_t;
NeoLKernel/drivers/net/wireless/bcm4329/bcmsdh_linux.c:		set_irq_wake(sdhcinfo->oob_irq, 1);
NeoLKernel/drivers/net/wireless/bcm4329/bcmsdh_linux.c:			set_irq_wake(sdhcinfo->oob_irq, 1);
NeoLKernel/drivers/net/wireless/bcm4329/bcmsdh_linux.c:			set_irq_wake(sdhcinfo->oob_irq, 0);
NeoLKernel/drivers/net/wireless/bcm4329/bcmsdh_linux.c:	set_irq_wake(sdhcinfo->oob_irq, 0);
NeoLKernel/drivers/net/wireless/bcm4329/bcmsdspi_linux.c:		/* For local interrupts, wake the waiting process */
NeoLKernel/drivers/net/wireless/bcm4329/bcmsdspi_linux.c:			wake_up_interruptible(&sdos->intr_wait_queue);
NeoLKernel/drivers/net/wireless/bcm4329/bcmsdstd_linux.c:		/* For local interrupts, wake the waiting process */
NeoLKernel/drivers/net/wireless/bcm4329/bcmsdstd_linux.c:			wake_up_interruptible(&sdos->intr_wait_queue);
NeoLKernel/drivers/net/wireless/bcm4329/dhd.h:#include <linux/wakelock.h>
NeoLKernel/drivers/net/wireless/bcm4329/dhd.h:enum dhd_bus_wake_state {
NeoLKernel/drivers/net/wireless/bcm4329/dhd.h:	int dtim_skip;         /* dtim skip , default 0 means wake each dtim */
NeoLKernel/drivers/net/wireless/bcm4329/dhd.h:	struct wake_lock	wakelock[WAKE_LOCK_MAX];
NeoLKernel/drivers/net/wireless/bcm4329/dhd.h:	wake_lock_init(&dhdp->wakelock[index], WAKE_LOCK_SUSPEND, y);
NeoLKernel/drivers/net/wireless/bcm4329/dhd.h:	wake_lock(&dhdp->wakelock[index]);
NeoLKernel/drivers/net/wireless/bcm4329/dhd.h:	wake_unlock(&dhdp->wakelock[index]);
NeoLKernel/drivers/net/wireless/bcm4329/dhd.h:	wake_lock_timeout(&dhdp->wakelock[index], time);
NeoLKernel/drivers/net/wireless/bcm4329/dhd.h:	wake_lock_destroy(&dhdp->wakelock[index]);
NeoLKernel/drivers/net/wireless/bcm4329/dhd.h:extern int dhd_os_ioctl_resp_wake(dhd_pub_t * pub);
NeoLKernel/drivers/net/wireless/bcm4329/dhd.h:extern void dhd_wait_event_wakeup(dhd_pub_t*dhd);
NeoLKernel/drivers/net/wireless/hostap/hostap_80211_tx.c:	 * STA remains awake for the response. */
NeoLKernel/drivers/net/wireless/hostap/hostap_hw.c: * either wake up the sleeping process that is waiting for command completion
NeoLKernel/drivers/net/wireless/hostap/hostap_hw.c:		wake_up_interruptible(&entry->compl);
NeoLKernel/drivers/net/wireless/hostap/hostap_hw.c:	 * below would be handled like CmdCompl event (sleep here, wake up from
NeoLKernel/drivers/net/wireless/hostap/hostap_hw.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/wireless/hostap/hostap_hw.c:				       "wake up queue\n");
NeoLKernel/drivers/net/wireless/hostap/hostap_hw.c:				netif_wake_queue(local->dev);
NeoLKernel/drivers/net/wireless/hostap/hostap_hw.c:		/* ready for next TX, so wake up queue that was stopped in
NeoLKernel/drivers/net/wireless/hostap/hostap_hw.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/wireless/hostap/hostap_hw.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/wireless/hostap/hostap_hw.c:				netif_wake_queue(dev);
NeoLKernel/drivers/net/wireless/hostap/hostap_info.c:	wake_up_interruptible(&local->hostscan_wq);
NeoLKernel/drivers/net/wireless/ipw2x00/ipw2100.c:		wake_up_interruptible(&priv->wait_command_queue);
NeoLKernel/drivers/net/wireless/ipw2x00/ipw2100.c: * TODO: See if it would be more efficient to do a wait/wake
NeoLKernel/drivers/net/wireless/ipw2x00/ipw2100.c: *       cycle and have the completion event trigger the wakeup
NeoLKernel/drivers/net/wireless/ipw2x00/ipw2100.c:                    2. awake clocks & wait for clock stabilization
NeoLKernel/drivers/net/wireless/ipw2x00/ipw2100.c:	wake_up_interruptible(&priv->wait_command_queue);
NeoLKernel/drivers/net/wireless/ipw2x00/ipw2100.c:		/* We have a free slot in the Tx queue, so wake up the
NeoLKernel/drivers/net/wireless/ipw2x00/ipw2100.c:			netif_wake_queue(priv->net_dev);
NeoLKernel/drivers/net/wireless/ipw2x00/ipw2100.c:	/* Set the device back into the PRESENT state; this will also wake
NeoLKernel/drivers/net/wireless/ipw2x00/ipw2100.c:		netif_wake_queue(priv->net_dev);
NeoLKernel/drivers/net/wireless/ipw2x00/ipw2200.c:		wake_up_interruptible(&priv->wait_command_queue);
NeoLKernel/drivers/net/wireless/ipw2x00/ipw2200.c:		wake_up_interruptible(&priv->wait_command_queue);
NeoLKernel/drivers/net/wireless/ipw2x00/ipw2200.c:		wake_up_interruptible(&priv->wait_command_queue);
NeoLKernel/drivers/net/wireless/ipw2x00/ipw2200.c:	wake_up_interruptible(&priv->wait_command_queue);
NeoLKernel/drivers/net/wireless/ipw2x00/ipw2200.c:	wake_up_interruptible(&priv->wait_state);
NeoLKernel/drivers/net/wireless/ipw2x00/ipw2200.c:			wake_up_interruptible(&priv->wait_state);
NeoLKernel/drivers/net/wireless/ipw2x00/ipw2200.c: * forms. If there is enough free space (> low mark), wake Tx queue.
NeoLKernel/drivers/net/wireless/ipw2x00/ipw2200.c:		netif_wake_queue(priv->net_dev);
NeoLKernel/drivers/net/wireless/ipw2x00/ipw2200.c:	/* Set the device back into the PRESENT state; this will also wake
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-commands.h: * ucode assume sleep over DTIM is allowed and we don't need to wake up
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-commands.h:	u8 pm_wakeup_src;
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-commands.h:/* UnMask wake up src at unassociated sleep */
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-commands.h:/* UnMask wake up src at associated sleep */
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-3945.c: * enough free space (> low mark), wake the stack that feeds us.
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-3945.c:		iwl_wake_queue(priv, txq_id);
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-3945.c:	wake_up_interruptible(&priv->wait_command_queue);
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-4965.c:	wake_up_interruptible(&priv->wait_command_queue);
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-4965.c:					iwl_wake_queue(priv, txq_id);
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-4965.c:					iwl_wake_queue(priv, txq->swq_id);
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-4965.c:			iwl_wake_queue(priv, txq_id);
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-5000.c:					iwl_wake_queue(priv, txq_id);
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-5000.c:					iwl_wake_queue(priv, txq->swq_id);
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-5000.c:			iwl_wake_queue(priv, txq_id);
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-agn.c:		wake_up_interruptible(&priv->wait_command_queue);
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-agn.c:	/* uCode wakes up after power-down sleep */
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-agn.c:		priv->isr_stats.wakeup++;
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-agn.c:		wake_up_interruptible(&priv->wait_command_queue);
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-agn.c:	/* uCode wakes up after power-down sleep */
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-agn.c:		priv->isr_stats.wakeup++;
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-agn.c:		wake_up_interruptible(&priv->wait_command_queue);
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-agn.c:	ieee80211_wake_queues(priv->hw);
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-agn.c:	wake_up_interruptible(&priv->wait_command_queue);
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-agn.c:	wake_up_interruptible_all(&priv->wait_command_queue);
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-core.c:	wake_up_interruptible(&priv->wait_command_queue);
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-core.c:		     sleep->pm_sleep_mode, sleep->pm_wakeup_src);
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-debugfs.c:		priv->isr_stats.wakeup);
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-dev.h:	u32 wakeup;
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-helpers.h:static inline void iwl_wake_queue(struct iwl_priv *priv, u8 queue)
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-helpers.h:			ieee80211_wake_queue(priv->hw, ac);
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-helpers.h:#define ieee80211_wake_queue DO_NOT_USE_ieee80211_wake_queue
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-io.h:	/* this bit wakes up the NIC */
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-power.c:				     int dynps_ms, int wakeup_period)
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-power.c:	 * also adjust the succession here to the wakeup_period below.
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-power.c:	 * the sleep index but here we use the wakeup period since that
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-power.c:	if (wakeup_period > IWL_DTIM_RANGE_0_MAX)
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-power.c:	if (wakeup_period > IWL_DTIM_RANGE_1_MAX)
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-power.c:			cpu_to_le32(min_t(int, slp_succ[i], wakeup_period));
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-power.c: * toggle the bit to wake up uCode and check the temperature
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-power.c: * if the temperature is below CT, uCode will stay awake and send card
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-power.c: * to wake up uCode for temperature check until temperature drop below CT
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-power.c:			ieee80211_wake_queues(priv->hw);
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-power.c:			"- ucode awake!\n");
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-rx.c:	/* If power-saving is in use, make sure device is awake */
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-rx.c:	/* Else device is assumed to be awake */
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-sta.c:static void iwl_sta_modify_ps_wake(struct iwl_priv *priv, int sta_id)
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-sta.c:		u8 sta_awake = priv->stations[sta_id].
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-sta.c:		if (sta_awake && ps_bit)
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-sta.c:		else if (!sta_awake && !ps_bit) {
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-sta.c:			iwl_sta_modify_ps_wake(priv, sta_id);
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-tx.c:		/* wake up nic if it's powered down ...
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-tx.c:		 * uCode will wake up, and interrupt us again, so next
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-tx.c:			IWL_DEBUG_INFO(priv, "Requesting wakeup, GP1 = 0x%x\n", reg);
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-tx.c: * enough free space (> low mark), wake the stack that feeds us.
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-tx.c:		wake_up_interruptible(&priv->wait_command_queue);
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-tx.c:		/* calculate mac80211 ampdu sw queue to wake */
NeoLKernel/drivers/net/wireless/iwlwifi/iwl-tx.c:			iwl_wake_queue(priv, txq->swq_id);
NeoLKernel/drivers/net/wireless/iwlwifi/iwl3945-base.c:		wake_up_interruptible(&priv->wait_command_queue);
NeoLKernel/drivers/net/wireless/iwlwifi/iwl3945-base.c:	/* uCode wakes up after power-down sleep */
NeoLKernel/drivers/net/wireless/iwlwifi/iwl3945-base.c:		priv->isr_stats.wakeup++;
NeoLKernel/drivers/net/wireless/iwlwifi/iwl3945-base.c:	ieee80211_wake_queues(priv->hw);
NeoLKernel/drivers/net/wireless/iwlwifi/iwl3945-base.c:	wake_up_interruptible(&priv->wait_command_queue);
NeoLKernel/drivers/net/wireless/iwlwifi/iwl3945-base.c:	wake_up_interruptible_all(&priv->wait_command_queue);
NeoLKernel/drivers/net/wireless/iwmc3200wifi/main.c:	wake_up_interruptible(&iwm->mlme_queue);
NeoLKernel/drivers/net/wireless/iwmc3200wifi/main.c: * and then wakes the waiting processes up.
NeoLKernel/drivers/net/wireless/iwmc3200wifi/main.c:	wake_up_interruptible(&iwm->notif_queue);
NeoLKernel/drivers/net/wireless/iwmc3200wifi/main.c:	netif_tx_wake_all_queues(iwm_to_ndev(iwm));
NeoLKernel/drivers/net/wireless/iwmc3200wifi/rx.c: * iwm_rx_handle_wifi() just wakes those processes up and they
NeoLKernel/drivers/net/wireless/iwmc3200wifi/rx.c:	wake_up_interruptible(&iwm->mlme_queue);
NeoLKernel/drivers/net/wireless/iwmc3200wifi/rx.c:	wake_up_interruptible(&iwm->mlme_queue);
NeoLKernel/drivers/net/wireless/iwmc3200wifi/rx.c:		wake_up_interruptible(&iwm->wifi_ntfy_queue);
NeoLKernel/drivers/net/wireless/iwmc3200wifi/rx.c:	 * replace the command payload with the buffer, and then wake the
NeoLKernel/drivers/net/wireless/iwmc3200wifi/rx.c:			wake_up_interruptible(&iwm->nonwifi_queue);
NeoLKernel/drivers/net/wireless/iwmc3200wifi/tx.c:		netif_wake_subqueue(iwm_to_ndev(iwm), txq->id);
NeoLKernel/drivers/net/wireless/libertas/assoc.c:		netif_wake_queue(priv->dev);
NeoLKernel/drivers/net/wireless/libertas/assoc.c:		netif_wake_queue(priv->dev);
NeoLKernel/drivers/net/wireless/libertas/assoc.c:		/* wake up first */
NeoLKernel/drivers/net/wireless/libertas/assoc.c:			lbs_ps_wakeup(priv, CMD_OPTION_WAITFORRSP);
NeoLKernel/drivers/net/wireless/libertas/cmd.c:	wake_up_interruptible(&cmd->cmdwait_q);
NeoLKernel/drivers/net/wireless/libertas/cmd.c:		wake_up_interruptible(&priv->waitq);
NeoLKernel/drivers/net/wireless/libertas/cmd.c:	wake_up_interruptible(&priv->waitq);
NeoLKernel/drivers/net/wireless/libertas/cmd.c:			 * Queue it. set needtowakeup to TRUE if current state
NeoLKernel/drivers/net/wireless/libertas/cmd.c:			 * is SLEEP, otherwise call lbs_ps_wakeup to send Exit_PS.
NeoLKernel/drivers/net/wireless/libertas/cmd.c:			 * Set needtowakeup to TRUE if current state is SLEEP,
NeoLKernel/drivers/net/wireless/libertas/cmd.c:					priv->needtowakeup = 1;
NeoLKernel/drivers/net/wireless/libertas/cmd.c:					lbs_ps_wakeup(priv, 0);
NeoLKernel/drivers/net/wireless/libertas/cmd.c:					priv->needtowakeup = 1;
NeoLKernel/drivers/net/wireless/libertas/cmd.c:void lbs_ps_wakeup(struct lbs_private *priv, int wait_option)
NeoLKernel/drivers/net/wireless/libertas/cmd.c:		wake_up_interruptible(&priv->waitq);
NeoLKernel/drivers/net/wireless/libertas/cmd.c:	wake_up_interruptible(&priv->waitq);
NeoLKernel/drivers/net/wireless/libertas/cmdresp.c:		lbs_ps_wakeup(priv, 0);
NeoLKernel/drivers/net/wireless/libertas/cmdresp.c:			priv->needtowakeup = 0;
NeoLKernel/drivers/net/wireless/libertas/cmdresp.c:				 * response, We need to wake up the firmware.
NeoLKernel/drivers/net/wireless/libertas/cmdresp.c:				       "disconnected, invoking lbs_ps_wakeup\n");
NeoLKernel/drivers/net/wireless/libertas/cmdresp.c:				lbs_ps_wakeup(priv, 0);
NeoLKernel/drivers/net/wireless/libertas/cmdresp.c:			priv->needtowakeup = 0;
NeoLKernel/drivers/net/wireless/libertas/cmdresp.c:static int lbs_send_confirmwake(struct lbs_private *priv)
NeoLKernel/drivers/net/wireless/libertas/cmdresp.c:	lbs_deb_hex(LBS_DEB_HOST, "wake confirm", (u8 *) &cmd,
NeoLKernel/drivers/net/wireless/libertas/cmdresp.c:		lbs_deb_cmd("EVENT: host awake\n");
NeoLKernel/drivers/net/wireless/libertas/cmdresp.c:		lbs_send_confirmwake(priv);
NeoLKernel/drivers/net/wireless/libertas/cmdresp.c:		lbs_deb_cmd("EVENT: ps awake\n");
NeoLKernel/drivers/net/wireless/libertas/cmdresp.c:		if (priv->needtowakeup) {
NeoLKernel/drivers/net/wireless/libertas/cmdresp.c:			 * priv->needtowakeup will be set to FALSE
NeoLKernel/drivers/net/wireless/libertas/cmdresp.c:			 * in lbs_ps_wakeup()
NeoLKernel/drivers/net/wireless/libertas/cmdresp.c:			lbs_ps_wakeup(priv, 0);
NeoLKernel/drivers/net/wireless/libertas/cmdresp.c:				netif_wake_queue(priv->mesh_dev);
NeoLKernel/drivers/net/wireless/libertas/decl.h:void lbs_ps_wakeup(struct lbs_private *priv, int wait_option);
NeoLKernel/drivers/net/wireless/libertas/dev.h:	u8 needtowakeup;
NeoLKernel/drivers/net/wireless/libertas/ethtool.c:		/* Interface driver didn't configure wake */
NeoLKernel/drivers/net/wireless/libertas/hostcmd.h:struct cmd_ds_802_11_fw_wake_method {
NeoLKernel/drivers/net/wireless/libertas/if_spi.c:	/* Used to wake up the spi_thread */
NeoLKernel/drivers/net/wireless/libertas/if_spi.c:	 * can't wake threads waiting for a semaphore. */
NeoLKernel/drivers/net/wireless/libertas/if_spi.c: * don't try to talk on the SPI bus, just wake up the SPI thread.
NeoLKernel/drivers/net/wireless/libertas/if_usb.c:	struct cmd_ds_802_11_fw_wake_method wake_method;
NeoLKernel/drivers/net/wireless/libertas/if_usb.c:	wake_method.hdr.size = cpu_to_le16(sizeof(wake_method));
NeoLKernel/drivers/net/wireless/libertas/if_usb.c:	wake_method.action = cpu_to_le16(CMD_ACT_GET);
NeoLKernel/drivers/net/wireless/libertas/if_usb.c:	if (lbs_cmd_with_response(priv, CMD_802_11_FW_WAKE_METHOD, &wake_method)) {
NeoLKernel/drivers/net/wireless/libertas/if_usb.c:		if (le16_to_cpu(wake_method.method) == CMD_WAKE_METHOD_COMMAND_INT) {
NeoLKernel/drivers/net/wireless/libertas/if_usb.c:			lbs_deb_usb("Firmware seems to support PS with wake-via-command\n");
NeoLKernel/drivers/net/wireless/libertas/if_usb.c:			lbs_pr_info("Firmware doesn't wake via command interrupt; disabling PS mode\n");
NeoLKernel/drivers/net/wireless/libertas/if_usb.c:	wake_up(&cardp->fw_wq);
NeoLKernel/drivers/net/wireless/libertas/if_usb.c:			wake_up(&cardp->fw_wq);
NeoLKernel/drivers/net/wireless/libertas/if_usb.c: *  wake up the main thread and initialise the Rx callack.
NeoLKernel/drivers/net/wireless/libertas/if_usb.c:	wake_up_interruptible(&priv->waitq);
NeoLKernel/drivers/net/wireless/libertas/main.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/wireless/libertas/main.c:		wake_up_interruptible(&priv->waitq);
NeoLKernel/drivers/net/wireless/libertas/main.c:			shouldsleep = 1;	/* Sleep mode. Nothing we can do till it wakes */
NeoLKernel/drivers/net/wireless/libertas/main.c:			wake_up_all(&priv->cmd_pending);
NeoLKernel/drivers/net/wireless/libertas/main.c:				/* We can wake the queues immediately if we aren't
NeoLKernel/drivers/net/wireless/libertas/main.c:					netif_wake_queue(priv->dev);
NeoLKernel/drivers/net/wireless/libertas/main.c:					netif_wake_queue(priv->mesh_dev);
NeoLKernel/drivers/net/wireless/libertas/main.c:	wake_up_all(&priv->cmd_pending);
NeoLKernel/drivers/net/wireless/libertas/main.c:		lbs_pr_info("Suspend attempt without configuring wake params!\n");
NeoLKernel/drivers/net/wireless/libertas/main.c:	wake_up_interruptible(&priv->waitq);
NeoLKernel/drivers/net/wireless/libertas/main.c:		lbs_ps_wakeup(priv, CMD_OPTION_WAITFORRSP);
NeoLKernel/drivers/net/wireless/libertas/main.c:		wake_up_interruptible(&cmdnode->cmdwait_q);
NeoLKernel/drivers/net/wireless/libertas/main.c:		wake_up_interruptible(&priv->cur_cmd->cmdwait_q);
NeoLKernel/drivers/net/wireless/libertas/main.c:	wake_up_interruptible(&priv->waitq);
NeoLKernel/drivers/net/wireless/libertas/main.c:	wake_up_interruptible(&priv->waitq);
NeoLKernel/drivers/net/wireless/libertas/scan.c:		netif_wake_queue(priv->dev);
NeoLKernel/drivers/net/wireless/libertas/scan.c:		netif_wake_queue(priv->mesh_dev);
NeoLKernel/drivers/net/wireless/libertas/tx.c:	wake_up(&priv->waitq);
NeoLKernel/drivers/net/wireless/libertas/tx.c:		netif_wake_queue(priv->dev);
NeoLKernel/drivers/net/wireless/libertas/tx.c:		netif_wake_queue(priv->mesh_dev);
NeoLKernel/drivers/net/wireless/libertas/wext.c:			lbs_ps_wakeup(priv, CMD_OPTION_WAITFORRSP);
NeoLKernel/drivers/net/wireless/libertas_tf/cmd.c:	wake_up_interruptible(&cmd->cmdwait_q);
NeoLKernel/drivers/net/wireless/libertas_tf/if_usb.c:	wake_up(&cardp->fw_wq);
NeoLKernel/drivers/net/wireless/libertas_tf/if_usb.c:			wake_up(&cardp->fw_wq);
NeoLKernel/drivers/net/wireless/libertas_tf/main.c:		wake_up_interruptible(&cmdnode->cmdwait_q);
NeoLKernel/drivers/net/wireless/libertas_tf/main.c:		ieee80211_wake_queues(priv->hw);
NeoLKernel/drivers/net/wireless/mwl8k.c:	int wake = 0;
NeoLKernel/drivers/net/wireless/mwl8k.c:		wake = 1;
NeoLKernel/drivers/net/wireless/mwl8k.c:	if (wake && priv->radio_on && !mutex_is_locked(&priv->fw_mutex))
NeoLKernel/drivers/net/wireless/mwl8k.c:		ieee80211_wake_queue(hw, index);
NeoLKernel/drivers/net/wireless/mwl8k.c:			ieee80211_wake_queues(hw);
NeoLKernel/drivers/net/wireless/mwl8k.c:		ieee80211_wake_queues(hw);
NeoLKernel/drivers/net/wireless/netwave_cs.c:	    netif_wake_queue(dev);
NeoLKernel/drivers/net/wireless/netwave_cs.c:    netif_wake_queue(dev);
NeoLKernel/drivers/net/wireless/orinoco/main.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/wireless/orinoco/main.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/wireless/p54/fwio.c:		setup->v1.wakeup_timer = cpu_to_le16(priv->wakeup_timer);
NeoLKernel/drivers/net/wireless/p54/fwio.c:		setup->v2.timer = cpu_to_le16(priv->wakeup_timer);
NeoLKernel/drivers/net/wireless/p54/lmac.h:			__le16 wakeup_timer;
NeoLKernel/drivers/net/wireless/p54/main.c:			priv->wakeup_timer = info->beacon_int *
NeoLKernel/drivers/net/wireless/p54/main.c:			priv->wakeup_timer = 500;
NeoLKernel/drivers/net/wireless/p54/p54.h:	u16 wakeup_timer;
NeoLKernel/drivers/net/wireless/p54/p54pci.c:		ieee80211_wake_queues(dev);
NeoLKernel/drivers/net/wireless/p54/p54spi.c:static int p54spi_wakeup(struct p54s_priv *priv)
NeoLKernel/drivers/net/wireless/p54/p54spi.c:	/* wake the chip */
NeoLKernel/drivers/net/wireless/p54/p54spi.c:	if (p54spi_wakeup(priv) < 0)
NeoLKernel/drivers/net/wireless/p54/p54spi.c:	if (p54spi_wakeup(priv) < 0)
NeoLKernel/drivers/net/wireless/p54/txrx.c:static void p54_wake_queues(struct p54_common *priv)
NeoLKernel/drivers/net/wireless/p54/txrx.c:			ieee80211_wake_queue(priv->hw, i);
NeoLKernel/drivers/net/wireless/p54/txrx.c:	p54_wake_queues(priv);
NeoLKernel/drivers/net/wireless/prism54/islpci_dev.c:					netif_wake_queue(priv->ndev);
NeoLKernel/drivers/net/wireless/prism54/islpci_dev.c:			wake_up(&priv->reset_done);
NeoLKernel/drivers/net/wireless/prism54/islpci_dev.c:			isl38xx_handle_wakeup(priv->control_block,
NeoLKernel/drivers/net/wireless/prism54/islpci_dev.c:	INIT_WORK(&priv->reset_task, islpci_do_reset_and_wake);
NeoLKernel/drivers/net/wireless/prism54/islpci_eth.c:		printk(KERN_ERR "%s: transmit device queue full when awake\n",
NeoLKernel/drivers/net/wireless/prism54/islpci_eth.c:islpci_do_reset_and_wake(struct work_struct *work)
NeoLKernel/drivers/net/wireless/prism54/islpci_eth.c:	netif_wake_queue(priv->ndev);
NeoLKernel/drivers/net/wireless/prism54/islpci_eth.h:void islpci_do_reset_and_wake(struct work_struct *);
NeoLKernel/drivers/net/wireless/prism54/islpci_mgt.c:			wake_up(&priv->mgmt_wqueue);
NeoLKernel/drivers/net/wireless/prism54/isl_38xx.c:isl38xx_handle_wakeup(isl38xx_control_block *control_block,
NeoLKernel/drivers/net/wireless/prism54/isl_38xx.c:		/* device is in powersave, trigger the device for wakeup */
NeoLKernel/drivers/net/wireless/prism54/isl_38xx.c:		DEBUG(SHOW_TRACING, "%08li.%08li Device wakeup triggered\n",
NeoLKernel/drivers/net/wireless/prism54/isl_38xx.c:		/* device is (still) awake  */
NeoLKernel/drivers/net/wireless/prism54/isl_38xx.h:void isl38xx_handle_wakeup(isl38xx_control_block *, int *, void __iomem *);
NeoLKernel/drivers/net/wireless/ray_cs.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/wireless/rt2x00/rt2400pci.c:		/* We must first disable autowake before it can be enabled */
NeoLKernel/drivers/net/wireless/rt2x00/rt2400pci.h: * TBCN_BEFORE_WAKEUP: Number of beacon before wakeup.
NeoLKernel/drivers/net/wireless/rt2x00/rt2400pci.h: * AUTOWAKE: Enable auto wakeup / sleep mechanism.
NeoLKernel/drivers/net/wireless/rt2x00/rt2400pci.h: * Allowed state: 0 deep_sleep, 1: sleep, 2: standby, 3: awake.
NeoLKernel/drivers/net/wireless/rt2x00/rt2500pci.c:		/* We must first disable autowake before it can be enabled */
NeoLKernel/drivers/net/wireless/rt2x00/rt2500pci.h: * TBCN_BEFORE_WAKEUP: Number of beacon before wakeup.
NeoLKernel/drivers/net/wireless/rt2x00/rt2500pci.h: * AUTOWAKE: Enable auto wakeup / sleep mechanism.
NeoLKernel/drivers/net/wireless/rt2x00/rt2500pci.h: * Allowed state: 0 deep_sleep, 1: sleep, 2: standby, 3: awake.
NeoLKernel/drivers/net/wireless/rt2x00/rt2500usb.c:		/* We must first disable autowake before it can be enabled */
NeoLKernel/drivers/net/wireless/rt2x00/rt2500usb.h: * Allowed state: 0 deep_sleep, 1: sleep, 2: standby, 3: awake.
NeoLKernel/drivers/net/wireless/rt2x00/rt2500usb.h: * BEACONS_BEFORE_WAKEUP: Number of beacon before wakeup.
NeoLKernel/drivers/net/wireless/rt2x00/rt2500usb.h: * AUTO_WAKE: Enable auto wakeup / sleep mechanism.
NeoLKernel/drivers/net/wireless/rt2x00/rt2800usb.c:		 * to be fully awake and then the radio can be enabled.
NeoLKernel/drivers/net/wireless/rt2x00/rt2800usb.h: * AUTOWAKE: 0:sleep, 1:awake
NeoLKernel/drivers/net/wireless/rt2x00/rt2x00debug.c:	wake_up_interruptible(&intf->frame_dump_waitqueue);
NeoLKernel/drivers/net/wireless/rt2x00/rt2x00dev.c:	ieee80211_wake_queues(rt2x00dev->hw);
NeoLKernel/drivers/net/wireless/rt2x00/rt2x00dev.c:		ieee80211_wake_queue(rt2x00dev->hw, qid);
NeoLKernel/drivers/net/wireless/rt2x00/rt61pci.c:		/* We must first disable autowake before it can be enabled */
NeoLKernel/drivers/net/wireless/rt2x00/rt61pci.h: * TBCN_BEFORE_WAKEUP: Number of beacon before wakeup.
NeoLKernel/drivers/net/wireless/rt2x00/rt61pci.h: * CURRENT_STATE: 0:sleep, 1:awake.
NeoLKernel/drivers/net/wireless/rt2x00/rt61pci.h: * BBP_CURRENT_STATE: 0: BBP sleep, 1: BBP awake.
NeoLKernel/drivers/net/wireless/rt2x00/rt73usb.c:		/* We must first disable autowake before it can be enabled */
NeoLKernel/drivers/net/wireless/rt2x00/rt73usb.h: * TBCN_BEFORE_WAKEUP: Number of beacon before wakeup.
NeoLKernel/drivers/net/wireless/rt2x00/rt73usb.h: * CURRENT_STATE: 0:sleep, 1:awake.
NeoLKernel/drivers/net/wireless/rt2x00/rt73usb.h: * BBP_CURRENT_STATE: 0: BBP sleep, 1: BBP awake.
NeoLKernel/drivers/net/wireless/rtl818x/rtl8180_dev.c:			ieee80211_wake_queue(dev, prio);
NeoLKernel/drivers/net/wireless/strip.c:	struct timer_list idle_timer;	/* For periodic wakeup calls    */
NeoLKernel/drivers/net/wireless/strip.c:	netif_wake_queue(strip_info->dev);
NeoLKernel/drivers/net/wireless/strip.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/wireless/strip.c:	.write_wakeup = strip_write_some_more,
NeoLKernel/drivers/net/wireless/wavelan.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/wireless/wavelan.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/wireless/wavelan.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/wireless/wavelan_cs.c:	  netif_wake_queue(dev);
NeoLKernel/drivers/net/wireless/wavelan_cs.c:  netif_wake_queue(dev);
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_spi.c:static void wl1251_spi_wake(struct wl1251 *wl)
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_spi.c:static void wl1251_spi_reset_wake(struct wl1251 *wl)
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_spi.c:	wl1251_spi_wake(wl);
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_spi.c:	.reset = wl1251_spi_reset_wake,
NeoLKernel/drivers/net/wireless/wl12xx/wl1251.h:	struct dentry *isr_wakeups;
NeoLKernel/drivers/net/wireless/wl12xx/wl1251.h:	struct dentry *pwr_wake_on_host;
NeoLKernel/drivers/net/wireless/wl12xx/wl1251.h:	struct dentry *pwr_wake_on_timer_exp;
NeoLKernel/drivers/net/wireless/wl12xx/wl1251.h:	struct dentry *pwr_rcvd_awake_beacons;
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_acx.c:int wl1251_acx_wake_up_conditions(struct wl1251 *wl, u8 wake_up_event,
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_acx.c:	struct acx_wake_up_condition *wake_up;
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_acx.c:	wl1251_debug(DEBUG_ACX, "acx wake up conditions");
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_acx.c:	wake_up = kzalloc(sizeof(*wake_up), GFP_KERNEL);
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_acx.c:	if (!wake_up) {
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_acx.c:	wake_up->wake_up_event = wake_up_event;
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_acx.c:	wake_up->listen_interval = listen_interval;
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_acx.c:				   wake_up, sizeof(*wake_up));
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_acx.c:		wl1251_warning("could not set wake up conditions: %d", ret);
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_acx.c:	kfree(wake_up);
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_acx.c:	param->wake_up_beacon = PTA_TIME_BEFORE_BEACON_DEF;
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_acx.h:	u16 wake_up_beacon;
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_acx.h:enum acx_wake_up_event {
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_acx.h:struct acx_wake_up_condition {
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_acx.h:	u8 wake_up_event; /* Only one bit can be set */
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_acx.h:	u32 wakeups;
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_acx.h:	/* the amount of wake on host-access times */
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_acx.h:	u32 wake_on_host;
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_acx.h:	/* the amount of wake on timer-expire */
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_acx.h:	u32 wake_on_timer_exp;
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_acx.h:	/* the number of beacons in awake mode */
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_acx.h:	u32 rcvd_awake_beacons;
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_acx.h:int wl1251_acx_wake_up_conditions(struct wl1251 *wl, u8 wake_up_event,
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_boot.c:	/* enable restart wakeup sequence (ELP_CMD[0]) */
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_cmd.h:#define JOIN_CMD_CTRL_EARLY_WAKEUP_ENABLE  0x01 /* Early wakeup time */
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_cmd.h:	  * TUs during which the target stays awake after switching
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_debugfs.c:	ret = wl1251_ps_elp_wakeup(wl);
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_debugfs.c:DEBUGFS_FWSTATS_FILE(isr, wakeups, 20, "%u");
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_debugfs.c:DEBUGFS_FWSTATS_FILE(pwr, wake_on_host, 20, "%u");
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_debugfs.c:DEBUGFS_FWSTATS_FILE(pwr, wake_on_timer_exp, 20, "%u");
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_debugfs.c:DEBUGFS_FWSTATS_FILE(pwr, rcvd_awake_beacons, 20, "%u");
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_debugfs.c:	DEBUGFS_FWSTATS_DEL(isr, wakeups);
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_debugfs.c:	DEBUGFS_FWSTATS_DEL(pwr, wake_on_host);
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_debugfs.c:	DEBUGFS_FWSTATS_DEL(pwr, wake_on_timer_exp);
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_debugfs.c:	DEBUGFS_FWSTATS_DEL(pwr, rcvd_awake_beacons);
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_debugfs.c:	DEBUGFS_FWSTATS_ADD(isr, wakeups);
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_debugfs.c:	DEBUGFS_FWSTATS_ADD(pwr, wake_on_host);
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_debugfs.c:	DEBUGFS_FWSTATS_ADD(pwr, wake_on_timer_exp);
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_debugfs.c:	DEBUGFS_FWSTATS_ADD(pwr, rcvd_awake_beacons);
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_main.c:static void wl1251_fw_wakeup(struct wl1251 *wl)
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_main.c:static int wl1251_chip_wakeup(struct wl1251 *wl)
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_main.c:	/* ELP module wake up */
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_main.c:	wl1251_fw_wakeup(wl);
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_main.c:	ret = wl1251_ps_elp_wakeup(wl);
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_main.c:	ret = wl1251_ps_elp_wakeup(wl);
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_main.c:	ret = wl1251_chip_wakeup(wl);
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_main.c:	ret = wl1251_ps_elp_wakeup(wl);
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_main.c:	ret = wl1251_ps_elp_wakeup(wl);
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_main.c:	ret = wl1251_ps_elp_wakeup(wl);
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_main.c:	ret = wl1251_ps_elp_wakeup(wl);
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_main.c:	ret = wl1251_ps_elp_wakeup(wl);
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_ps.c:int wl1251_ps_elp_wakeup(struct wl1251 *wl)
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_ps.c:			wl1251_error("elp wakeup timeout");
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_ps.c:	wl1251_debug(DEBUG_PSM, "wakeup time: %u ms",
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_ps.c:		 * we have to wake the target up before
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_ps.c:		wl1251_ps_elp_wakeup(wl);
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_ps.c:		ret = wl1251_acx_wake_up_conditions(wl,
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_ps.c:		ret = wl1251_acx_wake_up_conditions(wl,
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_ps.h:int wl1251_ps_elp_wakeup(struct wl1251 *wl);
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_tx.c:			ret = wl1251_ps_elp_wakeup(wl);
NeoLKernel/drivers/net/wireless/wl12xx/wl1251_tx.c:		ieee80211_wake_queues(wl->hw);
NeoLKernel/drivers/net/wireless/wl12xx/wl1271.h:	struct dentry *isr_wakeups;
NeoLKernel/drivers/net/wireless/wl12xx/wl1271.h:	struct dentry *pwr_wake_on_host;
NeoLKernel/drivers/net/wireless/wl12xx/wl1271.h:	struct dentry *pwr_wake_on_timer_exp;
NeoLKernel/drivers/net/wireless/wl12xx/wl1271.h:	struct dentry *pwr_rcvd_awake_beacons;
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_acx.c:int wl1271_acx_wake_up_conditions(struct wl1271 *wl, u8 wake_up_event,
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_acx.c:	struct acx_wake_up_condition *wake_up;
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_acx.c:	wl1271_debug(DEBUG_ACX, "acx wake up conditions");
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_acx.c:	wake_up = kzalloc(sizeof(*wake_up), GFP_KERNEL);
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_acx.c:	if (!wake_up) {
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_acx.c:	wake_up->wake_up_event = wake_up_event;
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_acx.c:	wake_up->listen_interval = listen_interval;
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_acx.c:				   wake_up, sizeof(*wake_up));
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_acx.c:		wl1271_warning("could not set wake up conditions: %d", ret);
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_acx.c:	kfree(wake_up);
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_acx.c:	param->wake_up_beacon = PTA_TIME_BEFORE_BEACON_DEF;
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_acx.h:/* Signaling the host on HW wakeup */
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_acx.h:	u16 wake_up_beacon;
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_acx.h:enum acx_wake_up_event {
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_acx.h:struct acx_wake_up_condition {
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_acx.h:	u8 wake_up_event; /* Only one bit can be set */
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_acx.h:	u32 wakeups;
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_acx.h:	/* the amount of wake on host-access times */
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_acx.h:	u32 wake_on_host;
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_acx.h:	/* the amount of wake on timer-expire */
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_acx.h:	u32 wake_on_timer_exp;
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_acx.h:	/* the number of beacons in awake mode */
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_acx.h:	u32 rcvd_awake_beacons;
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_acx.h:int wl1271_acx_wake_up_conditions(struct wl1271 *wl, u8 wake_up_event,
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_boot.c:	/* Continue the ELP wake up sequence */
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_cmd.c:	ret = wl1271_acx_wake_up_conditions(wl, WAKE_UP_EVENT_DTIM_BITMAP,
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_cmd.c:		wl1271_error("couldn't set wake up conditions");
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_cmd.h:	  * TUs during which the target stays awake after switching
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_debugfs.c:	ret = wl1271_ps_elp_wakeup(wl, false);
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_debugfs.c:DEBUGFS_FWSTATS_FILE(isr, wakeups, 20, "%u");
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_debugfs.c:DEBUGFS_FWSTATS_FILE(pwr, wake_on_host, 20, "%u");
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_debugfs.c:DEBUGFS_FWSTATS_FILE(pwr, wake_on_timer_exp, 20, "%u");
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_debugfs.c:DEBUGFS_FWSTATS_FILE(pwr, rcvd_awake_beacons, 20, "%u");
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_debugfs.c:	DEBUGFS_FWSTATS_DEL(isr, wakeups);
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_debugfs.c:	DEBUGFS_FWSTATS_DEL(pwr, wake_on_host);
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_debugfs.c:	DEBUGFS_FWSTATS_DEL(pwr, wake_on_timer_exp);
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_debugfs.c:	DEBUGFS_FWSTATS_DEL(pwr, rcvd_awake_beacons);
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_debugfs.c:	DEBUGFS_FWSTATS_ADD(isr, wakeups);
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_debugfs.c:	DEBUGFS_FWSTATS_ADD(pwr, wake_on_host);
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_debugfs.c:	DEBUGFS_FWSTATS_ADD(pwr, wake_on_timer_exp);
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_debugfs.c:	DEBUGFS_FWSTATS_ADD(pwr, rcvd_awake_beacons);
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_init.c:	gen_parms->clk_valid_on_wakeup = 0;
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_init.h:	u8 clk_valid_on_wakeup;
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_main.c:	ret = wl1271_ps_elp_wakeup(wl, true);
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_main.c:static void wl1271_fw_wakeup(struct wl1271 *wl)
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_main.c:static int wl1271_chip_wakeup(struct wl1271 *wl)
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_main.c:	/* ELP module wake up */
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_main.c:	wl1271_fw_wakeup(wl);
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_main.c:	ret = wl1271_ps_elp_wakeup(wl, false);
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_main.c:	ret = wl1271_chip_wakeup(wl);
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_main.c:	ret = wl1271_chip_wakeup(wl);
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_main.c:	ret = wl1271_ps_elp_wakeup(wl, false);
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_main.c:	ret = wl1271_ps_elp_wakeup(wl, false);
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_main.c:	ret = wl1271_ps_elp_wakeup(wl, false);
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_main.c:	ret = wl1271_ps_elp_wakeup(wl, false);
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_main.c:	ret = wl1271_ps_elp_wakeup(wl, false);
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_main.c:	ret = wl1271_ps_elp_wakeup(wl, false);
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_ps.c:	 * will immediately wakeup the chipset anyway.
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_ps.c:int wl1271_ps_elp_wakeup(struct wl1271 *wl, bool chip_awake)
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_ps.c:	if (work_pending(&wl->irq_work) || chip_awake)
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_ps.c:			wl1271_error("ELP wakeup timeout!");
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_ps.c:			wl1271_error("ELP wakeup completion error.");
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_ps.c:	wl1271_debug(DEBUG_PSM, "wakeup time: %u ms",
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_ps.c:		ret = wl1271_ps_elp_wakeup(wl, false);
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_ps.h:int wl1271_ps_elp_wakeup(struct wl1271 *wl, bool chip_awake);
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_tx.c:			ret = wl1271_ps_elp_wakeup(wl, false);
NeoLKernel/drivers/net/wireless/wl12xx/wl1271_tx.c:			ieee80211_wake_queues(wl->hw);
NeoLKernel/drivers/net/wireless/wl3501.h:	u8	wake_up;
NeoLKernel/drivers/net/wireless/wl3501_cs.c:		.wake_up	= !suspend,
NeoLKernel/drivers/net/wireless/wl3501_cs.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/wireless/wl3501_cs.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/wireless/wl3501_cs.c:	wake_up(&this->wait);
NeoLKernel/drivers/net/wireless/wl3501_cs.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/wireless/wl3501_cs.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/wireless/zd1201.c:	netif_wake_queue(zd->dev);
NeoLKernel/drivers/net/wireless/zd1201.c:		wake_up(&zd->rxdataq);
NeoLKernel/drivers/net/wireless/zd1201.c:			wake_up(&zd->rxdataq);
NeoLKernel/drivers/net/wireless/zd1201.c:		wake_up(&zd->rxdataq);
NeoLKernel/drivers/net/wireless/zd1211rw/zd_usb.c:	/* The stopped state is ignored, relying on ieee80211_wake_queues()
NeoLKernel/drivers/net/wireless/zd1211rw/zd_usb.c:	ieee80211_wake_queues(zd_usb_to_hw(usb));
NeoLKernel/drivers/net/wireless/zd1211rw/zd_usb.c:		ieee80211_wake_queues(zd_usb_to_hw(usb));
NeoLKernel/drivers/net/wireless/zd1211rw/zd_usb.h:	u8 ibss_wakeup_dest;
NeoLKernel/drivers/net/xen-netfront.c:static void xennet_maybe_wake_tx(struct net_device *dev)
NeoLKernel/drivers/net/xen-netfront.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/xen-netfront.c:	xennet_maybe_wake_tx(dev);
NeoLKernel/drivers/net/xilinx_emaclite.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/xilinx_emaclite.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/yellowfin.c:		netif_wake_queue (dev);		/* Typical path */
NeoLKernel/drivers/net/yellowfin.c:				netif_wake_queue(dev);
NeoLKernel/drivers/net/yellowfin.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/yellowfin.c:				netif_wake_queue(dev);
NeoLKernel/drivers/net/znet.c:	netif_wake_queue (dev);
NeoLKernel/drivers/net/znet.c:			netif_wake_queue (dev);
NeoLKernel/drivers/net/mipsnet.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/mlx4/en_ethtool.c:	"queue_stopped", "wake_queue", "tx_timeout", "rx_alloc_failed",
NeoLKernel/drivers/net/mlx4/en_tx.c:			netif_tx_wake_queue(netdev_get_tx_queue(dev, cq->ring));
NeoLKernel/drivers/net/mlx4/en_tx.c:			priv->port_stats.wake_queue++;
NeoLKernel/drivers/net/mlx4/mlx4_en.h:	unsigned long wake_queue;
NeoLKernel/drivers/net/msm_rmnet.c:#include <linux/wakelock.h>
NeoLKernel/drivers/net/msm_rmnet.c:	struct wake_lock wake_lock;
NeoLKernel/drivers/net/msm_rmnet.c:	unsigned long wakeups_xmit;
NeoLKernel/drivers/net/msm_rmnet.c:	unsigned long wakeups_rcv;
NeoLKernel/drivers/net/msm_rmnet.c:/* Returns 1 if packet caused rmnet to wakeup, 0 otherwise. */
NeoLKernel/drivers/net/msm_rmnet.c:static int rmnet_cause_wakeup(struct rmnet_private *p) {
NeoLKernel/drivers/net/msm_rmnet.c:static ssize_t wakeups_xmit_show(struct device *d,
NeoLKernel/drivers/net/msm_rmnet.c:	return sprintf(buf, "%lu\n", p->wakeups_xmit);
NeoLKernel/drivers/net/msm_rmnet.c:DEVICE_ATTR(wakeups_xmit, 0444, wakeups_xmit_show, NULL);
NeoLKernel/drivers/net/msm_rmnet.c:static ssize_t wakeups_rcv_show(struct device *d, struct device_attribute *attr,
NeoLKernel/drivers/net/msm_rmnet.c:	return sprintf(buf, "%lu\n", p->wakeups_rcv);
NeoLKernel/drivers/net/msm_rmnet.c:DEVICE_ATTR(wakeups_rcv, 0444, wakeups_rcv_show, NULL);
NeoLKernel/drivers/net/msm_rmnet.c:				wake_lock_timeout(&p->wake_lock, HZ / 2);
NeoLKernel/drivers/net/msm_rmnet.c:						p->wakeups_rcv +=
NeoLKernel/drivers/net/msm_rmnet.c:							rmnet_cause_wakeup(p);
NeoLKernel/drivers/net/msm_rmnet.c:		p->wakeups_xmit += rmnet_cause_wakeup(p);
NeoLKernel/drivers/net/msm_rmnet.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/msm_rmnet.c:		wake_lock_init(&p->wake_lock, WAKE_LOCK_SUSPEND, ch_name[n]);
NeoLKernel/drivers/net/msm_rmnet.c:		p->wakeups_xmit = p->wakeups_rcv = 0;
NeoLKernel/drivers/net/msm_rmnet.c:		if (device_create_file(d, &dev_attr_wakeups_xmit))
NeoLKernel/drivers/net/msm_rmnet.c:		if (device_create_file(d, &dev_attr_wakeups_rcv))
NeoLKernel/drivers/net/msm_rmnet_common.c:#include <linux/wakelock.h>
NeoLKernel/drivers/net/msm_rmnet_common.c:	unsigned long wakeups_xmit;
NeoLKernel/drivers/net/msm_rmnet_common.c:	unsigned long wakeups_rcv;
NeoLKernel/drivers/net/msm_rmnet_common.c:/* Returns 1 if packet caused rmnet to wakeup, 0 otherwise. */
NeoLKernel/drivers/net/msm_rmnet_common.c:static int rmnet_cause_wakeup(struct rmnet_private *p)
NeoLKernel/drivers/net/msm_rmnet_common.c:static ssize_t wakeups_xmit_show(struct device *d,
NeoLKernel/drivers/net/msm_rmnet_common.c:	return sprintf(buf, "%lu\n", p->wakeups_xmit);
NeoLKernel/drivers/net/msm_rmnet_common.c:DEVICE_ATTR(wakeups_xmit, 0444, wakeups_xmit_show, NULL);
NeoLKernel/drivers/net/msm_rmnet_common.c:static ssize_t wakeups_rcv_show(struct device *d, struct device_attribute *attr,
NeoLKernel/drivers/net/msm_rmnet_common.c:	return sprintf(buf, "%lu\n", p->wakeups_rcv);
NeoLKernel/drivers/net/msm_rmnet_common.c:DEVICE_ATTR(wakeups_rcv, 0444, wakeups_rcv_show, NULL);
NeoLKernel/drivers/net/msm_rmnet_common.c:			p->wakeups_rcv += rmnet_cause_wakeup(p);
NeoLKernel/drivers/net/msm_rmnet_common.c:		p->wakeups_xmit += rmnet_cause_wakeup(p);
NeoLKernel/drivers/net/msm_rmnet_common.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/msm_rmnet_common.c:		p->wakeups_xmit = p->wakeups_rcv = 0;
NeoLKernel/drivers/net/msm_rmnet_common.c:		if (device_create_file(d, &dev_attr_wakeups_xmit))
NeoLKernel/drivers/net/msm_rmnet_common.c:		if (device_create_file(d, &dev_attr_wakeups_rcv))
NeoLKernel/drivers/net/msm_rmnet_sdio.c:#include <linux/wakelock.h>
NeoLKernel/drivers/net/msm_rmnet_sdio.c:struct wake_lock sdio_mux_ch_wakelock;
NeoLKernel/drivers/net/msm_rmnet_sdio.c:	/* half second wakelock is fine? */
NeoLKernel/drivers/net/msm_rmnet_sdio.c:	wake_lock_timeout(&sdio_mux_ch_wakelock, HZ / 2);
NeoLKernel/drivers/net/msm_rmnet_sdio.c:	wake_lock_init(&sdio_mux_ch_wakelock, WAKE_LOCK_SUSPEND,
NeoLKernel/drivers/net/msm_rmnet_sdio.c:		wake_lock_destroy(&sdio_mux_ch_wakelock);
NeoLKernel/drivers/net/mv643xx_eth.c:static void txq_maybe_wake(struct tx_queue *txq)
NeoLKernel/drivers/net/mv643xx_eth.c:			netif_tx_wake_queue(nq);
NeoLKernel/drivers/net/mv643xx_eth.c:		wake_up(&msp->smi_busy_wait);
NeoLKernel/drivers/net/mv643xx_eth.c:			txq_maybe_wake(mp->txq + queue);
NeoLKernel/drivers/net/mv643xx_eth.c:		netif_tx_wake_all_queues(mp->dev);
NeoLKernel/drivers/net/myri10ge/myri10ge.c:	int wake_queue;
NeoLKernel/drivers/net/myri10ge/myri10ge.c:		ss->tx.wake_queue = 0;
NeoLKernel/drivers/net/myri10ge/myri10ge.c:		tx->wake_queue++;
NeoLKernel/drivers/net/myri10ge/myri10ge.c:		netif_tx_wake_queue(dev_queue);
NeoLKernel/drivers/net/myri10ge/myri10ge.c:			wake_up(&mgp->down_wq);
NeoLKernel/drivers/net/myri10ge/myri10ge.c:	"wake_queue", "stop_queue", "tx_linearized", "LRO aggregated",
NeoLKernel/drivers/net/myri10ge/myri10ge.c:		data[i++] = (unsigned int)ss->tx.wake_queue;
NeoLKernel/drivers/net/myri10ge/myri10ge.c:	netif_tx_wake_all_queues(dev);
NeoLKernel/drivers/net/myri_sbus.c:			DET(("wakeup successful, "));
NeoLKernel/drivers/net/myri_sbus.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/natsemi.c:	 * Read the intr status to clear it (needed for wake events).
NeoLKernel/drivers/net/natsemi.c:	/* clear any interrupts that are pending, such as wake events */
NeoLKernel/drivers/net/natsemi.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/natsemi.c:		/* The ring is no longer full, wake queue. */
NeoLKernel/drivers/net/natsemi.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/natsemi.c:		printk(KERN_NOTICE "%s: Link wake-up event %#08x\n",
NeoLKernel/drivers/net/natsemi.c:		printk(KERN_INFO "%s: remaining active for wake-on-lan\n",
NeoLKernel/drivers/net/netx-eth.c:			netif_wake_queue(ndev);
NeoLKernel/drivers/net/netx-eth.c:	netif_wake_queue(ndev);
NeoLKernel/drivers/net/cpmac.c:			netif_wake_subqueue(dev, queue);
NeoLKernel/drivers/net/cpmac.c:			netif_wake_subqueue(dev, queue);
NeoLKernel/drivers/net/cpmac.c:	netif_tx_wake_all_queues(priv->dev);
NeoLKernel/drivers/net/cpmac.c:	netif_tx_wake_all_queues(priv->dev);
NeoLKernel/drivers/net/cris/eth_v10.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/cris/eth_v10.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/cs89x0.c:                    : Don't call netif_wake_queue() in net_send_packet()
NeoLKernel/drivers/net/cs89x0.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/cs89x0.c:	 * We DO NOT call netif_wake_queue() here.
NeoLKernel/drivers/net/cs89x0.c:			netif_wake_queue(dev);	/* Inform upper layers. */
NeoLKernel/drivers/net/cs89x0.c:				netif_wake_queue(dev);	/* Inform upper layers. */
NeoLKernel/drivers/net/cs89x0.c:				netif_wake_queue(dev);	/* Inform upper layers. */
NeoLKernel/drivers/net/cxgb3/sge.c:			"%s: Tx ring %u full while queue awake!\n",
NeoLKernel/drivers/net/cxgb3/sge.c:			netif_tx_wake_queue(txq);
NeoLKernel/drivers/net/cxgb3/sge.c:			netif_tx_wake_queue(qs->tx_q);
NeoLKernel/drivers/net/davinci_emac.c:			netif_wake_queue(ndev);
NeoLKernel/drivers/net/de600.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/de620.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/de620.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/de620.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/de620.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/declance.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/declance.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/declance.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/declance.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/declance.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/defxx.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/defxx.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/defxx.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/defxx.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/depca.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/depca.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/dl2k.c:			np->wake_polarity = psib[i];
NeoLKernel/drivers/net/dl2k.c:	   call netif_wake_queue() */
NeoLKernel/drivers/net/dl2k.c:		netif_wake_queue (dev);
NeoLKernel/drivers/net/dl2k.c:		netif_wake_queue (dev);
NeoLKernel/drivers/net/dl2k.h:	int wake_polarity;
NeoLKernel/drivers/net/dm9000.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/dm9000.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/dnet.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/smc91x.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/smc91x.c:				netif_wake_queue(dev);
NeoLKernel/drivers/net/smc91x.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/smc91x.c:	 * Wait for the chip to wake up.  We could poll the control
NeoLKernel/drivers/net/smsc911x.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/smsc911x.c:	/* enable wake on LAN, energy detection and the external PME
NeoLKernel/drivers/net/smsc911x.c:	 * 	 data to the BYTE_TEST register will wake-up the device."
NeoLKernel/drivers/net/smsc9420.c:			netif_wake_queue(pd->dev);
NeoLKernel/drivers/net/smsc9420.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/smsc9420.c:	pci_enable_wake(pdev, pci_choose_state(pdev, state), 0);
NeoLKernel/drivers/net/smsc9420.c:	err = pci_enable_wake(pdev, 0, 0);
NeoLKernel/drivers/net/smsc9420.c:		smsc_warn(IFUP, "pci_enable_wake failed: %d", err);
NeoLKernel/drivers/net/sonic.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/sonic.c: *   wake the tx queue
NeoLKernel/drivers/net/sonic.c:				netif_wake_queue(dev);  /* The ring is no longer full */
NeoLKernel/drivers/net/spider_net.c:		netif_wake_queue(card->netdev);
NeoLKernel/drivers/net/starfire.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/starfire.c:			/* The ring is no longer full, wake the queue. */
NeoLKernel/drivers/net/starfire.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/starfire.c:	/* XXX: add wakeup code -- requires firmware for MagicPacket */
NeoLKernel/drivers/net/stmmac/gmac.h:	wake_up_rx_frame = 0x00000040,
NeoLKernel/drivers/net/stmmac/gmac.h:	wake_up_frame_en = 0x00000004,
NeoLKernel/drivers/net/stmmac/stmmac_ethtool.c:		device_set_wakeup_enable(priv->device, 0);
NeoLKernel/drivers/net/stmmac/stmmac_ethtool.c:		device_set_wakeup_enable(priv->device, 1);
NeoLKernel/drivers/net/stmmac/stmmac_main.c:/* minimum number of free TX descriptors required to wake up TX process */
NeoLKernel/drivers/net/stmmac/stmmac_main.c:			netif_wake_queue(priv->dev);
NeoLKernel/drivers/net/stmmac/stmmac_main.c:	netif_wake_queue(priv->dev);
NeoLKernel/drivers/net/stmmac/stmmac_main.c:		TX_DBG(KERN_ERR "%s: TSO BUG! Tx Ring full when queue awake\n",
NeoLKernel/drivers/net/stmmac/stmmac_main.c:		netif_wake_queue(priv->dev);
NeoLKernel/drivers/net/stmmac/stmmac_main.c:			pr_err("%s: BUG! Tx Ring full when queue awake\n",
NeoLKernel/drivers/net/stmmac/stmmac_main.c:		if (device_may_wakeup(&(pdev->dev))) {
NeoLKernel/drivers/net/stmmac/stmmac_main.c:	if (device_may_wakeup(&(pdev->dev)))
NeoLKernel/drivers/net/sun3lance.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/sun3_82586.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/sun3_82586.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/sun3_82586.c:				netif_wake_queue(dev);
NeoLKernel/drivers/net/sun3_82586.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/3c509.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/3c509.c:			netif_wake_queue (dev);
NeoLKernel/drivers/net/3c515.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/3c515.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/3c515.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/3c515.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/3c515.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/3c515.c:				netif_wake_queue(dev);
NeoLKernel/drivers/net/3c515.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/3c523.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/3c523.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/3c523.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/3c527.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/3c527.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/3c527.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/3c527.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/3c59x.c:	/* wake up and enable device */
NeoLKernel/drivers/net/3c59x.c:			netif_wake_queue (dev);
NeoLKernel/drivers/net/3c59x.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/3c59x.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/3c59x.c:		/* netif_wake_queue() will be called at the DMADone interrupt. */
NeoLKernel/drivers/net/3c59x.c:			netif_wake_queue (dev);
NeoLKernel/drivers/net/3c59x.c:					 * netif_wake_queue()
NeoLKernel/drivers/net/3c59x.c:					netif_wake_queue(dev);
NeoLKernel/drivers/net/3c59x.c:					pr_debug("boomerang_interrupt: wake queue\n");
NeoLKernel/drivers/net/3c59x.c:				netif_wake_queue (dev);
NeoLKernel/drivers/net/3c59x.c:	device_set_wakeup_enable(vp->gendev, vp->enable_wol);
NeoLKernel/drivers/net/3c59x.c:		if (pci_enable_wake(VORTEX_PCI(vp), PCI_D3hot, 1)) {
NeoLKernel/drivers/net/7990.c:		netif_wake_queue (dev);
NeoLKernel/drivers/net/7990.c:	netif_wake_queue (dev);
NeoLKernel/drivers/net/8139cp.c:	BWF             = (1 << 6),  /* Accept Broadcast wakeup frame */
NeoLKernel/drivers/net/8139cp.c:	MWF             = (1 << 5),  /* Accept Multicast wakeup frame */
NeoLKernel/drivers/net/8139cp.c:	UWF             = (1 << 4),  /* Accept Unicast wakeup frame */
NeoLKernel/drivers/net/8139cp.c:		netif_wake_queue(cp->dev);
NeoLKernel/drivers/net/8139cp.c:		pr_err(PFX "%s: BUG! Tx Ring full when queue awake!\n",
NeoLKernel/drivers/net/8139cp.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/8139cp.c:	pci_enable_wake (cp->pdev, 0, 1); /* Enable PME# generation */
NeoLKernel/drivers/net/8139cp.c:	pci_enable_wake(pdev, pci_choose_state(pdev, state), cp->wol_enabled);
NeoLKernel/drivers/net/8139cp.c:	pci_enable_wake(pdev, PCI_D0, 0);
NeoLKernel/drivers/net/8139too.c:	Cfg3_LinkUp   	= (1 << 4), /* 1	= wake up on link up */
NeoLKernel/drivers/net/8139too.c:	Cfg3_Magic    	= (1 << 5), /* 1	= wake up on Magic Packet (tm) */
NeoLKernel/drivers/net/8139too.c:	Cfg5_UWF        = (1 << 4), /* 1 = accept unicast wakeup frame */
NeoLKernel/drivers/net/8139too.c:	Cfg5_MWF        = (1 << 5), /* 1 = accept multicast wakeup frame */
NeoLKernel/drivers/net/8139too.c:	Cfg5_BWF        = (1 << 6), /* 1 = accept broadcast wakeup frame */
NeoLKernel/drivers/net/8139too.c:	/* enable device (incl. PCI PM wakeup and hotplug setup) */
NeoLKernel/drivers/net/8139too.c:		pr_debug("PCI PM wakeup\n");
NeoLKernel/drivers/net/8139too.c:		pr_debug("Old chip wakeup\n");
NeoLKernel/drivers/net/8139too.c:		netif_wake_queue (dev);
NeoLKernel/drivers/net/8139too.c:	/* only wake the queue if we did work, and the queue is stopped */
NeoLKernel/drivers/net/8139too.c:		netif_wake_queue (dev);
NeoLKernel/drivers/net/82596.c:	netif_wake_queue (dev);
NeoLKernel/drivers/net/a2065.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/a2065.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/a2065.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/a2065.c:	netif_wake_queue(dev);
NeoLKernel/drivers/net/acenic.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/acenic.c:		netif_wake_queue(dev);
NeoLKernel/drivers/net/acenic.c:	/* So... tx_ret_csm is advanced _after_ check for device wakeup.
NeoLKernel/drivers/net/acenic.c:	 * which we have just freed, so that we make illegal device wakeup.
NeoLKernel/drivers/net/acenic.c:	 * When tx_ret_csm is advanced after, we wake up device _only_
NeoLKernel/drivers/net/acenic.c:	 * may think that ring is full between wakeup and advancing
NeoLKernel/drivers/net/acenic.c:			netif_wake_queue(dev);
NeoLKernel/drivers/net/acenic.c:	 * We wake up the queue _before_ tx_prd is advanced, so that we can
NeoLKernel/drivers/oprofile/event_buffer.c: * wake up the process sleeping on the read() of the file. To protect
NeoLKernel/drivers/oprofile/event_buffer.c:		wake_up(&buffer_wait);
NeoLKernel/drivers/oprofile/event_buffer.c:void wake_up_buffer_waiter(void)
NeoLKernel/drivers/oprofile/event_buffer.c:	wake_up(&buffer_wait);
NeoLKernel/drivers/oprofile/event_buffer.h:/* wake up the process sleeping on the event file */
NeoLKernel/drivers/oprofile/event_buffer.h:void wake_up_buffer_waiter(void);
NeoLKernel/drivers/oprofile/oprof.c:	/* wake up the daemon to read what remains */
NeoLKernel/drivers/oprofile/oprof.c:	wake_up_buffer_waiter();
NeoLKernel/drivers/oprofile/oprofile_files.c:	wake_up_buffer_waiter();
NeoLKernel/drivers/parport/daisy.c:                   they wake up. */
NeoLKernel/drivers/parport/ieee1284.c:/* Make parport_wait_peripheral wake up.
NeoLKernel/drivers/parport/ieee1284.c:static void parport_ieee1284_wakeup (struct parport *port)
NeoLKernel/drivers/parport/ieee1284.c:	parport_ieee1284_wakeup (port_from_cookie[cookie % PARPORT_MAX]);
NeoLKernel/drivers/parport/ieee1284.c:	parport_ieee1284_wakeup (port);
NeoLKernel/drivers/parport/ieee1284.c:		parport_ieee1284_wakeup (dev->port);
NeoLKernel/drivers/parport/parport_ip32.c: * parport_ip32_wakeup - wakes up code waiting for an interrupt
NeoLKernel/drivers/parport/parport_ip32.c:static inline void parport_ip32_wakeup(struct parport *p)
NeoLKernel/drivers/parport/parport_ip32.c:		parport_ip32_wakeup(p);
NeoLKernel/drivers/parport/parport_ip32.c:		 * peripheral doesn't wake up now.
NeoLKernel/drivers/parport/share.c: *	@kf: kick callback (wake-up)
NeoLKernel/drivers/parport/share.c: *	The wake-up ("kick") callback function, @kf, is called when
NeoLKernel/drivers/parport/share.c: *	inside the wake-up callback function.  If the driver wants to
NeoLKernel/drivers/parport/share.c:	tmp->wakeup = kf;
NeoLKernel/drivers/parport/share.c:	   parport_claim_or_block(), or those with a wakeup function.  */
NeoLKernel/drivers/parport/share.c:	if (dev->waiting & 2 || dev->wakeup) {
NeoLKernel/drivers/parport/share.c:	   wakeup function.  */
NeoLKernel/drivers/parport/share.c:	   then wake them up. (Note: no locking required) */
NeoLKernel/drivers/parport/share.c:				wake_up_interruptible(&pd->wait_q);
NeoLKernel/drivers/parport/share.c:		} else if (pd->wakeup) {
NeoLKernel/drivers/parport/share.c:			pd->wakeup(pd->private);
NeoLKernel/drivers/parport/share.c:			printk(KERN_ERR "%s: don't know how to wake %s\n", port->name, pd->name);
NeoLKernel/drivers/parport/share.c:		if (pd->wakeup && pd != dev)
NeoLKernel/drivers/parport/share.c:			pd->wakeup(pd->private);
NeoLKernel/drivers/pci/access.c:	wake_up_all(&pci_ucfg_wait);
NeoLKernel/drivers/pci/hotplug/acpiphp_glue.c:		/* wake event */
NeoLKernel/drivers/pci/hotplug/acpiphp_glue.c:		dbg("%s: Device wake notify on %s\n", __func__, objname);
NeoLKernel/drivers/pci/hotplug/acpiphp_glue.c:		/* wake event */
NeoLKernel/drivers/pci/hotplug/acpiphp_glue.c:		dbg("%s: Device wake notify on %s\n", __func__, objname);
NeoLKernel/drivers/pci/hotplug/acpiphp_glue.c:	/* wake up all functions */
NeoLKernel/drivers/pci/hotplug/cpci_hotplug_core.c:	wake_up_process(cpci_thread);
NeoLKernel/drivers/pci/hotplug/cpqphp.h:	wait_queue_head_t queue;	/* sleep & wake process */
NeoLKernel/drivers/pci/hotplug/cpqphp_ctrl.c:		wake_up_interruptible(&ctrl->queue);
NeoLKernel/drivers/pci/hotplug/cpqphp_ctrl.c:		wake_up_interruptible(&ctrl->queue);
NeoLKernel/drivers/pci/hotplug/cpqphp_ctrl.c:		wake_up_process(cpqhp_event_thread);
NeoLKernel/drivers/pci/hotplug/cpqphp_ctrl.c:	wake_up_process(cpqhp_event_thread);
NeoLKernel/drivers/pci/hotplug/pciehp.h:	wait_queue_head_t queue;	/* sleep & wake process */
NeoLKernel/drivers/pci/hotplug/pciehp_hpc.c:		wake_up(&ctrl->queue);
NeoLKernel/drivers/pci/hotplug/shpchp.h:	wait_queue_head_t queue;	/* sleep & wake process */
NeoLKernel/drivers/pci/hotplug/shpchp_hpc.c:		wake_up_interruptible(&ctrl->queue);
NeoLKernel/drivers/pci/pci-acpi.c: * (Power Resources for Wake) supporting system wakeup from "x"
NeoLKernel/drivers/pci/pci-acpi.c: * may enter while still able to wake the system.
NeoLKernel/drivers/pci/pci-acpi.c:static bool acpi_pci_can_wakeup(struct pci_dev *dev)
NeoLKernel/drivers/pci/pci-acpi.c:	return handle ? acpi_bus_can_wakeup(handle) : false;
NeoLKernel/drivers/pci/pci-acpi.c:static void acpi_pci_propagate_wakeup_enable(struct pci_bus *bus, bool enable)
NeoLKernel/drivers/pci/pci-acpi.c:		ret = acpi_pm_device_sleep_wake(&bridge->dev, enable);
NeoLKernel/drivers/pci/pci-acpi.c:		acpi_pm_device_sleep_wake(bus->bridge, enable);
NeoLKernel/drivers/pci/pci-acpi.c:static int acpi_pci_sleep_wake(struct pci_dev *dev, bool enable)
NeoLKernel/drivers/pci/pci-acpi.c:	if (acpi_pci_can_wakeup(dev))
NeoLKernel/drivers/pci/pci-acpi.c:		return acpi_pm_device_sleep_wake(&dev->dev, enable);
NeoLKernel/drivers/pci/pci-acpi.c:		acpi_pci_propagate_wakeup_enable(dev->bus, enable);
NeoLKernel/drivers/pci/pci-acpi.c:	.can_wakeup = acpi_pci_can_wakeup,
NeoLKernel/drivers/pci/pci-acpi.c:	.sleep_wake = acpi_pci_sleep_wake,
NeoLKernel/drivers/pci/pci-driver.c:	 * horrible the crap we have to deal with is when we are awake...
NeoLKernel/drivers/pci/pci-driver.c:		pci_enable_wake(pci_dev, PCI_D0, false);
NeoLKernel/drivers/pci/pci.c:#include <linux/pm_wakeup.h>
NeoLKernel/drivers/pci/pci.c: * pci_restore_bars - restore a devices BAR values (e.g. after wake-up)
NeoLKernel/drivers/pci/pci.c:	    || !ops->sleep_wake || !ops->can_wakeup)
NeoLKernel/drivers/pci/pci.c:static inline bool platform_pci_can_wakeup(struct pci_dev *dev)
NeoLKernel/drivers/pci/pci.c:	return pci_platform_pm ? pci_platform_pm->can_wakeup(dev) : false;
NeoLKernel/drivers/pci/pci.c:static inline int platform_pci_sleep_wake(struct pci_dev *dev, bool enable)
NeoLKernel/drivers/pci/pci.c:			pci_platform_pm->sleep_wake(dev, enable) : -ENODEV;
NeoLKernel/drivers/pci/pci.c: * pci_enable_wake - enable PCI device as wakeup event source
NeoLKernel/drivers/pci/pci.c: * @state: PCI state from which device will issue wakeup events
NeoLKernel/drivers/pci/pci.c: * This enables the device as a wakeup event source, or disables it.
NeoLKernel/drivers/pci/pci.c: * -EINVAL is returned if device is not supposed to wake up the system
NeoLKernel/drivers/pci/pci.c: * the native mechanism fail to enable the generation of wake-up events
NeoLKernel/drivers/pci/pci.c:int pci_enable_wake(struct pci_dev *dev, pci_power_t state, bool enable)
NeoLKernel/drivers/pci/pci.c:	if (enable && !device_may_wakeup(&dev->dev))
NeoLKernel/drivers/pci/pci.c:	if (!!enable == !!dev->wakeup_prepared)
NeoLKernel/drivers/pci/pci.c:	 * Anderson we should be doing PME# wake enable followed by ACPI wake
NeoLKernel/drivers/pci/pci.c:	 * enable.  To disable wake-up we call the platform first, for symmetry.
NeoLKernel/drivers/pci/pci.c:		error = platform_pci_sleep_wake(dev, true);
NeoLKernel/drivers/pci/pci.c:			dev->wakeup_prepared = true;
NeoLKernel/drivers/pci/pci.c:		platform_pci_sleep_wake(dev, false);
NeoLKernel/drivers/pci/pci.c:		dev->wakeup_prepared = false;
NeoLKernel/drivers/pci/pci.c: * pci_wake_from_d3 - enable/disable device to wake up from D3_hot or D3_cold
NeoLKernel/drivers/pci/pci.c: * @enable: True to enable wake-up event generation; false to disable
NeoLKernel/drivers/pci/pci.c: * Many drivers want the device to wake up the system from D3_hot or D3_cold
NeoLKernel/drivers/pci/pci.c: * and this function allows them to set that up cleanly - pci_enable_wake()
NeoLKernel/drivers/pci/pci.c: * should not be called twice in a row to enable wake-up due to PCI PM vs ACPI
NeoLKernel/drivers/pci/pci.c: * enable wake-up power for it.
NeoLKernel/drivers/pci/pci.c:int pci_wake_from_d3(struct pci_dev *dev, bool enable)
NeoLKernel/drivers/pci/pci.c:			pci_enable_wake(dev, PCI_D3cold, enable) :
NeoLKernel/drivers/pci/pci.c:			pci_enable_wake(dev, PCI_D3hot, enable);
NeoLKernel/drivers/pci/pci.c: * can generate wake events, based on any available PME info.
NeoLKernel/drivers/pci/pci.c:		 * and enable wake-up from this state if supported.
NeoLKernel/drivers/pci/pci.c:	} else if (device_may_wakeup(&dev->dev)) {
NeoLKernel/drivers/pci/pci.c:		 * wake-up events, make it the target state and enable device
NeoLKernel/drivers/pci/pci.c: * it can wake up the system and/or is power manageable by the platform
NeoLKernel/drivers/pci/pci.c:	pci_enable_wake(dev, target_state, device_may_wakeup(&dev->dev));
NeoLKernel/drivers/pci/pci.c:		pci_enable_wake(dev, target_state, false);
NeoLKernel/drivers/pci/pci.c: * Disable device's sytem wake-up capability and put it into D0.
NeoLKernel/drivers/pci/pci.c:	pci_enable_wake(dev, PCI_D0, false);
NeoLKernel/drivers/pci/pci.c:	dev->wakeup_prepared = false;
NeoLKernel/drivers/pci/pci.c:		 * Make device's PM flags reflect the wake-up capability, but
NeoLKernel/drivers/pci/pci.c:		 * let the user space enable it to wake up the system as needed.
NeoLKernel/drivers/pci/pci.c:		device_set_wakeup_capable(&dev->dev, true);
NeoLKernel/drivers/pci/pci.c:		device_set_wakeup_enable(&dev->dev, false);
NeoLKernel/drivers/pci/pci.c: * platform_pci_wakeup_init - init platform wakeup if present
NeoLKernel/drivers/pci/pci.c: * Some devices don't have PCI PM caps but can still generate wakeup
NeoLKernel/drivers/pci/pci.c: * platform wakeup events, set the device flag to indicate as much.  This
NeoLKernel/drivers/pci/pci.c:void platform_pci_wakeup_init(struct pci_dev *dev)
NeoLKernel/drivers/pci/pci.c:	if (!platform_pci_can_wakeup(dev))
NeoLKernel/drivers/pci/pci.c:	device_set_wakeup_capable(&dev->dev, true);
NeoLKernel/drivers/pci/pci.c:	device_set_wakeup_enable(&dev->dev, false);
NeoLKernel/drivers/pci/pci.c:	platform_pci_sleep_wake(dev, false);
NeoLKernel/drivers/pci/pci.c:EXPORT_SYMBOL(pci_enable_wake);
NeoLKernel/drivers/pci/pci.c:EXPORT_SYMBOL(pci_wake_from_d3);
NeoLKernel/drivers/pci/pci.h: * @can_wakeup: returns 'true' if given device is capable of waking up the
NeoLKernel/drivers/pci/pci.h: * @sleep_wake: enables/disables the system wake up capability of given device
NeoLKernel/drivers/pci/pci.h:	bool (*can_wakeup)(struct pci_dev *dev);
NeoLKernel/drivers/pci/pci.h:	int (*sleep_wake)(struct pci_dev *dev, bool enable);
NeoLKernel/drivers/pci/pci.h:extern void platform_pci_wakeup_init(struct pci_dev *dev);
NeoLKernel/drivers/pci/pcie/aer/aerdrv_core.c:	wake_up(&rpc->wait_release);
NeoLKernel/drivers/pci/probe.c:	platform_pci_wakeup_init(dev);
NeoLKernel/drivers/pcmcia/i82365.c:static int wakeup = 0;
NeoLKernel/drivers/pcmcia/i82365.c:module_param(wakeup, int, 0444);
NeoLKernel/drivers/pcmcia/i82365.c:    if (wakeup) {
NeoLKernel/drivers/pcmcia/at91_cf.c:	device_init_wakeup(&pdev->dev, 1);
NeoLKernel/drivers/pcmcia/at91_cf.c:	device_init_wakeup(&pdev->dev, 0);
NeoLKernel/drivers/pcmcia/at91_cf.c:	device_init_wakeup(&pdev->dev, 0);
NeoLKernel/drivers/pcmcia/at91_cf.c:	if (device_may_wakeup(&pdev->dev)) {
NeoLKernel/drivers/pcmcia/at91_cf.c:		enable_irq_wake(board->det_pin);
NeoLKernel/drivers/pcmcia/at91_cf.c:			enable_irq_wake(board->irq_pin);
NeoLKernel/drivers/pcmcia/at91_cf.c:	if (device_may_wakeup(&pdev->dev)) {
NeoLKernel/drivers/pcmcia/at91_cf.c:		disable_irq_wake(board->det_pin);
NeoLKernel/drivers/pcmcia/at91_cf.c:			disable_irq_wake(board->irq_pin);
NeoLKernel/drivers/pcmcia/cs.c:		wake_up_process(s->thread);
NeoLKernel/drivers/pcmcia/cs.c:/* These shut down or wake up a socket.  They are sort of user
NeoLKernel/drivers/pcmcia/electra_cf.c:	device_init_wakeup(&ofdev->dev, 0);
NeoLKernel/drivers/pcmcia/pcmcia_ioctl.c:    wake_up_interruptible(&s->queue);
NeoLKernel/drivers/platform/x86/sony-laptop.c:	wake_up_interruptible(&sonypi_compat.fifo_proc_list);
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:} hotkey_wakeup_reason;
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:/* sysfs wakeup reason (pollable) -------------------------------------- */
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:static ssize_t hotkey_wakeup_reason_show(struct device *dev,
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:	return snprintf(buf, PAGE_SIZE, "%d\n", hotkey_wakeup_reason);
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:static struct device_attribute dev_attr_hotkey_wakeup_reason =
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:	__ATTR(wakeup_reason, S_IRUGO, hotkey_wakeup_reason_show, NULL);
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:static void hotkey_wakeup_reason_notify_change(void)
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:		     "wakeup_reason");
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:/* sysfs wakeup hotunplug_complete (pollable) -------------------------- */
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:static ssize_t hotkey_wakeup_hotunplug_complete_show(struct device *dev,
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:static struct device_attribute dev_attr_hotkey_wakeup_hotunplug_complete =
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:	__ATTR(wakeup_hotunplug_complete, S_IRUGO,
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:	       hotkey_wakeup_hotunplug_complete_show, NULL);
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:static void hotkey_wakeup_hotunplug_complete_notify_change(void)
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:		     "wakeup_hotunplug_complete");
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:	&dev_attr_hotkey_wakeup_reason.attr,
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:	&dev_attr_hotkey_wakeup_hotunplug_complete.attr,
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:static bool hotkey_notify_wakeup(const u32 hkey,
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:		hotkey_wakeup_reason = TP_ACPI_WAKEUP_UNDOCK;
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:		hotkey_wakeup_reason = TP_ACPI_WAKEUP_BAYEJ;
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:	if (hotkey_wakeup_reason != TP_ACPI_WAKEUP_NONE) {
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:		hotkey_wakeup_reason_notify_change();
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:			known_ev = hotkey_notify_wakeup(hkey, &send_acpi_ev,
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:			/* 0x3000-0x3FFF: bay-related wakeups */
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:				hotkey_wakeup_hotunplug_complete_notify_change();
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:			/* 0x4000-0x4FFF: dock-related wakeups */
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:				hotkey_wakeup_hotunplug_complete_notify_change();
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:	hotkey_wakeup_reason = TP_ACPI_WAKEUP_NONE;
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:	hotkey_wakeup_reason_notify_change();
NeoLKernel/drivers/platform/x86/thinkpad_acpi.c:	hotkey_wakeup_hotunplug_complete_notify_change();
NeoLKernel/drivers/pnp/isapnp/core.c:static void isapnp_wake(unsigned char csn)
NeoLKernel/drivers/pnp/isapnp/core.c:	isapnp_wake(0x00);
NeoLKernel/drivers/pnp/isapnp/core.c:			isapnp_wake(0x00);
NeoLKernel/drivers/pnp/isapnp/core.c:		isapnp_wake(csn);
NeoLKernel/drivers/pnp/isapnp/core.c:	isapnp_wake(csn);
NeoLKernel/drivers/pnp/isapnp/core.c:	isapnp_wake(csn);	/* bring card into sleep state */
NeoLKernel/drivers/pnp/isapnp/core.c:	isapnp_wake(0);		/* bring card into isolation state */
NeoLKernel/drivers/power/bq24185_charger.c:#include <linux/wakelock.h>
NeoLKernel/drivers/power/bq24185_charger.c:	struct wake_lock wake_lock;
NeoLKernel/drivers/power/bq24185_charger.c:	u8 irq_wake_enabled;
NeoLKernel/drivers/power/bq24185_charger.c:	wake_lock(&bd->wake_lock);
NeoLKernel/drivers/power/bq24185_charger.c:	wake_unlock(&bd->wake_lock);
NeoLKernel/drivers/power/bq24185_charger.c:	if (bd->irq_wake_enabled)
NeoLKernel/drivers/power/bq24185_charger.c:		(void)disable_irq_wake(client->irq);
NeoLKernel/drivers/power/bq24185_charger.c:	wake_lock_destroy(&bd->wake_lock);
NeoLKernel/drivers/power/bq24185_charger.c:	wake_lock_init(&bd->wake_lock, WAKE_LOCK_SUSPEND,
NeoLKernel/drivers/power/bq24185_charger.c:	device_init_wakeup(&client->dev, 1);
NeoLKernel/drivers/power/bq24185_charger.c:	rc = enable_irq_wake(client->irq);
NeoLKernel/drivers/power/bq24185_charger.c:			"Failed to enable wakeup on IRQ request\n");
NeoLKernel/drivers/power/bq24185_charger.c:		bd->irq_wake_enabled = 1;
NeoLKernel/drivers/power/bq24185_charger.c:	wake_lock_destroy(&bd->wake_lock);
NeoLKernel/drivers/power/bq27520_battery.c:		set_irq_wake(client->irq, 1);
NeoLKernel/drivers/power/bq27520_battery.c:		set_irq_wake(client->irq, 0);
NeoLKernel/drivers/power/da9030_battery.c:	/* we wake or boot with external power on */
NeoLKernel/drivers/power/ds2784_battery.c:#include <linux/wakelock.h>
NeoLKernel/drivers/power/ds2784_battery.c:/* When we're awake or running on wall power, sample the battery
NeoLKernel/drivers/power/ds2784_battery.c:	struct wake_lock work_wake_lock;
NeoLKernel/drivers/power/ds2784_battery.c:static struct wake_lock vbus_wake_lock;
NeoLKernel/drivers/power/ds2784_battery.c:	wake_unlock(&di->work_wake_lock);
NeoLKernel/drivers/power/ds2784_battery.c:	wake_lock(&di->work_wake_lock);
NeoLKernel/drivers/power/ds2784_battery.c:		wake_lock(&vbus_wake_lock);
NeoLKernel/drivers/power/ds2784_battery.c:		wake_lock_timeout(&vbus_wake_lock, HZ / 2);
NeoLKernel/drivers/power/ds2784_battery.c:	wake_lock_init(&di->work_wake_lock, WAKE_LOCK_SUSPEND,
NeoLKernel/drivers/power/ds2784_battery.c:	wake_lock(&di->work_wake_lock);
NeoLKernel/drivers/power/ds2784_battery.c:	wake_lock_init(&vbus_wake_lock, WAKE_LOCK_SUSPEND, "vbus_present");
NeoLKernel/drivers/power/pda_power.c:		device_init_wakeup(&pdev->dev, 1);
NeoLKernel/drivers/power/pda_power.c:static int ac_wakeup_enabled;
NeoLKernel/drivers/power/pda_power.c:static int usb_wakeup_enabled;
NeoLKernel/drivers/power/pda_power.c:	if (device_may_wakeup(&pdev->dev)) {
NeoLKernel/drivers/power/pda_power.c:			ac_wakeup_enabled = !enable_irq_wake(ac_irq->start);
NeoLKernel/drivers/power/pda_power.c:			usb_wakeup_enabled = !enable_irq_wake(usb_irq->start);
NeoLKernel/drivers/power/pda_power.c:	if (device_may_wakeup(&pdev->dev)) {
NeoLKernel/drivers/power/pda_power.c:		if (usb_irq && usb_wakeup_enabled)
NeoLKernel/drivers/power/pda_power.c:			disable_irq_wake(usb_irq->start);
NeoLKernel/drivers/power/pda_power.c:		if (ac_irq && ac_wakeup_enabled)
NeoLKernel/drivers/power/pda_power.c:			disable_irq_wake(ac_irq->start);
NeoLKernel/drivers/power/power_supply_core.c:		wake_unlock(&psy->work_wake_lock);
NeoLKernel/drivers/power/power_supply_core.c:	wake_lock(&psy->work_wake_lock);
NeoLKernel/drivers/power/power_supply_core.c:	wake_lock_init(&psy->work_wake_lock, WAKE_LOCK_SUSPEND, "power-supply");
NeoLKernel/drivers/power/power_supply_core.c:	wake_lock_destroy(&psy->work_wake_lock);
NeoLKernel/drivers/power/power_supply_core.c:	wake_lock_destroy(&psy->work_wake_lock);
NeoLKernel/drivers/pps/kapi.c:		wake_up_interruptible(&pps->queue);
NeoLKernel/drivers/pps/pps.c:	/* Free the PPS source and wake up (possible) deregistration */
NeoLKernel/drivers/ps3/ps3-sys-manager.c: * enum ps3_sys_manager_wake_source - Next-op wakeup source (bit position mask).
NeoLKernel/drivers/ps3/ps3-sys-manager.c: * Additional wakeup sources when specifying PS3_SM_NEXT_OP_SYS_SHUTDOWN.
NeoLKernel/drivers/ps3/ps3-sys-manager.c: * The system will always wake from the PS3_SM_WAKE_DEFAULT sources.
NeoLKernel/drivers/ps3/ps3-sys-manager.c:enum ps3_sys_manager_wake_source {
NeoLKernel/drivers/ps3/ps3-sys-manager.c: * user_wake_sources - User specified wakeup sources.
NeoLKernel/drivers/ps3/ps3-sys-manager.c: * Logical OR of enum ps3_sys_manager_wake_source types.
NeoLKernel/drivers/ps3/ps3-sys-manager.c:static u32 user_wake_sources = PS3_SM_WAKE_DEFAULT;
NeoLKernel/drivers/ps3/ps3-sys-manager.c:	enum ps3_sys_manager_wake_source wake_source)
NeoLKernel/drivers/ps3/ps3-sys-manager.c:		u32 wake_source;
NeoLKernel/drivers/ps3/ps3-sys-manager.c:	payload.wake_source = wake_source;
NeoLKernel/drivers/ps3/ps3-sys-manager.c:		user_wake_sources);
NeoLKernel/drivers/ps3/ps3-sys-manager.c:		user_wake_sources);
NeoLKernel/drivers/ps3/ps3-sys-manager.c: * ps3_sys_manager_get_wol - Get wake-on-lan setting.
NeoLKernel/drivers/ps3/ps3-sys-manager.c:	return (user_wake_sources & PS3_SM_WAKE_W_O_L) != 0;
NeoLKernel/drivers/ps3/ps3-sys-manager.c: * ps3_sys_manager_set_wol - Set wake-on-lan setting.
NeoLKernel/drivers/ps3/ps3-sys-manager.c:		user_wake_sources |= PS3_SM_WAKE_W_O_L;
NeoLKernel/drivers/ps3/ps3-sys-manager.c:		user_wake_sources &= ~PS3_SM_WAKE_W_O_L;
NeoLKernel/drivers/ps3/ps3av.c:	/* wake up ps3avd to do the actual video mode setting */
NeoLKernel/drivers/rtc/interface.c:	wake_up_interruptible(&rtc->irq_queue);
NeoLKernel/drivers/rtc/alarm-dev.c:#include <linux/wakelock.h>
NeoLKernel/drivers/rtc/alarm-dev.c:static struct wake_lock alarm_wake_lock;
NeoLKernel/drivers/rtc/alarm-dev.c:				wake_unlock(&alarm_wake_lock);
NeoLKernel/drivers/rtc/alarm-dev.c:			wake_unlock(&alarm_wake_lock);
NeoLKernel/drivers/rtc/alarm-dev.c:		wake_up(&alarm_wait_queue);
NeoLKernel/drivers/rtc/alarm-dev.c:			wake_unlock(&alarm_wake_lock);
NeoLKernel/drivers/rtc/alarm-dev.c:		wake_lock_timeout(&alarm_wake_lock, 5 * HZ);
NeoLKernel/drivers/rtc/alarm-dev.c:		wake_up(&alarm_wait_queue);
NeoLKernel/drivers/rtc/alarm-dev.c:	wake_lock_init(&alarm_wake_lock, WAKE_LOCK_SUSPEND, "alarm");
NeoLKernel/drivers/rtc/alarm-dev.c:	wake_lock_destroy(&alarm_wake_lock);
NeoLKernel/drivers/rtc/alarm.c:#include <linux/wakelock.h>
NeoLKernel/drivers/rtc/alarm.c:static struct wake_lock alarm_rtc_wake_lock;
NeoLKernel/drivers/rtc/alarm.c:	bool is_wakeup = base == &alarms[ANDROID_ALARM_RTC_WAKEUP] ||
NeoLKernel/drivers/rtc/alarm.c:	if (is_wakeup && !suspended && head_removed)
NeoLKernel/drivers/rtc/alarm.c:		wake_unlock(&alarm_rtc_wake_lock);
NeoLKernel/drivers/rtc/alarm.c:	if (is_wakeup && suspended) {
NeoLKernel/drivers/rtc/alarm.c:		wake_lock_timeout(&alarm_rtc_wake_lock, 1 * HZ);
NeoLKernel/drivers/rtc/alarm.c:	wake_lock(&alarm_rtc_wake_lock);
NeoLKernel/drivers/rtc/alarm.c:	wake_unlock(&alarm_rtc_wake_lock);
NeoLKernel/drivers/rtc/alarm.c:	wake_lock_timeout(&alarm_rtc_wake_lock, 1 * HZ);
NeoLKernel/drivers/rtc/alarm.c:	struct alarm_queue *wakeup_queue = NULL;
NeoLKernel/drivers/rtc/alarm.c:		wakeup_queue = tmp_queue;
NeoLKernel/drivers/rtc/alarm.c:	if (tmp_queue->first && (!wakeup_queue ||
NeoLKernel/drivers/rtc/alarm.c:				hrtimer_get_expires(&wakeup_queue->timer).tv64))
NeoLKernel/drivers/rtc/alarm.c:		wakeup_queue = tmp_queue;
NeoLKernel/drivers/rtc/alarm.c:	if (wakeup_queue) {
NeoLKernel/drivers/rtc/alarm.c:			hrtimer_get_expires(&wakeup_queue->timer)),
NeoLKernel/drivers/rtc/alarm.c:			wake_lock_timeout(&alarm_rtc_wake_lock, 2 * HZ);
NeoLKernel/drivers/rtc/alarm.c:	wake_lock_init(&alarm_rtc_wake_lock, WAKE_LOCK_SUSPEND, "alarm_rtc");
NeoLKernel/drivers/rtc/alarm.c:	wake_lock_destroy(&alarm_rtc_wake_lock);
NeoLKernel/drivers/rtc/alarm.c:	wake_lock_destroy(&alarm_rtc_wake_lock);
NeoLKernel/drivers/rtc/rtc-omap.c: * and wiring RTC_WAKE_INT (so the RTC alarm can wake the system from
NeoLKernel/drivers/rtc/rtc-omap.c:	 *    should initialize the device wakeup flag appropriately.
NeoLKernel/drivers/rtc/rtc-omap.c:	device_init_wakeup(&pdev->dev, 0);
NeoLKernel/drivers/rtc/rtc-omap.c:	device_init_wakeup(&pdev->dev, 0);
NeoLKernel/drivers/rtc/rtc-omap.c:	/* FIXME the RTC alarm is not currently acting as a wakeup event
NeoLKernel/drivers/rtc/rtc-omap.c:	if (device_may_wakeup(&pdev->dev))
NeoLKernel/drivers/rtc/rtc-omap.c:		enable_irq_wake(omap_rtc_alarm);
NeoLKernel/drivers/rtc/rtc-omap.c:	if (device_may_wakeup(&pdev->dev))
NeoLKernel/drivers/rtc/rtc-omap.c:		disable_irq_wake(omap_rtc_alarm);
NeoLKernel/drivers/rtc/rtc-pm8058.c:	device_init_wakeup(&pdev->dev, 1);
NeoLKernel/drivers/rtc/rtc-pm8058.c:	if (device_may_wakeup(dev))
NeoLKernel/drivers/rtc/rtc-pm8058.c:		disable_irq_wake(rtc_dd->rtc_alarm_irq);
NeoLKernel/drivers/rtc/rtc-pm8058.c:	if (device_may_wakeup(dev))
NeoLKernel/drivers/rtc/rtc-pm8058.c:		enable_irq_wake(rtc_dd->rtc_alarm_irq);
NeoLKernel/drivers/rtc/rtc-pm8058.c:	device_init_wakeup(&pdev->dev, 0);
NeoLKernel/drivers/rtc/rtc-pxa.c:	device_init_wakeup(dev, 1);
NeoLKernel/drivers/rtc/rtc-pxa.c:	if (device_may_wakeup(dev))
NeoLKernel/drivers/rtc/rtc-pxa.c:		enable_irq_wake(pxa_rtc->irq_Alrm);
NeoLKernel/drivers/rtc/rtc-pxa.c:	if (device_may_wakeup(dev))
NeoLKernel/drivers/rtc/rtc-pxa.c:		disable_irq_wake(pxa_rtc->irq_Alrm);
NeoLKernel/drivers/rtc/rtc-ds1305.c: *   same value, letting ALM1 be the wakeup event source on DS1306
NeoLKernel/drivers/rtc/rtc-ds1374.c:	if (client->irq >= 0 && device_may_wakeup(&client->dev))
NeoLKernel/drivers/rtc/rtc-ds1374.c:		enable_irq_wake(client->irq);
NeoLKernel/drivers/rtc/rtc-ds1374.c:	if (client->irq >= 0 && device_may_wakeup(&client->dev))
NeoLKernel/drivers/rtc/rtc-ds1374.c:		disable_irq_wake(client->irq);
NeoLKernel/drivers/rtc/rtc-efi.c:	status = efi.get_wakeup_time((efi_bool_t *)&wkalrm->enabled,
NeoLKernel/drivers/rtc/rtc-efi.c:	status = efi.set_wakeup_time((efi_bool_t)wkalrm->enabled, &eft);
NeoLKernel/drivers/rtc/rtc-s3c.c:		enable_irq_wake(s3c_rtc_alarmno);
NeoLKernel/drivers/rtc/rtc-s3c.c:		disable_irq_wake(s3c_rtc_alarmno);
NeoLKernel/drivers/rtc/rtc-s3c.c:	/* do not clear AIE here, it may be needed for wake */
NeoLKernel/drivers/rtc/rtc-s3c.c:	device_init_wakeup(&pdev->dev, 1);
NeoLKernel/drivers/rtc/rtc-sa1100.c:	device_init_wakeup(&pdev->dev, 1);
NeoLKernel/drivers/rtc/rtc-sa1100.c:	if (device_may_wakeup(dev))
NeoLKernel/drivers/rtc/rtc-sa1100.c:		enable_irq_wake(IRQ_RTCAlrm);
NeoLKernel/drivers/rtc/rtc-sa1100.c:	if (device_may_wakeup(dev))
NeoLKernel/drivers/rtc/rtc-sa1100.c:		disable_irq_wake(IRQ_RTCAlrm);
NeoLKernel/drivers/rtc/rtc-sh.c:	device_init_wakeup(&pdev->dev, 1);
NeoLKernel/drivers/rtc/rtc-sh.c:static void sh_rtc_set_irq_wake(struct device *dev, int enabled)
NeoLKernel/drivers/rtc/rtc-sh.c:	set_irq_wake(rtc->periodic_irq, enabled);
NeoLKernel/drivers/rtc/rtc-sh.c:		set_irq_wake(rtc->carry_irq, enabled);
NeoLKernel/drivers/rtc/rtc-sh.c:		set_irq_wake(rtc->alarm_irq, enabled);
NeoLKernel/drivers/rtc/rtc-sh.c:	if (device_may_wakeup(dev))
NeoLKernel/drivers/rtc/rtc-sh.c:		sh_rtc_set_irq_wake(dev, 1);
NeoLKernel/drivers/rtc/rtc-sh.c:	if (device_may_wakeup(dev))
NeoLKernel/drivers/rtc/rtc-sh.c:		sh_rtc_set_irq_wake(dev, 0);
NeoLKernel/drivers/rtc/rtc-sysfs.c: * attributes including date, time, since_epoch, and wakealarm.
NeoLKernel/drivers/rtc/rtc-sysfs.c:rtc_sysfs_show_wakealarm(struct device *dev, struct device_attribute *attr,
NeoLKernel/drivers/rtc/rtc-sysfs.c:rtc_sysfs_set_wakealarm(struct device *dev, struct device_attribute *attr,
NeoLKernel/drivers/rtc/rtc-sysfs.c:static DEVICE_ATTR(wakealarm, S_IRUGO | S_IWUSR,
NeoLKernel/drivers/rtc/rtc-sysfs.c:		rtc_sysfs_show_wakealarm, rtc_sysfs_set_wakealarm);
NeoLKernel/drivers/rtc/rtc-sysfs.c:static inline int rtc_does_wakealarm(struct rtc_device *rtc)
NeoLKernel/drivers/rtc/rtc-sysfs.c:	if (!device_can_wakeup(rtc->dev.parent))
NeoLKernel/drivers/rtc/rtc-sysfs.c:	/* not all RTCs support both alarms and wakeup */
NeoLKernel/drivers/rtc/rtc-sysfs.c:	if (!rtc_does_wakealarm(rtc))
NeoLKernel/drivers/rtc/rtc-sysfs.c:	err = device_create_file(&rtc->dev, &dev_attr_wakealarm);
NeoLKernel/drivers/rtc/rtc-sysfs.c:	if (rtc_does_wakealarm(rtc))
NeoLKernel/drivers/rtc/rtc-sysfs.c:		device_remove_file(&rtc->dev, &dev_attr_wakealarm);
NeoLKernel/drivers/rtc/rtc-wm831x.c:/* Turn off the alarm if it should not be a wake source. */
NeoLKernel/drivers/rtc/rtc-wm831x.c:	if (wm831x_rtc->alarm_enabled && device_may_wakeup(&pdev->dev))
NeoLKernel/drivers/rtc/rtc-wm831x.c: * prevent use as a wake source).
NeoLKernel/drivers/rtc/rtc-wm831x.c:	device_init_wakeup(&pdev->dev, 1);
NeoLKernel/drivers/rtc/rtc-wm8350.c:	if (device_may_wakeup(&wm8350->rtc.pdev->dev) &&
NeoLKernel/drivers/rtc/rtc-wm8350.c:	device_init_wakeup(&pdev->dev, 1);
NeoLKernel/drivers/rtc/Kconfig:	  Provides non-wakeup and rtc backed wakeup alarms based on rtc or
NeoLKernel/drivers/rtc/Kconfig:	  elapsed realtime, and a non-wakeup alarm on the monotonic clock.
NeoLKernel/drivers/rtc/Kconfig:	  wakeup from Alarm.
NeoLKernel/drivers/rtc/rtc-at32ap700x.c:	device_init_wakeup(&pdev->dev, 1);
NeoLKernel/drivers/rtc/rtc-at32ap700x.c:	device_init_wakeup(&pdev->dev, 0);
NeoLKernel/drivers/rtc/rtc-at91rm9200.c:	 * being wake-capable; if it didn't, do that here.
NeoLKernel/drivers/rtc/rtc-at91rm9200.c:	if (!device_can_wakeup(&pdev->dev))
NeoLKernel/drivers/rtc/rtc-at91rm9200.c:		device_init_wakeup(&pdev->dev, 1);
NeoLKernel/drivers/rtc/rtc-at91rm9200.c:		if (device_may_wakeup(dev))
NeoLKernel/drivers/rtc/rtc-at91rm9200.c:			enable_irq_wake(AT91_ID_SYS);
NeoLKernel/drivers/rtc/rtc-at91rm9200.c:		if (device_may_wakeup(dev))
NeoLKernel/drivers/rtc/rtc-at91rm9200.c:			disable_irq_wake(AT91_ID_SYS);
NeoLKernel/drivers/rtc/rtc-at91sam9.c:	if (!device_can_wakeup(&pdev->dev))
NeoLKernel/drivers/rtc/rtc-at91sam9.c:		device_init_wakeup(&pdev->dev, 1);
NeoLKernel/drivers/rtc/rtc-at91sam9.c:	 * necessarily a wakeup event source.
NeoLKernel/drivers/rtc/rtc-at91sam9.c:		if (device_may_wakeup(&pdev->dev) && (mr & AT91_RTT_ALMIEN)) {
NeoLKernel/drivers/rtc/rtc-at91sam9.c:			enable_irq_wake(AT91_ID_SYS);
NeoLKernel/drivers/rtc/rtc-at91sam9.c:			/* don't let RTTINC cause wakeups */
NeoLKernel/drivers/rtc/rtc-at91sam9.c:		if (device_may_wakeup(&pdev->dev))
NeoLKernel/drivers/rtc/rtc-at91sam9.c:			disable_irq_wake(AT91_ID_SYS);
NeoLKernel/drivers/rtc/rtc-bfin.c: *  - process wakes up, sees WRITE PENDING bit set, goes to sleep
NeoLKernel/drivers/rtc/rtc-bfin.c:	device_init_wakeup(dev, 1);
NeoLKernel/drivers/rtc/rtc-bfin.c:	if (device_may_wakeup(&pdev->dev)) {
NeoLKernel/drivers/rtc/rtc-bfin.c:		enable_irq_wake(IRQ_RTC);
NeoLKernel/drivers/rtc/rtc-bfin.c:	if (device_may_wakeup(&pdev->dev))
NeoLKernel/drivers/rtc/rtc-bfin.c:		disable_irq_wake(IRQ_RTC);
NeoLKernel/drivers/rtc/rtc-cmos.c:	void			(*wake_on)(struct device *);
NeoLKernel/drivers/rtc/rtc-cmos.c:	void			(*wake_off)(struct device *);
NeoLKernel/drivers/rtc/rtc-cmos.c:	u8			enabled_wake;
NeoLKernel/drivers/rtc/rtc-cmos.c:	 * Similar code may be needed in system wakeup paths, in case the
NeoLKernel/drivers/rtc/rtc-cmos.c:	 * the alarm IRQ isn't automatically a wakeup IRQ (like ACPI, and
NeoLKernel/drivers/rtc/rtc-cmos.c:		if (info->wake_on && info->wake_off) {
NeoLKernel/drivers/rtc/rtc-cmos.c:			cmos_rtc.wake_on = info->wake_on;
NeoLKernel/drivers/rtc/rtc-cmos.c:			cmos_rtc.wake_off = info->wake_off;
NeoLKernel/drivers/rtc/rtc-cmos.c:	/* only the alarm might be a wakeup event source */
NeoLKernel/drivers/rtc/rtc-cmos.c:		if (device_may_wakeup(dev))
NeoLKernel/drivers/rtc/rtc-cmos.c:		cmos->enabled_wake = 1;
NeoLKernel/drivers/rtc/rtc-cmos.c:		if (cmos->wake_on)
NeoLKernel/drivers/rtc/rtc-cmos.c:			cmos->wake_on(dev);
NeoLKernel/drivers/rtc/rtc-cmos.c:			enable_irq_wake(cmos->irq);
NeoLKernel/drivers/rtc/rtc-cmos.c:			(tmp & RTC_AIE) ? ", alarm may wake" : "",
NeoLKernel/drivers/rtc/rtc-cmos.c:/* We want RTC alarms to wake us from e.g. ACPI G2/S5 "soft off", even
NeoLKernel/drivers/rtc/rtc-cmos.c: * says wakeup should only work from G1/S4 "hibernate".  To most users,
NeoLKernel/drivers/rtc/rtc-cmos.c:		if (cmos->enabled_wake) {
NeoLKernel/drivers/rtc/rtc-cmos.c:			if (cmos->wake_off)
NeoLKernel/drivers/rtc/rtc-cmos.c:				cmos->wake_off(dev);
NeoLKernel/drivers/rtc/rtc-cmos.c:				disable_irq_wake(cmos->irq);
NeoLKernel/drivers/rtc/rtc-cmos.c:			cmos->enabled_wake = 0;
NeoLKernel/drivers/rtc/rtc-cmos.c:			 * the wake alarm's irq
NeoLKernel/drivers/rtc/rtc-cmos.c:static inline void rtc_wake_setup(void)
NeoLKernel/drivers/rtc/rtc-cmos.c:static void rtc_wake_on(struct device *dev)
NeoLKernel/drivers/rtc/rtc-cmos.c:static void rtc_wake_off(struct device *dev)
NeoLKernel/drivers/rtc/rtc-cmos.c:#define rtc_wake_setup()	do{}while(0)
NeoLKernel/drivers/rtc/rtc-cmos.c:#define rtc_wake_on		NULL
NeoLKernel/drivers/rtc/rtc-cmos.c:#define rtc_wake_off		NULL
NeoLKernel/drivers/rtc/rtc-cmos.c: * that this board's RTC is wakeup-capable (per ACPI spec).
NeoLKernel/drivers/rtc/rtc-cmos.c:cmos_wake_setup(struct device *dev)
NeoLKernel/drivers/rtc/rtc-cmos.c:	rtc_wake_setup();
NeoLKernel/drivers/rtc/rtc-cmos.c:	acpi_rtc_info.wake_on = rtc_wake_on;
NeoLKernel/drivers/rtc/rtc-cmos.c:	acpi_rtc_info.wake_off = rtc_wake_off;
NeoLKernel/drivers/rtc/rtc-cmos.c:		dev_info(dev, "RTC can wake from S4\n");
NeoLKernel/drivers/rtc/rtc-cmos.c:	/* RTC always wakes from S1/S2/S3, and often S4/STD */
NeoLKernel/drivers/rtc/rtc-cmos.c:	device_init_wakeup(dev, 1);
NeoLKernel/drivers/rtc/rtc-cmos.c:cmos_wake_setup(struct device *dev)
NeoLKernel/drivers/rtc/rtc-cmos.c:	cmos_wake_setup(&pnp->dev);
NeoLKernel/drivers/rtc/rtc-cmos.c:	cmos_wake_setup(&pdev->dev);
NeoLKernel/drivers/rtc/rtc-coh901331.c:	if (device_may_wakeup(&pdev->dev)) {
NeoLKernel/drivers/rtc/rtc-coh901331.c:		enable_irq_wake(rtap->irq);
NeoLKernel/drivers/rtc/rtc-coh901331.c:	if (device_may_wakeup(&pdev->dev))
NeoLKernel/drivers/rtc/rtc-coh901331.c:		disable_irq_wake(rtap->irq);
NeoLKernel/drivers/rtc/rtc-dev.c:	 * Leave the alarm alone; it may be set to trigger a system wakeup
NeoLKernel/drivers/s390/block/dasd.c:		wake_up(&dasd_init_waitq);
NeoLKernel/drivers/s390/block/dasd.c:			wake_up(&dasd_init_waitq);
NeoLKernel/drivers/s390/block/dasd.c:		wake_up(&dasd_flush_wq);
NeoLKernel/drivers/s390/block/dasd.c:static void dasd_wakeup_cb(struct dasd_ccw_req *cqr, void *data)
NeoLKernel/drivers/s390/block/dasd.c:	wake_up((wait_queue_head_t *) data);
NeoLKernel/drivers/s390/block/dasd.c:static inline int _wait_for_wakeup(struct dasd_ccw_req *cqr)
NeoLKernel/drivers/s390/block/dasd.c:	cqr->callback = dasd_wakeup_cb;
NeoLKernel/drivers/s390/block/dasd.c:	wait_event(generic_waitq, _wait_for_wakeup(cqr));
NeoLKernel/drivers/s390/block/dasd.c:	cqr->callback = dasd_wakeup_cb;
NeoLKernel/drivers/s390/block/dasd.c:	rc = wait_event_interruptible(generic_waitq, _wait_for_wakeup(cqr));
NeoLKernel/drivers/s390/block/dasd.c:		wait_event(generic_waitq, _wait_for_wakeup(cqr));
NeoLKernel/drivers/s390/block/dasd.c:	cqr->callback = dasd_wakeup_cb;
NeoLKernel/drivers/s390/block/dasd.c:	wait_event(generic_waitq, _wait_for_wakeup(cqr));
NeoLKernel/drivers/s390/block/dasd.c:static void _dasd_wake_block_flush_cb(struct dasd_ccw_req *cqr, void *data)
NeoLKernel/drivers/s390/block/dasd.c:	wake_up(&dasd_flush_wq);
NeoLKernel/drivers/s390/block/dasd.c:		cqr->callback = _dasd_wake_block_flush_cb;
NeoLKernel/drivers/s390/block/dasd_devmap.c:dasd_put_device_wake(struct dasd_device *device)
NeoLKernel/drivers/s390/block/dasd_devmap.c:	wake_up(&dasd_delete_wq);
NeoLKernel/drivers/s390/block/dasd_eer.c:	wake_up_interruptible(&dasd_eer_read_wait_queue);
NeoLKernel/drivers/s390/block/dasd_eer.c:	wake_up_interruptible(&dasd_eer_read_wait_queue);
NeoLKernel/drivers/s390/block/dasd_int.h:void dasd_put_device_wake(struct dasd_device *);
NeoLKernel/drivers/s390/block/dasd_int.h:		dasd_put_device_wake(device);
NeoLKernel/drivers/s390/char/sclp_tty.c:	/* check if the tty needs a wake up call */
NeoLKernel/drivers/s390/char/sclp_tty.c:		tty_wakeup(sclp_tty);
NeoLKernel/drivers/s390/char/con3215.c:#define RAW3215_MIN_SPACE   128	      /* minimum free space for wakeup */
NeoLKernel/drivers/s390/char/con3215.c: * Try to start the next IO and wake up processes waiting on the tty.
NeoLKernel/drivers/s390/char/con3215.c:	    	tty_wakeup(tty);
NeoLKernel/drivers/s390/char/con3215.c:			wake_up_interruptible(&raw->empty_wait);
NeoLKernel/drivers/s390/char/con3215.c:	tty_wakeup(tty);
NeoLKernel/drivers/s390/char/fs3270.c:fs3270_wake_up(struct raw3270_request *rq, void *data)
NeoLKernel/drivers/s390/char/fs3270.c:	wake_up((wait_queue_head_t *) data);
NeoLKernel/drivers/s390/char/fs3270.c:	rq->callback = fs3270_wake_up;
NeoLKernel/drivers/s390/char/fs3270.c:	wake_up(&fp->wait);
NeoLKernel/drivers/s390/char/fs3270.c:	wake_up(&fp->wait);
NeoLKernel/drivers/s390/char/fs3270.c:	wake_up(&fp->wait);
NeoLKernel/drivers/s390/char/fs3270.c:	/* Handle ATTN. Set indication and wake waiters for attention. */
NeoLKernel/drivers/s390/char/fs3270.c:		wake_up(&fp->wait);
NeoLKernel/drivers/s390/char/monreader.c:	wake_up(&mon_conn_wait_queue);
NeoLKernel/drivers/s390/char/monreader.c:	wake_up(&mon_conn_wait_queue);
NeoLKernel/drivers/s390/char/monreader.c:	wake_up_interruptible(&mon_read_wait_queue);
NeoLKernel/drivers/s390/char/monreader.c:	wake_up_interruptible(&mon_read_wait_queue);
NeoLKernel/drivers/s390/char/raw3270.c:		wake_up(&raw3270_wait_queue);
NeoLKernel/drivers/s390/char/raw3270.c: * raw3270_wait/raw3270_wait_interruptible/__raw3270_wakeup
NeoLKernel/drivers/s390/char/raw3270.c:raw3270_wake_init(struct raw3270_request *rq, void *data)
NeoLKernel/drivers/s390/char/raw3270.c:	wake_up((wait_queue_head_t *) data);
NeoLKernel/drivers/s390/char/raw3270.c:	rq->callback = raw3270_wake_init;
NeoLKernel/drivers/s390/char/raw3270.h:		wake_up(&raw3270_wait_queue);
NeoLKernel/drivers/s390/char/sclp_sdias.c:	wake_up(&sdias_wq); /* Inform caller, that request is complete */
NeoLKernel/drivers/s390/char/sclp_vt220.c:	/* Check if the tty needs a wake up call */
NeoLKernel/drivers/s390/char/sclp_vt220.c:		tty_wakeup(sclp_vt220_tty);
NeoLKernel/drivers/s390/char/tape_3590.c: * The done handler is called at device/channel end and wakes up the sleeping
NeoLKernel/drivers/s390/char/tape_core.c:	wake_up(&device->state_change_wq);
NeoLKernel/drivers/s390/char/tape_core.c:	wake_up(&device->state_change_wq);
NeoLKernel/drivers/s390/char/tape_core.c: * tape_do_io/__tape_wake_up
NeoLKernel/drivers/s390/char/tape_core.c:__tape_wake_up(struct tape_request *request, void *data)
NeoLKernel/drivers/s390/char/tape_core.c:	wake_up((wait_queue_head_t *) data);
NeoLKernel/drivers/s390/char/tape_core.c:	request->callback = __tape_wake_up;
NeoLKernel/drivers/s390/char/tape_core.c: * tape_do_io_interruptible/__tape_wake_up_interruptible
NeoLKernel/drivers/s390/char/tape_core.c:__tape_wake_up_interruptible(struct tape_request *request, void *data)
NeoLKernel/drivers/s390/char/tape_core.c:	wake_up_interruptible((wait_queue_head_t *) data);
NeoLKernel/drivers/s390/char/tape_core.c:	request->callback = __tape_wake_up_interruptible;
NeoLKernel/drivers/s390/char/vmlogrdr.c:	wake_up(&conn_wait_queue);
NeoLKernel/drivers/s390/char/vmlogrdr.c:	wake_up(&conn_wait_queue);
NeoLKernel/drivers/s390/char/vmlogrdr.c:	wake_up_interruptible(&read_wait_queue);
NeoLKernel/drivers/s390/char/vmlogrdr.c:	wake_up_interruptible(&read_wait_queue);
NeoLKernel/drivers/s390/char/vmur.c: * and complete()s the io_done to wake the waiting do_ur_io.
NeoLKernel/drivers/s390/char/vmur.c:	wake_up_interruptible(&urf->urd->wait);
NeoLKernel/drivers/s390/cio/device_fsm.c:		wake_up(&cdev->private->wait_q);
NeoLKernel/drivers/s390/cio/device_fsm.c:		wake_up(&cdev->private->wait_q);
NeoLKernel/drivers/s390/cio/device_fsm.c:			wake_up(&cdev->private->wait_q);
NeoLKernel/drivers/s390/cio/device_fsm.c:			wake_up(&cdev->private->wait_q);
NeoLKernel/drivers/s390/cio/device_fsm.c:	wake_up(&cdev->private->wait_q);
NeoLKernel/drivers/s390/cio/device_fsm.c:	wake_up(&cdev->private->wait_q);
NeoLKernel/drivers/s390/cio/device_fsm.c:	wake_up(&cdev->private->wait_q);
NeoLKernel/drivers/s390/cio/device_fsm.c:			goto out_wakeup;
NeoLKernel/drivers/s390/cio/device_fsm.c:out_wakeup:
NeoLKernel/drivers/s390/cio/device_fsm.c:	wake_up(&cdev->private->wait_q);
NeoLKernel/drivers/s390/cio/device_fsm.c:	wake_up(&cdev->private->wait_q);
NeoLKernel/drivers/s390/cio/device_fsm.c:		wake_up(&cdev->private->wait_q);
NeoLKernel/drivers/s390/cio/device_fsm.c:		wake_up(&cdev->private->wait_q);
NeoLKernel/drivers/s390/cio/chp.c:		wake_up_interruptible(&cfg_wait_queue);
NeoLKernel/drivers/s390/cio/cmf.c:	wake_up(&set_data->wait);
NeoLKernel/drivers/s390/cio/cmf.c:	wake_up(&copy_block->wait);
NeoLKernel/drivers/s390/cio/css.c:		wake_up(&css_eval_wq);
NeoLKernel/drivers/s390/cio/device.c:	wake_up(&cdev->private->wait_q);
NeoLKernel/drivers/s390/cio/device.c:		wake_up(&ccw_device_init_wq);
NeoLKernel/drivers/s390/cio/device.c:			wake_up(&ccw_device_init_wq);
NeoLKernel/drivers/s390/cio/device.c:			wake_up(&ccw_device_init_wq);
NeoLKernel/drivers/s390/cio/qdio_main.c:			wake_up(&cdev->private->wait_q);
NeoLKernel/drivers/s390/cio/qdio_main.c:	wake_up(&cdev->private->wait_q);
NeoLKernel/drivers/s390/crypto/ap_bus.c:			wake_up(&ap_poll_wait);
NeoLKernel/drivers/s390/net/claw.c:	netif_wake_queue(dev);
NeoLKernel/drivers/s390/net/claw.c:	netif_wake_queue(dev);
NeoLKernel/drivers/s390/net/claw.c:		wake_up(&p_ch->wait);   /* wake up claw_release */
NeoLKernel/drivers/s390/net/claw.c:			wake_up(&p_ch->wait); /* wake claw_open (READ)*/
NeoLKernel/drivers/s390/net/claw.c:        wake_up(&p_ch->wait);
NeoLKernel/drivers/s390/net/claw.c:			wake_up(&p_ch->wait);  /* wake up claw_open ( WRITE) */
NeoLKernel/drivers/s390/net/claw.c:			wake_up(&p_ch->wait);
NeoLKernel/drivers/s390/net/claw.h:#define CLAW_TIMER      0x80      /* - Set if timer made the wake_up  */
NeoLKernel/drivers/s390/net/ctcm_main.h:	netif_wake_queue(dev);
NeoLKernel/drivers/s390/net/lcs.c:	wake_up(&card->wait_q);
NeoLKernel/drivers/s390/net/lcs.c:        wake_up(&card->wait_q);
NeoLKernel/drivers/s390/net/lcs.c:			wake_up(&reply->wait_q);
NeoLKernel/drivers/s390/net/lcs.c:			wake_up(&reply->wait_q);
NeoLKernel/drivers/s390/net/lcs.c:		netif_wake_queue(card->dev);
NeoLKernel/drivers/s390/net/lcs.c:		wake_up(&card->wait_q);
NeoLKernel/drivers/s390/net/lcs.c:	wake_up(&channel->wait_q);
NeoLKernel/drivers/s390/net/lcs.c:		netif_wake_queue(card->dev);
NeoLKernel/drivers/s390/net/lcs.c:	netif_wake_queue(card->dev);
NeoLKernel/drivers/s390/net/lcs.c:		netif_wake_queue(dev);
NeoLKernel/drivers/s390/net/lcs.c:		netif_wake_queue(card->dev);
NeoLKernel/drivers/s390/net/netiucv.c:	netif_wake_queue(dev);
NeoLKernel/drivers/s390/net/qeth_core_main.c:	wake_up(&card->wait_q);
NeoLKernel/drivers/s390/net/qeth_core_main.c:		netif_wake_queue(card->dev);
NeoLKernel/drivers/s390/net/qeth_core_main.c:		wake_up(&card->wait_q);
NeoLKernel/drivers/s390/net/qeth_core_main.c:		wake_up(&reply->wait_q);
NeoLKernel/drivers/s390/net/qeth_core_main.c:				wake_up(&reply->wait_q);
NeoLKernel/drivers/s390/net/qeth_core_main.c:	wake_up(&card->wait_q);
NeoLKernel/drivers/s390/net/qeth_core_main.c:	wake_up(&card->wait_q);
NeoLKernel/drivers/s390/net/qeth_core_main.c:				wake_up(&card->wait_q);
NeoLKernel/drivers/s390/net/qeth_core_main.c:	/*let's wake up immediately on data channel*/
NeoLKernel/drivers/s390/net/qeth_core_main.c:	wake_up(&card->wait_q);
NeoLKernel/drivers/s390/net/qeth_core_main.c:		wake_up(&card->wait_q);
NeoLKernel/drivers/s390/net/qeth_core_main.c:		wake_up(&card->wait_q);
NeoLKernel/drivers/s390/net/qeth_core_main.c:		wake_up(&card->wait_q);
NeoLKernel/drivers/s390/net/qeth_core_main.c:	wake_up(&reply->wait_q);
NeoLKernel/drivers/s390/net/qeth_core_main.c:				 * will wake at some time in the future then we
NeoLKernel/drivers/s390/net/qeth_core_main.c:	netif_wake_queue(queue->card->dev);
NeoLKernel/drivers/s390/net/qeth_l2_main.c:	netif_wake_queue(dev);
NeoLKernel/drivers/s390/net/qeth_l2_main.c:	netif_wake_queue(dev);
NeoLKernel/drivers/s390/net/qeth_l2_main.c:		wake_up(&card->wait_q);
NeoLKernel/drivers/s390/net/qeth_l3_main.c:	netif_wake_queue(dev);
NeoLKernel/drivers/s390/net/qeth_l3_main.c:	netif_wake_queue(dev);
NeoLKernel/drivers/s390/scsi/zfcp_def.h:		wake_up(&unit->remove_wq);
NeoLKernel/drivers/s390/scsi/zfcp_def.h:		wake_up(&port->remove_wq);
NeoLKernel/drivers/s390/scsi/zfcp_def.h:		wake_up(&adapter->remove_wq);
NeoLKernel/drivers/s390/scsi/zfcp_erp.c:	wake_up(&adapter->erp_ready_wq);
NeoLKernel/drivers/s390/scsi/zfcp_erp.c:	wake_up(&adapter->erp_ready_wq);
NeoLKernel/drivers/s390/scsi/zfcp_erp.c:static void zfcp_erp_wakeup(struct zfcp_adapter *adapter)
NeoLKernel/drivers/s390/scsi/zfcp_erp.c:			wake_up(&adapter->erp_done_wqh);
NeoLKernel/drivers/s390/scsi/zfcp_erp.c:				zfcp_erp_wakeup(adapter);
NeoLKernel/drivers/s390/scsi/zfcp_fc.c:		wake_up(&wka_port->completion_wq);
NeoLKernel/drivers/s390/scsi/zfcp_fsf.c:	wake_up(&wka_port->completion_wq);
NeoLKernel/drivers/s390/scsi/zfcp_fsf.c:	wake_up(&wka_port->completion_wq);
NeoLKernel/drivers/s390/scsi/zfcp_qdio.c:	wake_up(&qdio->req_q_wq);
NeoLKernel/drivers/gpio/gpiolib.c:			 * and set_irq_wake() ... but those are "rare".
NeoLKernel/drivers/gpio/gpiolib.c:						? " wakeup" : "");
NeoLKernel/drivers/gpu/drm/drm_bufs.c:			wake_up_interruptible_all(&master->lock.lock_queue);
NeoLKernel/drivers/gpu/drm/drm_context.c: * hardware lock is held, clears the drm_device::context_flag and wakes up
NeoLKernel/drivers/gpu/drm/drm_context.c:	wake_up(&dev->context_wait);
NeoLKernel/drivers/gpu/drm/drm_dma.c:		wake_up_interruptible(&buf->dma_wait);
NeoLKernel/drivers/gpu/drm/drm_fops.c:			wake_up_interruptible_all(&master->lock.lock_queue);
NeoLKernel/drivers/gpu/drm/drm_lock.c:	wake_up_interruptible(&lock_data->lock_queue);
NeoLKernel/drivers/gpu/drm/drm_lock.c:			wake_up_interruptible(&lock_data->lock_queue);
NeoLKernel/drivers/gpu/drm/i830/i830_irq.c:	wake_up_interruptible(&dev_priv->irq_queue);
NeoLKernel/drivers/gpu/drm/i915/i915_irq.c:	 * rendering.  The problem was that the kernel might wake the client
NeoLKernel/drivers/gpu/drm/radeon/radeon_fence.c:	bool wake = false;
NeoLKernel/drivers/gpu/drm/radeon/radeon_fence.c:		wake = true;
NeoLKernel/drivers/gpu/drm/radeon/radeon_fence.c:	return wake;
NeoLKernel/drivers/gpu/drm/radeon/radeon_fence.c:	bool wake;
NeoLKernel/drivers/gpu/drm/radeon/radeon_fence.c:	wake = radeon_fence_poll_locked(rdev);
NeoLKernel/drivers/gpu/drm/radeon/radeon_fence.c:	if (wake) {
NeoLKernel/drivers/gpu/drm/radeon/radeon_fence.c:		wake_up_all(&rdev->fence_drv.queue);
NeoLKernel/drivers/gpu/drm/radeon/radeon_fence.c:	wake_up_all(&rdev->fence_drv.queue);
NeoLKernel/drivers/gpu/drm/ttm/ttm_bo.c:	wake_up_all(&bo->event_queue);
NeoLKernel/drivers/gpu/drm/ttm/ttm_bo.c:	wake_up_all(&bo->event_queue);
NeoLKernel/drivers/gpu/drm/ttm/ttm_bo.c:		wake_up_all(&bo->event_queue);
NeoLKernel/drivers/gpu/drm/ttm/ttm_bo.c:	wake_up_all(&bo->event_queue);
NeoLKernel/drivers/gpu/drm/ttm/ttm_module.c:	wake_up_all(&exit_q);
NeoLKernel/drivers/gpu/drm/ttm/ttm_module.c:	wake_up_all(&exit_q);
NeoLKernel/drivers/gpu/drm/via/via_dmablit.c: * Also wakes up waiting processes. Each of these tasks handles one
NeoLKernel/drivers/gpu/msm/kgsl_device.h:#include <linux/wakelock.h>
NeoLKernel/drivers/gpu/msm/kgsl_device.h:	struct wake_lock idle_wakelock;
NeoLKernel/drivers/gpu/msm/adreno_a2xx.c:			 * As a precaution just wake up processes so
NeoLKernel/drivers/gpu/msm/adreno_a2xx.c:			wake_up_interruptible_all(&device->wait_queue);
NeoLKernel/drivers/gpu/msm/adreno_a2xx.c:		wake_up_interruptible_all(&device->wait_queue);
NeoLKernel/drivers/gpu/msm/kgsl_drm.c:				wake_up_interruptible(
NeoLKernel/drivers/gpu/msm/kgsl_drm.c:wakeup_fence_entries(struct drm_kgsl_gem_object_fence *fence)
NeoLKernel/drivers/gpu/msm/kgsl_drm.c:			wake_up_interruptible(&lock_next->process_wait_q);
NeoLKernel/drivers/gpu/msm/kgsl_drm.c:			wakeup_fence_entries(fence);
NeoLKernel/drivers/gpu/msm/kgsl_pwrctrl.c:		kgsl_pwrctrl_wake(device);
NeoLKernel/drivers/gpu/msm/kgsl_pwrctrl.c:	wake_unlock(&device->idle_wakelock);
NeoLKernel/drivers/gpu/msm/kgsl_pwrctrl.c:void kgsl_pwrctrl_wake(struct kgsl_device *device)
NeoLKernel/drivers/gpu/msm/kgsl_pwrctrl.c:		kgsl_pwrscale_wake(device);
NeoLKernel/drivers/gpu/msm/kgsl_pwrctrl.c:	wake_lock(&device->idle_wakelock);
NeoLKernel/drivers/gpu/msm/kgsl_pwrctrl.c:	KGSL_PWR_INFO(device, "wake return for device %d\n", device->id);
NeoLKernel/drivers/gpu/msm/kgsl_pwrctrl.c:EXPORT_SYMBOL(kgsl_pwrctrl_wake);
NeoLKernel/drivers/gpu/msm/kgsl_pwrctrl.h:void kgsl_pwrctrl_wake(struct kgsl_device *device);
NeoLKernel/drivers/gpu/msm/kgsl_pwrscale.c:void kgsl_pwrscale_wake(struct kgsl_device *device)
NeoLKernel/drivers/gpu/msm/kgsl_pwrscale.c:	if (device->pwrscale.policy && device->pwrscale.policy->wake)
NeoLKernel/drivers/gpu/msm/kgsl_pwrscale.c:		device->pwrscale.policy->wake(device, &device->pwrscale);
NeoLKernel/drivers/gpu/msm/kgsl_pwrscale.c:EXPORT_SYMBOL(kgsl_pwrscale_wake);
NeoLKernel/drivers/gpu/msm/kgsl_pwrscale.h:	void (*wake)(struct kgsl_device *device,
NeoLKernel/drivers/gpu/msm/kgsl_pwrscale.h:void kgsl_pwrscale_wake(struct kgsl_device *device);
NeoLKernel/drivers/gpu/msm/kgsl_pwrscale_idlestats.c:	/* If the GPU is asleep, don't wake it up - assume that we
NeoLKernel/drivers/gpu/msm/kgsl_pwrscale_trustzone.c:static void tz_wake(struct kgsl_device *device, struct kgsl_pwrscale *pwrscale)
NeoLKernel/drivers/gpu/msm/kgsl_pwrscale_trustzone.c:	.wake = tz_wake,
NeoLKernel/drivers/gpu/msm/z180.c:			wake_up_interruptible(&device->wait_queue);
NeoLKernel/drivers/gpu/msm/adreno_postmortem.c:	kgsl_pwrctrl_wake(device);
NeoLKernel/drivers/gpu/msm/kgsl.c:	/* Don't let the timer wake us during suspended sleep. */
NeoLKernel/drivers/gpu/msm/kgsl.c:			"Runtime PM: Unable to wake up the device, rc = %d\n",
NeoLKernel/drivers/gpu/msm/kgsl.c:	wake_lock_destroy(&device->idle_wakelock);
NeoLKernel/drivers/gpu/msm/kgsl.c:	wake_lock_init(&device->idle_wakelock, WAKE_LOCK_IDLE, device->name);
NeoLKernel/drivers/gpu/vga/vgaarb.c:		wake_up_all(&vga_wait_queue);
NeoLKernel/drivers/gpu/vga/vgaarb.c:	wake_up_all(&vga_wait_queue);
NeoLKernel/drivers/hid/hid-debug.c:        wake_up_interruptible(&hdev->debug_wait);
NeoLKernel/drivers/hid/hid-debug.c:	wake_up_interruptible(&hdev->debug_wait);
NeoLKernel/drivers/hid/hidraw.c:	wake_up_interruptible(&dev->wait);
NeoLKernel/drivers/hid/hidraw.c:		wake_up_interruptible(&hidraw->wait);
NeoLKernel/drivers/hid/usbhid/hid-core.c:static struct workqueue_struct *resumption_waker;
NeoLKernel/drivers/hid/usbhid/hid-core.c:			wake_up(&usbhid->wait);
NeoLKernel/drivers/hid/usbhid/hid-core.c:			wake_up(&usbhid->wait);
NeoLKernel/drivers/hid/usbhid/hid-core.c:		 * because most keyboards don't wake up when
NeoLKernel/drivers/hid/usbhid/hid-core.c:		 * queue work to wake up the device.
NeoLKernel/drivers/hid/usbhid/hid-core.c:		queue_work(resumption_waker, &usbhid->restart_work);
NeoLKernel/drivers/hid/usbhid/hid-core.c:		 * queue work to wake up the device.
NeoLKernel/drivers/hid/usbhid/hid-core.c:		queue_work(resumption_waker, &usbhid->restart_work);
NeoLKernel/drivers/hid/usbhid/hid-core.c:			wake_up(&usbhid->wait);
NeoLKernel/drivers/hid/usbhid/hid-core.c:	wake_up(&usbhid->wait);
NeoLKernel/drivers/hid/usbhid/hid-core.c:			wake_up(&usbhid->wait);
NeoLKernel/drivers/hid/usbhid/hid-core.c:	wake_up(&usbhid->wait);
NeoLKernel/drivers/hid/usbhid/hid-core.c:		/* the device must be awake to reliable request remote wakeup */
NeoLKernel/drivers/hid/usbhid/hid-core.c:		usbhid->intf->needs_remote_wakeup = 1;
NeoLKernel/drivers/hid/usbhid/hid-core.c:		usbhid->intf->needs_remote_wakeup = 0;
NeoLKernel/drivers/hid/usbhid/hid-core.c:	resumption_waker = create_freezeable_workqueue("usbhid_resumer");
NeoLKernel/drivers/hid/usbhid/hid-core.c:	if (!resumption_waker)
NeoLKernel/drivers/hid/usbhid/hid-core.c:	destroy_workqueue(resumption_waker);
NeoLKernel/drivers/hid/usbhid/hid-core.c:	destroy_workqueue(resumption_waker);
NeoLKernel/drivers/hid/usbhid/hiddev.c:	wake_up_interruptible(&hiddev->wait);
NeoLKernel/drivers/hid/usbhid/hiddev.c:		wake_up_interruptible(&hiddev->wait);
NeoLKernel/drivers/hwmon/msm_adc.c:			wake_up_interruptible_all(&client->outst_wait);
NeoLKernel/drivers/hwmon/msm_adc.c:		wake_up_interruptible_all(&client->data_wait);
NeoLKernel/drivers/hwmon/msm_adc.c:			wake_up_interruptible_all(&msm_adc->total_outst_wait);
NeoLKernel/drivers/hwmon/sht15.c:	wake_up(&data->wait_queue);
NeoLKernel/drivers/hwmon/lis3lv02d.c:	wake_up_interruptible(&lis3_dev.misc_wait);
NeoLKernel/drivers/hwmon/lis3lv02d.c:		if (p->wakeup_flags && (dev->whoami == LIS_SINGLE_ID)) {
NeoLKernel/drivers/hwmon/lis3lv02d.c:			dev->write(dev, FF_WU_CFG_1, p->wakeup_flags);
NeoLKernel/drivers/hwmon/lis3lv02d.c:			dev->write(dev, FF_WU_THS_1, p->wakeup_thresh & 0x7f);
NeoLKernel/drivers/hwmon/lis3lv02d_spi.c:	if (!lis3->pdata->wakeup_flags)
NeoLKernel/drivers/hwmon/lis3lv02d_spi.c:	if (!lis3->pdata->wakeup_flags)
NeoLKernel/drivers/i2c/busses/i2c-ocores.c:		wake_up(&i2c->wait);
NeoLKernel/drivers/i2c/busses/i2c-cpm.c:	wake_up(&cpm->i2c_wait);
NeoLKernel/drivers/i2c/busses/i2c-elektor.c:	wake_up_interruptible(&pcf_wait);
NeoLKernel/drivers/i2c/busses/i2c-ibm_iic.c:	/* Acknowledge IRQ and wakeup iic_wait_for_tc */
NeoLKernel/drivers/i2c/busses/i2c-ibm_iic.c:	wake_up_interruptible(&dev->wq);
NeoLKernel/drivers/i2c/busses/i2c-imx.c:		wake_up_interruptible(&i2c_imx->queue);
NeoLKernel/drivers/i2c/busses/i2c-iop3xx.c:		wake_up_interruptible(&iop3xx_adap->waitq);
NeoLKernel/drivers/i2c/busses/i2c-mpc.c:		wake_up(&i2c->queue);
NeoLKernel/drivers/i2c/busses/i2c-msm.c:#include <linux/wakelock.h>
NeoLKernel/drivers/i2c/busses/i2c-msm.c:	struct wake_lock             wakelock;
NeoLKernel/drivers/i2c/busses/i2c-msm.c:	wake_lock(&dev->wakelock);
NeoLKernel/drivers/i2c/busses/i2c-msm.c:		wake_unlock(&dev->wakelock);
NeoLKernel/drivers/i2c/busses/i2c-msm.c:		 * and wake us up with dev->err set if there was an error
NeoLKernel/drivers/i2c/busses/i2c-msm.c:	wake_unlock(&dev->wakelock);
NeoLKernel/drivers/i2c/busses/i2c-msm.c:	wake_lock_init(&dev->wakelock, WAKE_LOCK_SUSPEND, "msm-i2c");
NeoLKernel/drivers/i2c/busses/i2c-msm.c:	wake_lock_destroy(&dev->wakelock);
NeoLKernel/drivers/i2c/busses/i2c-mv64xxx.c:		wake_up_interruptible(&drv_data->waitq);
NeoLKernel/drivers/i2c/busses/i2c-mv64xxx.c:		wake_up_interruptible(&drv_data->waitq);
NeoLKernel/drivers/i2c/busses/i2c-omap.c:/* For OMAP3 I2C_IV has changed to I2C_WE (wakeup enable) */
NeoLKernel/drivers/i2c/busses/i2c-omap.c:/* I2C WE wakeup enable register */
NeoLKernel/drivers/i2c/busses/i2c-omap.c:#define OMAP_I2C_WE_RDR_WE	(1 << 13)	/* RX drain wakeup */
NeoLKernel/drivers/i2c/busses/i2c-omap.c:#define OMAP_I2C_WE_AAS_WE	(1 << 9)	/* Address as slave wakeup*/
NeoLKernel/drivers/i2c/busses/i2c-omap.c:#define OMAP_I2C_WE_BF_WE	(1 << 8)	/* Bus free wakeup */
NeoLKernel/drivers/i2c/busses/i2c-omap.c:#define OMAP_I2C_WE_STC_WE	(1 << 6)	/* Start condition wakeup */
NeoLKernel/drivers/i2c/busses/i2c-omap.c:#define OMAP_I2C_WE_GC_WE	(1 << 5)	/* General call wakeup */
NeoLKernel/drivers/i2c/busses/i2c-omap.c:#define OMAP_I2C_WE_DRDY_WE	(1 << 3)	/* TX/RX data ready wakeup */
NeoLKernel/drivers/i2c/busses/i2c-omap.c:#define OMAP_I2C_WE_ARDY_WE	(1 << 2)	/* Reg access ready wakeup */
NeoLKernel/drivers/i2c/busses/i2c-omap.c:#define OMAP_I2C_WE_NACK_WE	(1 << 1)	/* No acknowledgment wakeup */
NeoLKernel/drivers/i2c/busses/i2c-omap.c:#define OMAP_I2C_WE_AL_WE	(1 << 0)	/* Arbitration lost wakeup */
NeoLKernel/drivers/i2c/busses/i2c-pca-isa.c:	wake_up(&pca_wait);
NeoLKernel/drivers/i2c/busses/i2c-pca-platform.c:	wake_up(&i2c->wait);
NeoLKernel/drivers/i2c/busses/i2c-pxa.c: * i2c_pxa_master_complete - complete the message and wake up.
NeoLKernel/drivers/i2c/busses/i2c-pxa.c:		wake_up(&i2c->wait);
NeoLKernel/drivers/i2c/busses/i2c-s3c2410.c: * complete the message and wake up the caller, using the given return code,
NeoLKernel/drivers/i2c/busses/i2c-s3c2410.c:	wake_up(&i2c->wait);
NeoLKernel/drivers/i2c/busses/i2c-sh_mobile.c:	int wakeup;
NeoLKernel/drivers/i2c/busses/i2c-sh_mobile.c:		wakeup = 0;
NeoLKernel/drivers/i2c/busses/i2c-sh_mobile.c:		wakeup = sh_mobile_i2c_isr_rx(pd);
NeoLKernel/drivers/i2c/busses/i2c-sh_mobile.c:		wakeup = sh_mobile_i2c_isr_tx(pd);
NeoLKernel/drivers/i2c/busses/i2c-sh_mobile.c:	if (wakeup) {
NeoLKernel/drivers/i2c/busses/i2c-sh_mobile.c:		wake_up(&pd->wait);
NeoLKernel/drivers/i2c/busses/i2c-sh_mobile.c:		/* the interrupt handler may wake us up before the
NeoLKernel/drivers/i2c/busses/i2c-taos-evm.c:			wake_up_interruptible(&wq);
NeoLKernel/drivers/i2c/busses/i2c-taos-evm.c:		wake_up_interruptible(&wq);
NeoLKernel/drivers/i2c/busses/i2c-taos-evm.c:			wake_up_interruptible(&wq);
NeoLKernel/drivers/i2c/chips/a1026.c:static ssize_t chk_wakeup_a1026(void)
NeoLKernel/drivers/i2c/chips/a1026.c:		gpio_set_value(pdata->gpio_a1026_wakeup, 0);
NeoLKernel/drivers/i2c/chips/a1026.c:		gpio_set_value(pdata->gpio_a1026_wakeup, 1);
NeoLKernel/drivers/i2c/chips/a1026.c:			goto wakeup_sync_err;
NeoLKernel/drivers/i2c/chips/a1026.c:wakeup_sync_err:
NeoLKernel/drivers/i2c/chips/a1026.c:	rc = chk_wakeup_a1026();
NeoLKernel/drivers/i2c/chips/a1026.c:		rc = chk_wakeup_a1026();
NeoLKernel/drivers/i2c/chips/a1026.c:		rc = chk_wakeup_a1026();
NeoLKernel/drivers/i2c/chips/a1026.c:		rc = chk_wakeup_a1026();
NeoLKernel/drivers/i2c/chips/a1026.c:		rc = chk_wakeup_a1026();
NeoLKernel/drivers/i2c/chips/a1026.c:		rc = chk_wakeup_a1026();
NeoLKernel/drivers/i2c/chips/a1026.c:		rc = chk_wakeup_a1026();
NeoLKernel/drivers/i2c/chips/a1026.c:	rc = gpio_request(pdata->gpio_a1026_wakeup, "a1026");
NeoLKernel/drivers/i2c/chips/a1026.c:		pr_err("%s: gpio request wakeup pin failed\n", __func__);
NeoLKernel/drivers/i2c/chips/a1026.c:	rc = gpio_direction_output(pdata->gpio_a1026_wakeup, 1);
NeoLKernel/drivers/i2c/chips/a1026.c:		pr_err("%s: request wakeup gpio direction failed\n", __func__);
NeoLKernel/drivers/i2c/chips/a1026.c:	gpio_set_value(pdata->gpio_a1026_wakeup, 1);
NeoLKernel/drivers/i2c/chips/a1026.c:	gpio_free(pdata->gpio_a1026_wakeup);
NeoLKernel/drivers/i2c/chips/akm8973.c:	wake_up(&data_ready_wq);
NeoLKernel/drivers/i2c/chips/akm8973.c:				wake_up(&open_wq);
NeoLKernel/drivers/i2c/chips/akm8973.c:			wake_up(&open_wq);
NeoLKernel/drivers/i2c/chips/akm8973.c:	wake_up(&open_wq);
NeoLKernel/drivers/i2c/chips/akm8975.c:				wake_up(&open_wq);
NeoLKernel/drivers/i2c/chips/akm8975.c:	wake_up(&data_ready_wq);
NeoLKernel/drivers/i2c/chips/akm8975.c:	wake_up(&open_wq);
NeoLKernel/drivers/i2c/chips/akm8975.c:	wake_up(&open_wq);
NeoLKernel/drivers/i2c/chips/akm8975.c:		/* First time opened, so we wake stuff up */
NeoLKernel/drivers/i2c/chips/akm8975.c:		wake_up(&open_wq);
NeoLKernel/drivers/i2c/chips/akm8975.c:		wake_up(&open_wq);
NeoLKernel/drivers/i2c/chips/akm8976.c:	wake_up(&data_ready_wq);
NeoLKernel/drivers/i2c/chips/akm8976.c:				wake_up(&open_wq);
NeoLKernel/drivers/i2c/chips/akm8976.c:			wake_up(&open_wq);
NeoLKernel/drivers/i2c/chips/akm8976.c:	wake_up(&open_wq);
NeoLKernel/drivers/i2c/chips/akm8976.c:			wake_up(&open_wq);
NeoLKernel/drivers/i2c/chips/akm8976.c:	wake_up(&open_wq);
NeoLKernel/drivers/i2c/chips/akm8976.c:	wake_up(&open_wq);
NeoLKernel/drivers/i2c/chips/akm8976.c:	wake_up(&open_wq);
NeoLKernel/drivers/i2c/chips/mt9t013.c:#include <linux/wakelock.h>
NeoLKernel/drivers/i2c/chips/mt9t013.c:static struct wake_lock mt9t013_wake_lock;
NeoLKernel/drivers/i2c/chips/mt9t013.c:	wake_lock_init(&mt9t013_wake_lock, WAKE_LOCK_IDLE, "mt9t013");
NeoLKernel/drivers/i2c/chips/mt9t013.c:	wake_lock_destroy(&mt9t013_wake_lock);
NeoLKernel/drivers/i2c/chips/mt9t013.c:	wake_lock(&mt9t013_wake_lock);
NeoLKernel/drivers/i2c/chips/mt9t013.c:	wake_unlock(&mt9t013_wake_lock);
NeoLKernel/drivers/i2c/i2c-core.c:	if (!device_can_wakeup(&client->dev))
NeoLKernel/drivers/i2c/i2c-core.c:		device_init_wakeup(&client->dev,
NeoLKernel/drivers/ide/ide-iops.c: * setting a timer to wake up at half second intervals thereafter,
NeoLKernel/drivers/ide/ide-park.c:		wake_up_all(&ide_park_wq);
NeoLKernel/drivers/ide/ide-pm.c:		 * The first thing we do on wakeup is to wait for BSY bit to
NeoLKernel/drivers/ide/ide-pm.c:			printk(KERN_WARNING "%s: bus not ready on wakeup\n", drive->name);
NeoLKernel/drivers/ide/ide-pm.c:			printk(KERN_WARNING "%s: drive not ready on wakeup\n", drive->name);
NeoLKernel/drivers/ide/pmac.c: * wakeup from sleep time, before we do real calculation
NeoLKernel/drivers/ieee1394/ieee1394_transactions.c:	wake_up_interruptible(&tlabel_wq);
NeoLKernel/drivers/ieee1394/dv1394.c:		/* wake */
NeoLKernel/drivers/ieee1394/dv1394.c:		   buffers; otherwise we could miss a wakeup if the interrupt
NeoLKernel/drivers/ieee1394/dv1394.c:		   buffers; otherwise we could miss a wakeup if the interrupt
NeoLKernel/drivers/ieee1394/dv1394.c:	int wake = 0;
NeoLKernel/drivers/ieee1394/dv1394.c:					wake = 1;
NeoLKernel/drivers/ieee1394/dv1394.c:	if (wake) {
NeoLKernel/drivers/ieee1394/dv1394.c:		/* wake readers/writers/ioctl'ers */
NeoLKernel/drivers/ieee1394/dv1394.c:		wake_up_interruptible(&video->waitq);
NeoLKernel/drivers/ieee1394/dv1394.c:	int wake = 0;
NeoLKernel/drivers/ieee1394/dv1394.c:			/* wake up DMA in case it fell asleep */
NeoLKernel/drivers/ieee1394/dv1394.c:		wake = 1; /* why the hell not? */
NeoLKernel/drivers/ieee1394/dv1394.c:	if (wake) {
NeoLKernel/drivers/ieee1394/dv1394.c:		/* wake readers/writers/ioctl'ers */
NeoLKernel/drivers/ieee1394/dv1394.c:		wake_up_interruptible(&video->waitq);
NeoLKernel/drivers/ieee1394/dv1394.c:	/* wake readers/writers/ioctl'ers */
NeoLKernel/drivers/ieee1394/dv1394.c:	wake_up_interruptible(&video->waitq);
NeoLKernel/drivers/ieee1394/eth1394.c:	/* flush priv->wake */
NeoLKernel/drivers/ieee1394/eth1394.c:static void ether1394_wake_queue(struct work_struct *work)
NeoLKernel/drivers/ieee1394/eth1394.c:	priv = container_of(work, struct eth1394_priv, wake);
NeoLKernel/drivers/ieee1394/eth1394.c:	packet->node_id = priv->wake_node;
NeoLKernel/drivers/ieee1394/eth1394.c:	netif_wake_queue(priv->wake_dev);
NeoLKernel/drivers/ieee1394/eth1394.c:	INIT_WORK(&priv->wake, ether1394_wake_queue);
NeoLKernel/drivers/ieee1394/eth1394.c:	priv->wake_dev = dev;
NeoLKernel/drivers/ieee1394/eth1394.c:	netif_wake_queue(dev);
NeoLKernel/drivers/ieee1394/eth1394.c:		netif_wake_queue(dev);
NeoLKernel/drivers/ieee1394/eth1394.c:		priv->wake_node = dest_node;
NeoLKernel/drivers/ieee1394/eth1394.c:		schedule_work(&priv->wake);
NeoLKernel/drivers/ieee1394/eth1394.h:	struct work_struct wake;	/* Wake up after xmit failure	 */
NeoLKernel/drivers/ieee1394/eth1394.h:	struct net_device *wake_dev;	/* Stupid backlink for .wake	 */
NeoLKernel/drivers/ieee1394/eth1394.h:	nodeid_t wake_node;		/* Destination of failed xmit	 */
NeoLKernel/drivers/ieee1394/ieee1394_core.c:		wake_up_process(khpsbpkt_thread);
NeoLKernel/drivers/ieee1394/ieee1394_core.c:EXPORT_SYMBOL(hpsb_iso_wake);
NeoLKernel/drivers/ieee1394/iso.c: * hpsb_iso_wake
NeoLKernel/drivers/ieee1394/iso.c: * Call to wake waiting processes after buffer space has opened up.
NeoLKernel/drivers/ieee1394/iso.c:void hpsb_iso_wake(struct hpsb_iso *iso)
NeoLKernel/drivers/ieee1394/iso.c:	wake_up_interruptible(&iso->waitq);
NeoLKernel/drivers/ieee1394/iso.h:void hpsb_iso_wake(struct hpsb_iso *iso);
NeoLKernel/drivers/ieee1394/nodemgr.c:		wake_up_process(hi->thread);
NeoLKernel/drivers/ieee1394/ohci1394.c: * and runs or wakes up the DMA prg if necessary.
NeoLKernel/drivers/ieee1394/ohci1394.c:	/* wake up DMA in case it fell asleep */
NeoLKernel/drivers/ieee1394/ohci1394.c:	int wake = 0;
NeoLKernel/drivers/ieee1394/ohci1394.c:		wake = 1;
NeoLKernel/drivers/ieee1394/ohci1394.c:	if (wake)
NeoLKernel/drivers/ieee1394/ohci1394.c:		hpsb_iso_wake(iso);
NeoLKernel/drivers/ieee1394/ohci1394.c:	int wake = 0;
NeoLKernel/drivers/ieee1394/ohci1394.c:		wake = 1;
NeoLKernel/drivers/ieee1394/ohci1394.c:	if (wake)
NeoLKernel/drivers/ieee1394/ohci1394.c:		hpsb_iso_wake(iso);
NeoLKernel/drivers/ieee1394/ohci1394.c:	int wake = 0;
NeoLKernel/drivers/ieee1394/ohci1394.c:		/* at least one packet went out, so wake up the writer */
NeoLKernel/drivers/ieee1394/ohci1394.c:		wake = 1;
NeoLKernel/drivers/ieee1394/ohci1394.c:	if (wake)
NeoLKernel/drivers/ieee1394/ohci1394.c:		hpsb_iso_wake(iso);
NeoLKernel/drivers/ieee1394/ohci1394.c:	/* wake DMA in case it is sleeping */
NeoLKernel/drivers/ieee1394/ohci1394.c:	 * context program descriptors before it sees the wakeup bit set. */
NeoLKernel/drivers/ieee1394/ohci1394.c:	/* wake up the dma context if necessary */
NeoLKernel/drivers/ieee1394/raw1394.c: 	wake_up(&fi->wait_complete);
NeoLKernel/drivers/ieee1394/sbp2.c:			wake_up_interruptible(&sbp2_access_wq);
NeoLKernel/drivers/ieee1394/video1394.c:static void wakeup_dma_ir_ctx(unsigned long l);
NeoLKernel/drivers/ieee1394/video1394.c:static void wakeup_dma_it_ctx(unsigned long l);
NeoLKernel/drivers/ieee1394/video1394.c:					  wakeup_dma_ir_ctx,
NeoLKernel/drivers/ieee1394/video1394.c:					  wakeup_dma_it_ctx,
NeoLKernel/drivers/ieee1394/video1394.c:static void wakeup_dma_ir_ctx(unsigned long l)
NeoLKernel/drivers/ieee1394/video1394.c:		wake_up_interruptible(&d->waitq);
NeoLKernel/drivers/ieee1394/video1394.c:static void wakeup_dma_it_ctx(unsigned long l)
NeoLKernel/drivers/ieee1394/video1394.c:		wake_up_interruptible(&d->waitq);
NeoLKernel/drivers/infiniband/core/fmr_pool.c:			wake_up_interruptible(&pool->force_wait);
NeoLKernel/drivers/infiniband/core/fmr_pool.c:	wake_up_process(pool->thread);
NeoLKernel/drivers/infiniband/core/fmr_pool.c:				wake_up_process(pool->thread);
NeoLKernel/drivers/infiniband/core/iwcm.c:		wake_up_all(&cm_id_priv->connect_wait);
NeoLKernel/drivers/infiniband/core/iwcm.c:	wake_up_all(&cm_id_priv->connect_wait);
NeoLKernel/drivers/infiniband/core/iwcm.c:		wake_up_all(&cm_id_priv->connect_wait);
NeoLKernel/drivers/infiniband/core/iwcm.c:		wake_up_all(&cm_id_priv->connect_wait);
NeoLKernel/drivers/infiniband/core/iwcm.c:		wake_up_all(&cm_id_priv->connect_wait);
NeoLKernel/drivers/infiniband/core/iwcm.c:		wake_up_all(&cm_id_priv->connect_wait);
NeoLKernel/drivers/infiniband/core/iwcm.c: * by the CLOSE event. If the app closes, it will block until we wake
NeoLKernel/drivers/infiniband/core/iwcm.c:	wake_up_all(&cm_id_priv->connect_wait);
NeoLKernel/drivers/infiniband/core/iwcm.c: * post it's requests to the server. This event will wake up anyone
NeoLKernel/drivers/infiniband/core/iwcm.c:	wake_up_all(&cm_id_priv->connect_wait);
NeoLKernel/drivers/infiniband/core/ucm.c:	wake_up_interruptible(&ctx->file->poll_wait);
NeoLKernel/drivers/infiniband/core/ucma.c:	wake_up_interruptible(&ctx->file->poll_wait);
NeoLKernel/drivers/infiniband/core/user_mad.c:			wake_up_interruptible(&file->recv_wait);
NeoLKernel/drivers/infiniband/core/uverbs_main.c:	wake_up_interruptible(&file->poll_wait);
NeoLKernel/drivers/infiniband/core/uverbs_main.c:	wake_up_interruptible(&file->async_file->poll_wait);
NeoLKernel/drivers/infiniband/hw/amso1100/c2.c:		netif_wake_queue(c2_port->netdev);
NeoLKernel/drivers/infiniband/hw/amso1100/c2.c:		netif_wake_queue(netdev);
NeoLKernel/drivers/infiniband/hw/amso1100/c2.c:		pr_debug("%s: Tx ring full when queue awake!\n",
NeoLKernel/drivers/infiniband/hw/amso1100/c2.h:	struct list_head eh_wakeup_list;	/* event wakeup list */
NeoLKernel/drivers/infiniband/hw/amso1100/c2_cq.c:		wake_up(&cq->wait);
NeoLKernel/drivers/infiniband/hw/amso1100/c2_intr.c:		wake_up(&c2dev->req_vq_wo);
NeoLKernel/drivers/infiniband/hw/amso1100/c2_intr.c:	 * wakeup the waiter, we just won't give him the msg.
NeoLKernel/drivers/infiniband/hw/amso1100/c2_intr.c:	 * wakeup the waiter.
NeoLKernel/drivers/infiniband/hw/amso1100/c2_intr.c:	wake_up(&req->wait_object);
NeoLKernel/drivers/infiniband/hw/amso1100/c2_provider.c:		wake_up(&qp->wait);
NeoLKernel/drivers/infiniband/hw/amso1100/c2_vq.c: * 	3) wake up the kernel verbs handler blocked awaiting the reply.
NeoLKernel/drivers/infiniband/hw/amso1100/c2_vq.c: * It is used in the interrupt handler (handle_vq()) to wake up the appropriate
NeoLKernel/drivers/infiniband/hw/amso1100/c2_vq.c: * NOTE: handle_mq() on the interrupt context will wake up threads blocked here.
NeoLKernel/drivers/infiniband/hw/amso1100/c2_vq.c:	 * When a messages are available, the int handler will wake_up()
NeoLKernel/drivers/infiniband/hw/cxgb3/cxio_hal.c:			PDBG("%s ctrl_qp wakeup, continue posting work request "
NeoLKernel/drivers/infiniband/hw/cxgb3/cxio_hal.c:		wake_up_interruptible(&rdev_p->ctrl_qp.waitq);
NeoLKernel/drivers/infiniband/hw/cxgb3/iwch_cm.c:			wake_up(&ep->com.waitq);
NeoLKernel/drivers/infiniband/hw/cxgb3/iwch_cm.c:	wake_up(&ep->com.waitq);
NeoLKernel/drivers/infiniband/hw/cxgb3/iwch_cm.c:	wake_up(&ep->com.waitq);
NeoLKernel/drivers/infiniband/hw/cxgb3/iwch_cm.c:		 * rejects the CR. Also wake up anyone waiting
NeoLKernel/drivers/infiniband/hw/cxgb3/iwch_cm.c:		wake_up(&ep->com.waitq);
NeoLKernel/drivers/infiniband/hw/cxgb3/iwch_cm.c:		wake_up(&ep->com.waitq);
NeoLKernel/drivers/infiniband/hw/cxgb3/iwch_cm.c:		wake_up(&ep->com.waitq);
NeoLKernel/drivers/infiniband/hw/cxgb3/iwch_cm.c:		 * rejects the CR. Also wake up anyone waiting
NeoLKernel/drivers/infiniband/hw/cxgb3/iwch_cm.c:		wake_up(&ep->com.waitq);
NeoLKernel/drivers/infiniband/hw/cxgb3/iwch_ev.c:		wake_up(&qhp->wait);
NeoLKernel/drivers/infiniband/hw/cxgb3/iwch_ev.c:	        wake_up(&chp->wait);
NeoLKernel/drivers/infiniband/hw/cxgb3/iwch_provider.c:	        wake_up(&(to_iwch_qp(qp)->wait));
NeoLKernel/drivers/infiniband/hw/cxgb3/iwch_qp.c:	        wake_up(&qhp->wait);
NeoLKernel/drivers/infiniband/hw/cxgb3/iwch_qp.c:				wake_up(&qhp->wait);
NeoLKernel/drivers/infiniband/hw/cxgb3/iwch_qp.c:	wake_up(&qhp->wait);
NeoLKernel/drivers/infiniband/hw/ehca/ehca_irq.c:		wake_up(&qp->wait_completion);
NeoLKernel/drivers/infiniband/hw/ehca/ehca_irq.c:		wake_up(&cq->wait_completion);
NeoLKernel/drivers/infiniband/hw/ehca/ehca_irq.c:				wake_up(&cq->wait_completion);
NeoLKernel/drivers/infiniband/hw/ehca/ehca_irq.c:					wake_up(&cq->wait_completion);
NeoLKernel/drivers/infiniband/hw/ehca/ehca_irq.c:		wake_up(&cct->wait_queue);
NeoLKernel/drivers/infiniband/hw/ehca/ehca_irq.c:			wake_up(&cq->wait_completion);
NeoLKernel/drivers/infiniband/hw/ehca/ehca_irq.c:		wake_up_process(cct->task);
NeoLKernel/drivers/infiniband/hw/ehca/ehca_irq.c:			wake_up_process(task);
NeoLKernel/drivers/infiniband/hw/ipath/ipath_file_ops.c:		wake_up(&pd->port_wait);
NeoLKernel/drivers/infiniband/hw/ipath/ipath_iba7220.c:	wake_up(&dd->ipath_autoneg_wait);
NeoLKernel/drivers/infiniband/hw/ipath/ipath_iba7220.c:				wake_up(&dd->ipath_autoneg_wait);
NeoLKernel/drivers/infiniband/hw/ipath/ipath_intr.c:			wake_up_interruptible(&pd->port_wait);
NeoLKernel/drivers/infiniband/hw/ipath/ipath_intr.c:		wake_up_interruptible(&ipath_state_wait);
NeoLKernel/drivers/infiniband/hw/ipath/ipath_intr.c:				wake_up_interruptible(&pd->port_wait);
NeoLKernel/drivers/infiniband/hw/ipath/ipath_intr.c:				wake_up_interruptible(&pd->port_wait);
NeoLKernel/drivers/infiniband/hw/ipath/ipath_ruc.c:		wake_up(&qp->wait);
NeoLKernel/drivers/infiniband/hw/ipath/ipath_ud.c:		wake_up(&qp->wait);
NeoLKernel/drivers/infiniband/hw/ipath/ipath_verbs.c:			wake_up(&mcast->wait);
NeoLKernel/drivers/infiniband/hw/ipath/ipath_verbs.c:				wake_up(&qp->wait);
NeoLKernel/drivers/infiniband/hw/ipath/ipath_verbs.c:			wake_up(&qp->wait);
NeoLKernel/drivers/infiniband/hw/ipath/ipath_verbs.c:			wake_up(&qp->wait);
NeoLKernel/drivers/infiniband/hw/ipath/ipath_verbs.c:		wake_up(&qp->wait_dma);
NeoLKernel/drivers/infiniband/hw/ipath/ipath_verbs.c:		wake_up(&qp->wait);
NeoLKernel/drivers/infiniband/hw/ipath/ipath_verbs.c:		wake_up(&qp->wait_dma);
NeoLKernel/drivers/infiniband/hw/ipath/ipath_verbs.c:		wake_up(&qp->wait);
NeoLKernel/drivers/infiniband/hw/ipath/ipath_verbs.c:			wake_up(&qp->wait);
NeoLKernel/drivers/infiniband/hw/ipath/ipath_verbs_mcast.c:		wake_up(&qp->wait);
NeoLKernel/drivers/infiniband/hw/mthca/mthca_cq.c:		wake_up(&cq->wait);
NeoLKernel/drivers/infiniband/hw/mthca/mthca_provider.h: * - decrement ref count; if zero, wake up waiters
NeoLKernel/drivers/infiniband/hw/mthca/mthca_qp.c:		wake_up(&qp->wait);
NeoLKernel/drivers/infiniband/hw/mthca/mthca_srq.c:		wake_up(&srq->wait);
NeoLKernel/drivers/infiniband/hw/nes/nes_hw.c:					netif_wake_queue(nesvnic->netdev);
NeoLKernel/drivers/infiniband/hw/nes/nes_hw.c:			netif_wake_queue(nesvnic->netdev);
NeoLKernel/drivers/infiniband/hw/nes/nes_hw.c:					wake_up(&cqp_request->waitq);
NeoLKernel/drivers/infiniband/hw/nes/nes_hw.c:				wake_up(&nesdev->cqp.waitq);
NeoLKernel/drivers/infiniband/ulp/ipoib/ipoib_cm.c:		netif_wake_queue(dev);
NeoLKernel/drivers/infiniband/ulp/ipoib/ipoib_cm.c:			netif_wake_queue(p->dev);
NeoLKernel/drivers/infiniband/ulp/ipoib/ipoib_ib.c:		netif_wake_queue(dev);
NeoLKernel/drivers/infiniband/ulp/ipoib/ipoib_ib.c:			netif_wake_queue(dev);
NeoLKernel/drivers/infiniband/ulp/iser/iser_verbs.c:	wake_up_interruptible(&ib_conn->wait);
NeoLKernel/drivers/infiniband/ulp/iser/iser_verbs.c:	wake_up_interruptible(&ib_conn->wait);
NeoLKernel/drivers/infiniband/ulp/iser/iser_verbs.c:		wake_up_interruptible(&ib_conn->wait);
NeoLKernel/drivers/infiniband/ulp/iser/iser_verbs.c:			wake_up_interruptible(&ib_conn->wait);
NeoLKernel/drivers/input/evdev.c:#include <linux/wakelock.h>
NeoLKernel/drivers/input/evdev.c:	struct wake_lock wake_lock;
NeoLKernel/drivers/input/evdev.c:	wake_lock_timeout(&client->wake_lock, 5 * HZ);
NeoLKernel/drivers/input/evdev.c:	wake_up_interruptible(&evdev->wait);
NeoLKernel/drivers/input/evdev.c:	wake_up_interruptible(&evdev->wait);
NeoLKernel/drivers/input/evdev.c:	wake_lock_destroy(&client->wake_lock);
NeoLKernel/drivers/input/evdev.c:	wake_lock_init(&client->wake_lock, WAKE_LOCK_SUSPEND, client->name);
NeoLKernel/drivers/input/evdev.c:	wake_lock_destroy(&client->wake_lock);
NeoLKernel/drivers/input/evdev.c:			wake_unlock(&client->wake_lock);
NeoLKernel/drivers/input/gameport/gameport.c:	wake_up(&gameport_wait);
NeoLKernel/drivers/input/input.c:static inline void input_wakeup_procfs_readers(void)
NeoLKernel/drivers/input/input.c:	wake_up(&input_devices_poll_wait);
NeoLKernel/drivers/input/input.c:static inline void input_wakeup_procfs_readers(void) { }
NeoLKernel/drivers/input/input.c:	input_wakeup_procfs_readers();
NeoLKernel/drivers/input/input.c:	input_wakeup_procfs_readers();
NeoLKernel/drivers/input/input.c:	input_wakeup_procfs_readers();
NeoLKernel/drivers/input/input.c:	input_wakeup_procfs_readers();
NeoLKernel/drivers/input/joydev.c:	wake_up_interruptible(&joydev->wait);
NeoLKernel/drivers/input/joydev.c:	wake_up_interruptible(&joydev->wait);
NeoLKernel/drivers/input/joystick/iforce/iforce-packets.c:	wake_up(&iforce->wait);
NeoLKernel/drivers/input/joystick/iforce/iforce-serio.c:static void iforce_serio_write_wakeup(struct serio *serio)
NeoLKernel/drivers/input/joystick/iforce/iforce-serio.c:	.write_wakeup	= iforce_serio_write_wakeup,
NeoLKernel/drivers/input/joystick/iforce/iforce-usb.c:	wake_up(&iforce->wait);
NeoLKernel/drivers/input/joystick/iforce/iforce-usb.c:	wake_up(&iforce->wait);
NeoLKernel/drivers/input/joystick/synaptics_touchpad.c:	bool should_wake;
NeoLKernel/drivers/input/joystick/synaptics_touchpad.c:	should_wake = (active & SYN_ACTIVE_REQ) && !(active & SYN_STANDBY) &&
NeoLKernel/drivers/input/joystick/synaptics_touchpad.c:	if (should_wake && !(active & SYN_ACTIVE_POWER)) {
NeoLKernel/drivers/input/joystick/synaptics_touchpad.c:		dev_dbg(&this->i2c->dev, "%s: touch panel wakeup\n",
NeoLKernel/drivers/input/joystick/synaptics_touchpad.c:	} else if (!should_wake && (active & SYN_ACTIVE_POWER)) {
NeoLKernel/drivers/input/joystick/tdisc_vtd518_shinetsu.c:	if (device_may_wakeup(&dd->clientp->dev))
NeoLKernel/drivers/input/joystick/tdisc_vtd518_shinetsu.c:		enable_irq_wake(dd->clientp->irq);
NeoLKernel/drivers/input/joystick/tdisc_vtd518_shinetsu.c:	if (device_may_wakeup(&dd->clientp->dev))
NeoLKernel/drivers/input/joystick/tdisc_vtd518_shinetsu.c:		disable_irq_wake(dd->clientp->irq);
NeoLKernel/drivers/input/joystick/tdisc_vtd518_shinetsu.c:	/* Setup wakeup capability */
NeoLKernel/drivers/input/joystick/tdisc_vtd518_shinetsu.c:	device_init_wakeup(&dd->clientp->dev, dd->pdata->tdisc_wakeup);
NeoLKernel/drivers/input/keyboard/adp5588-keys.c:	device_init_wakeup(&client->dev, 1);
NeoLKernel/drivers/input/keyboard/adp5588-keys.c:	if (device_may_wakeup(&client->dev))
NeoLKernel/drivers/input/keyboard/adp5588-keys.c:		enable_irq_wake(client->irq);
NeoLKernel/drivers/input/keyboard/adp5588-keys.c:	if (device_may_wakeup(&client->dev))
NeoLKernel/drivers/input/keyboard/adp5588-keys.c:		disable_irq_wake(client->irq);
NeoLKernel/drivers/input/keyboard/bf54x-keys.c:	device_init_wakeup(&pdev->dev, 1);
NeoLKernel/drivers/input/keyboard/bf54x-keys.c:	if (device_may_wakeup(&pdev->dev))
NeoLKernel/drivers/input/keyboard/bf54x-keys.c:		enable_irq_wake(bf54x_kpad->irq);
NeoLKernel/drivers/input/keyboard/bf54x-keys.c:	if (device_may_wakeup(&pdev->dev))
NeoLKernel/drivers/input/keyboard/bf54x-keys.c:		disable_irq_wake(bf54x_kpad->irq);
NeoLKernel/drivers/input/keyboard/ep93xx_keypad.c:	if (device_may_wakeup(&pdev->dev))
NeoLKernel/drivers/input/keyboard/ep93xx_keypad.c:		enable_irq_wake(keypad->irq);
NeoLKernel/drivers/input/keyboard/ep93xx_keypad.c:	if (device_may_wakeup(&pdev->dev))
NeoLKernel/drivers/input/keyboard/ep93xx_keypad.c:		disable_irq_wake(keypad->irq);
NeoLKernel/drivers/input/keyboard/ep93xx_keypad.c:	device_init_wakeup(&pdev->dev, 1);
NeoLKernel/drivers/input/keyboard/gpio_keys.c:	int wakeup = 0;
NeoLKernel/drivers/input/keyboard/gpio_keys.c:		if (button->wakeup)
NeoLKernel/drivers/input/keyboard/gpio_keys.c:			wakeup = 1;
NeoLKernel/drivers/input/keyboard/gpio_keys.c:	device_init_wakeup(&pdev->dev, wakeup);
NeoLKernel/drivers/input/keyboard/gpio_keys.c:	device_init_wakeup(&pdev->dev, 0);
NeoLKernel/drivers/input/keyboard/gpio_keys.c:	if (device_may_wakeup(&pdev->dev)) {
NeoLKernel/drivers/input/keyboard/gpio_keys.c:			if (button->wakeup) {
NeoLKernel/drivers/input/keyboard/gpio_keys.c:				enable_irq_wake(irq);
NeoLKernel/drivers/input/keyboard/gpio_keys.c:	if (device_may_wakeup(&pdev->dev)) {
NeoLKernel/drivers/input/keyboard/gpio_keys.c:			if (button->wakeup) {
NeoLKernel/drivers/input/keyboard/gpio_keys.c:				disable_irq_wake(irq);
NeoLKernel/drivers/input/keyboard/lm8323.c:	 * back while it wakes up, so try again, once.
NeoLKernel/drivers/input/keyboard/lm8323.c:	 * back while it wakes up, so try again, once.
NeoLKernel/drivers/input/keyboard/lm8323.c:	device_init_wakeup(&client->dev, 1);
NeoLKernel/drivers/input/keyboard/lm8323.c:	enable_irq_wake(client->irq);
NeoLKernel/drivers/input/keyboard/lm8323.c:	disable_irq_wake(client->irq);
NeoLKernel/drivers/input/keyboard/lm8323.c:	set_irq_wake(client->irq, 0);
NeoLKernel/drivers/input/keyboard/lm8323.c:	set_irq_wake(client->irq, 1);
NeoLKernel/drivers/input/keyboard/matrix_keypad.c:	if (device_may_wakeup(&pdev->dev))
NeoLKernel/drivers/input/keyboard/matrix_keypad.c:			enable_irq_wake(gpio_to_irq(pdata->row_gpios[i]));
NeoLKernel/drivers/input/keyboard/matrix_keypad.c:	if (device_may_wakeup(&pdev->dev))
NeoLKernel/drivers/input/keyboard/matrix_keypad.c:			disable_irq_wake(gpio_to_irq(pdata->row_gpios[i]));
NeoLKernel/drivers/input/keyboard/matrix_keypad.c:	device_init_wakeup(&pdev->dev, pdata->wakeup);
NeoLKernel/drivers/input/keyboard/matrix_keypad.c:	device_init_wakeup(&pdev->dev, 0);
NeoLKernel/drivers/input/keyboard/max7359_keypad.c:		MAX7359_CFG_WAKEUP); /* Key press wakeup enable */
NeoLKernel/drivers/input/keyboard/max7359_keypad.c:	device_init_wakeup(&client->dev, 1);
NeoLKernel/drivers/input/keyboard/max7359_keypad.c:	if (device_may_wakeup(&client->dev))
NeoLKernel/drivers/input/keyboard/max7359_keypad.c:		enable_irq_wake(client->irq);
NeoLKernel/drivers/input/keyboard/max7359_keypad.c:	if (device_may_wakeup(&client->dev))
NeoLKernel/drivers/input/keyboard/max7359_keypad.c:		disable_irq_wake(client->irq);
NeoLKernel/drivers/input/keyboard/pmic8058-keypad.c:	device_init_wakeup(&pdev->dev, pdata->wakeup);
NeoLKernel/drivers/input/keyboard/pmic8058-keypad.c:	device_init_wakeup(&pdev->dev, 0);
NeoLKernel/drivers/input/keyboard/pmic8058-keypad.c:	if (device_may_wakeup(dev) && !pmic8058_kp_disabled(kp)) {
NeoLKernel/drivers/input/keyboard/pmic8058-keypad.c:		enable_irq_wake(kp->key_sense_irq);
NeoLKernel/drivers/input/keyboard/pmic8058-keypad.c:	if (device_may_wakeup(dev) && !pmic8058_kp_disabled(kp)) {
NeoLKernel/drivers/input/keyboard/pmic8058-keypad.c:		disable_irq_wake(kp->key_sense_irq);
NeoLKernel/drivers/input/keyboard/pxa27x_keypad.c:	if (device_may_wakeup(&pdev->dev))
NeoLKernel/drivers/input/keyboard/pxa27x_keypad.c:		enable_irq_wake(keypad->irq);
NeoLKernel/drivers/input/keyboard/pxa27x_keypad.c:	if (device_may_wakeup(&pdev->dev))
NeoLKernel/drivers/input/keyboard/pxa27x_keypad.c:		disable_irq_wake(keypad->irq);
NeoLKernel/drivers/input/keyboard/pxa27x_keypad.c:	device_init_wakeup(&pdev->dev, 1);
NeoLKernel/drivers/input/keyboard/sh_keysc.c:	device_init_wakeup(&pdev->dev, 1);
NeoLKernel/drivers/input/keyboard/sh_keysc.c:	if (device_may_wakeup(dev)) {
NeoLKernel/drivers/input/keyboard/sh_keysc.c:		enable_irq_wake(irq);
NeoLKernel/drivers/input/keyboard/sh_keysc.c:	if (device_may_wakeup(dev))
NeoLKernel/drivers/input/keyboard/sh_keysc.c:		disable_irq_wake(irq);
NeoLKernel/drivers/input/keyboard/sunkbd.c:		wake_up_interruptible(&sunkbd->wait);
NeoLKernel/drivers/input/keyboard/sunkbd.c:		wake_up_interruptible(&sunkbd->wait);
NeoLKernel/drivers/input/keyboard/twl4030_keypad.c: * up to an 8x8 switch matrix.  The controller can issue system wakeup
NeoLKernel/drivers/input/misc/Kconfig:	  IR Receive and wake-on-IR from suspend and power-off is currently
NeoLKernel/drivers/input/misc/ak8975.c:	device_init_wakeup(&client->dev, 0);
NeoLKernel/drivers/input/misc/apds9702.c:	err = set_irq_wake(data->interrupt, pdata->is_irq_wakeup);
NeoLKernel/drivers/input/misc/apds9702.c:		dev_err(&client->dev, "%s: set_irq_wake failed\n", __func__);
NeoLKernel/drivers/input/misc/apds9702.c:		goto err_request_wake_irq;
NeoLKernel/drivers/input/misc/apds9702.c:err_request_wake_irq:
NeoLKernel/drivers/input/misc/ati_remote.c:	wake_up(&ati_remote->wait);
NeoLKernel/drivers/input/misc/ati_remote2.c:	interface->needs_remote_wakeup = 1;
NeoLKernel/drivers/input/misc/bfin_rotary.c:	device_init_wakeup(&pdev->dev, 1);
NeoLKernel/drivers/input/misc/bfin_rotary.c:	if (device_may_wakeup(&pdev->dev))
NeoLKernel/drivers/input/misc/bfin_rotary.c:		enable_irq_wake(rotary->irq);
NeoLKernel/drivers/input/misc/bfin_rotary.c:	if (device_may_wakeup(&pdev->dev))
NeoLKernel/drivers/input/misc/bfin_rotary.c:		disable_irq_wake(rotary->irq);
NeoLKernel/drivers/input/misc/bma250.c:	rc = set_irq_wake(dd->ic_dev->irq, 1);
NeoLKernel/drivers/input/misc/bma250.c:			"%s: set_irq_wake failed with error %d\n",
NeoLKernel/drivers/input/misc/bma250.c:		goto probe_err_wake_irq;
NeoLKernel/drivers/input/misc/bma250.c:		goto probe_err_wake_irq;
NeoLKernel/drivers/input/misc/bma250.c:probe_err_wake_irq:
NeoLKernel/drivers/input/misc/bma250.c:	rc = set_irq_wake(dd->ic_dev->irq, 0);
NeoLKernel/drivers/input/misc/bma250.c:			"%s: set_irq_wake failed with error %d\n",
NeoLKernel/drivers/input/misc/keychord.c:		wake_up_interruptible(&kdev->waitq);
NeoLKernel/drivers/input/misc/kp_flip_switch.c:	device_init_wakeup(&pdev->dev, pdata->wakeup);
NeoLKernel/drivers/input/misc/kp_flip_switch.c:	if (device_may_wakeup(&pdev->dev))
NeoLKernel/drivers/input/misc/kp_flip_switch.c:		enable_irq_wake(gpio_to_irq(flip->fs_pdata->flip_gpio));
NeoLKernel/drivers/input/misc/kp_flip_switch.c:	if (device_may_wakeup(&pdev->dev))
NeoLKernel/drivers/input/misc/kp_flip_switch.c:		disable_irq_wake(gpio_to_irq(flip->fs_pdata->flip_gpio));
NeoLKernel/drivers/input/misc/kp_flip_switch.c:	device_init_wakeup(&pdev->dev, 0);
NeoLKernel/drivers/input/misc/pmic8058-othc.c:	if (device_may_wakeup(dev)) {
NeoLKernel/drivers/input/misc/pmic8058-othc.c:		enable_irq_wake(dd->othc_irq_sw);
NeoLKernel/drivers/input/misc/pmic8058-othc.c:		enable_irq_wake(dd->othc_irq_ir);
NeoLKernel/drivers/input/misc/pmic8058-othc.c:	if (device_may_wakeup(dev)) {
NeoLKernel/drivers/input/misc/pmic8058-othc.c:		disable_irq_wake(dd->othc_irq_sw);
NeoLKernel/drivers/input/misc/pmic8058-othc.c:		disable_irq_wake(dd->othc_irq_ir);
NeoLKernel/drivers/input/misc/pmic8058-othc.c:	device_init_wakeup(&pd->dev, 0);
NeoLKernel/drivers/input/misc/pmic8058-othc.c:	device_init_wakeup(&pd->dev, hsed_config->othc_wakeup);
NeoLKernel/drivers/input/misc/pmic8058-pwrkey.c:	if (device_may_wakeup(dev))
NeoLKernel/drivers/input/misc/pmic8058-pwrkey.c:		enable_irq_wake(pwrkey->key_press_irq);
NeoLKernel/drivers/input/misc/pmic8058-pwrkey.c:	if (device_may_wakeup(dev))
NeoLKernel/drivers/input/misc/pmic8058-pwrkey.c:		disable_irq_wake(pwrkey->key_press_irq);
NeoLKernel/drivers/input/misc/pmic8058-pwrkey.c:	device_init_wakeup(&pdev->dev, pdata->wakeup);
NeoLKernel/drivers/input/misc/pmic8058-pwrkey.c:	device_init_wakeup(&pdev->dev, 0);
NeoLKernel/drivers/input/misc/powermate.c:	int pulse_awake;
NeoLKernel/drivers/input/misc/powermate.c:		pm->configcr->wIndex = cpu_to_le16( pm->pulse_awake ? 1 : 0 );
NeoLKernel/drivers/input/misc/powermate.c:				int pulse_table, int pulse_asleep, int pulse_awake)
NeoLKernel/drivers/input/misc/powermate.c:	pulse_awake = !!pulse_awake;
NeoLKernel/drivers/input/misc/powermate.c:	if (pulse_awake != pm->pulse_awake) {
NeoLKernel/drivers/input/misc/powermate.c:		pm->pulse_awake = pulse_awake;
NeoLKernel/drivers/input/misc/powermate.c:		int pulse_awake  = (command >> 20) & 0x1; // bit 20
NeoLKernel/drivers/input/misc/powermate.c:		powermate_pulse_led(pm, static_brightness, pulse_speed, pulse_table, pulse_asleep, pulse_awake);
NeoLKernel/drivers/input/misc/uinput.c:	wake_up_interruptible(&udev->waitq);
NeoLKernel/drivers/input/misc/uinput.c:	wake_up(&udev->requests_waitq);
NeoLKernel/drivers/input/misc/winbond-cir.c:static unsigned int wake_sc = 0x800F040C;
NeoLKernel/drivers/input/misc/winbond-cir.c:module_param(wake_sc, uint, 0644);
NeoLKernel/drivers/input/misc/winbond-cir.c:MODULE_PARM_DESC(wake_sc, "Scancode of the power-on IR command");
NeoLKernel/drivers/input/misc/winbond-cir.c:static unsigned int wake_rc6mode = 6;
NeoLKernel/drivers/input/misc/winbond-cir.c:module_param(wake_rc6mode, uint, 0644);
NeoLKernel/drivers/input/misc/winbond-cir.c:MODULE_PARM_DESC(wake_rc6mode, "RC6 mode for the power-on command "
NeoLKernel/drivers/input/misc/winbond-cir.c:	int do_wake = 1;
NeoLKernel/drivers/input/misc/winbond-cir.c:	if (wake_sc == INVALID_SCANCODE || !device_may_wakeup(dev)) {
NeoLKernel/drivers/input/misc/winbond-cir.c:		do_wake = 0;
NeoLKernel/drivers/input/misc/winbond-cir.c:		if (wake_sc > 0xFFF) {
NeoLKernel/drivers/input/misc/winbond-cir.c:			do_wake = 0;
NeoLKernel/drivers/input/misc/winbond-cir.c:			dev_err(dev, "RC5 - Invalid wake scancode\n");
NeoLKernel/drivers/input/misc/winbond-cir.c:		match[0]  = (wake_sc & 0x003F);      /* 6 command bits */
NeoLKernel/drivers/input/misc/winbond-cir.c:		match[0] |= (wake_sc & 0x0180) >> 1; /* 2 address bits */
NeoLKernel/drivers/input/misc/winbond-cir.c:		match[1]  = (wake_sc & 0x0E00) >> 9; /* 3 address bits */
NeoLKernel/drivers/input/misc/winbond-cir.c:		if (!(wake_sc & 0x0040))             /* 2nd start bit  */
NeoLKernel/drivers/input/misc/winbond-cir.c:		if (wake_sc > 0xFFFFFF) {
NeoLKernel/drivers/input/misc/winbond-cir.c:			do_wake = 0;
NeoLKernel/drivers/input/misc/winbond-cir.c:			dev_err(dev, "NEC - Invalid wake scancode\n");
NeoLKernel/drivers/input/misc/winbond-cir.c:		match[1] = bitrev8((wake_sc & 0xFF));
NeoLKernel/drivers/input/misc/winbond-cir.c:		match[3] = bitrev8((wake_sc & 0xFF00) >> 8);
NeoLKernel/drivers/input/misc/winbond-cir.c:		if (wake_sc > 0xFFFF)
NeoLKernel/drivers/input/misc/winbond-cir.c:			match[2] = bitrev8((wake_sc & 0xFF0000) >> 16);
NeoLKernel/drivers/input/misc/winbond-cir.c:		if (wake_rc6mode == 0) {
NeoLKernel/drivers/input/misc/winbond-cir.c:			if (wake_sc > 0xFFFF) {
NeoLKernel/drivers/input/misc/winbond-cir.c:				do_wake = 0;
NeoLKernel/drivers/input/misc/winbond-cir.c:				dev_err(dev, "RC6 - Invalid wake scancode\n");
NeoLKernel/drivers/input/misc/winbond-cir.c:			match[0] = wbcir_to_rc6cells(wake_sc >>  0);
NeoLKernel/drivers/input/misc/winbond-cir.c:			match[1] = wbcir_to_rc6cells(wake_sc >>  4);
NeoLKernel/drivers/input/misc/winbond-cir.c:			match[2] = wbcir_to_rc6cells(wake_sc >>  8);
NeoLKernel/drivers/input/misc/winbond-cir.c:			match[3] = wbcir_to_rc6cells(wake_sc >> 12);
NeoLKernel/drivers/input/misc/winbond-cir.c:		} else if (wake_rc6mode == 6) {
NeoLKernel/drivers/input/misc/winbond-cir.c:			match[i]  = wbcir_to_rc6cells(wake_sc >>  0);
NeoLKernel/drivers/input/misc/winbond-cir.c:			match[i]  = wbcir_to_rc6cells(wake_sc >>  4);
NeoLKernel/drivers/input/misc/winbond-cir.c:			match[i]  = wbcir_to_rc6cells(wake_sc >>  8);
NeoLKernel/drivers/input/misc/winbond-cir.c:			match[i]  = wbcir_to_rc6cells(wake_sc >> 12);
NeoLKernel/drivers/input/misc/winbond-cir.c:			match[i]  = wbcir_to_rc6cells(wake_sc >> 16);
NeoLKernel/drivers/input/misc/winbond-cir.c:			match[i]  = wbcir_to_rc6cells(wake_sc >> 20);
NeoLKernel/drivers/input/misc/winbond-cir.c:			if (wake_sc & 0x80000000) {
NeoLKernel/drivers/input/misc/winbond-cir.c:				match[i]  = wbcir_to_rc6cells(wake_sc >> 24);
NeoLKernel/drivers/input/misc/winbond-cir.c:				match[i]  = wbcir_to_rc6cells(wake_sc >> 28);
NeoLKernel/drivers/input/misc/winbond-cir.c:			} else if (wake_sc <= 0x007FFFFF) {
NeoLKernel/drivers/input/misc/winbond-cir.c:				do_wake = 0;
NeoLKernel/drivers/input/misc/winbond-cir.c:				dev_err(dev, "RC6 - Invalid wake scancode\n");
NeoLKernel/drivers/input/misc/winbond-cir.c:			do_wake = 0;
NeoLKernel/drivers/input/misc/winbond-cir.c:			dev_err(dev, "RC6 - Invalid wake mode\n");
NeoLKernel/drivers/input/misc/winbond-cir.c:		do_wake = 0;
NeoLKernel/drivers/input/misc/winbond-cir.c:	if (do_wake) {
NeoLKernel/drivers/input/misc/winbond-cir.c:	device_init_wakeup(&device->dev, 1);
NeoLKernel/drivers/input/misc/capella_cm3602.c:	rc = set_irq_wake(irq, 1);
NeoLKernel/drivers/input/misc/capella_cm3602.c:		pr_err("%s: failed to set irq %d as a wake interrupt\n",
NeoLKernel/drivers/input/misc/dm355evm_keys.c: * be able to wake up the system.  When device_may_wakeup(&pdev->dev), call
NeoLKernel/drivers/input/misc/dm355evm_keys.c: * enable_irq_wake() on suspend, and disable_irq_wake() on resume.
NeoLKernel/drivers/input/misc/gp2ap002a00f.c:	if (dt->pdata->wake)
NeoLKernel/drivers/input/misc/gp2ap002a00f.c:		enable_irq_wake(dt->i2c_client->irq);
NeoLKernel/drivers/input/misc/gp2ap002a00f.c:	if (dt->pdata->wake)
NeoLKernel/drivers/input/misc/gp2ap002a00f.c:		disable_irq_wake(dt->i2c_client->irq);
NeoLKernel/drivers/input/misc/gp2ap002a00f.c:	device_init_wakeup(&client->dev, 0);
NeoLKernel/drivers/input/misc/gpio_input.c:#include <linux/wakelock.h>
NeoLKernel/drivers/input/misc/gpio_input.c:	struct wake_lock wake_lock;
NeoLKernel/drivers/input/misc/gpio_input.c:		wake_unlock(&ds->wake_lock);
NeoLKernel/drivers/input/misc/gpio_input.c:				wake_lock(&ds->wake_lock);
NeoLKernel/drivers/input/misc/gpio_input.c:		enable_irq_wake(irq);
NeoLKernel/drivers/input/misc/gpio_input.c:				disable_irq_wake(irq);
NeoLKernel/drivers/input/misc/gpio_input.c:				enable_irq_wake(irq);
NeoLKernel/drivers/input/misc/gpio_input.c:		wake_lock_init(&ds->wake_lock, WAKE_LOCK_SUSPEND, "gpio_input");
NeoLKernel/drivers/input/misc/gpio_input.c:	wake_lock_destroy(&ds->wake_lock);
NeoLKernel/drivers/input/misc/gpio_matrix.c:#include <linux/wakelock.h>
NeoLKernel/drivers/input/misc/gpio_matrix.c:	struct wake_lock wake_lock;
NeoLKernel/drivers/input/misc/gpio_matrix.c:	wake_unlock(&kp->wake_lock);
NeoLKernel/drivers/input/misc/gpio_matrix.c:	wake_lock(&kp->wake_lock);
NeoLKernel/drivers/input/misc/gpio_matrix.c:		err = set_irq_wake(irq, 1);
NeoLKernel/drivers/input/misc/gpio_matrix.c:			pr_err("gpiomatrix: set_irq_wake failed for input %d, "
NeoLKernel/drivers/input/misc/gpio_matrix.c:		wake_lock_init(&kp->wake_lock, WAKE_LOCK_SUSPEND, "gpio_kp");
NeoLKernel/drivers/input/misc/gpio_matrix.c:			wake_lock(&kp->wake_lock);
NeoLKernel/drivers/input/misc/gpio_matrix.c:	wake_lock_destroy(&kp->wake_lock);
NeoLKernel/drivers/input/mouse/hgpk.c:		 * Sending a byte will drive MS-DAT low; this will wake up
NeoLKernel/drivers/input/mousedev.c:	int wake_readers = 0;
NeoLKernel/drivers/input/mousedev.c:			wake_readers = 1;
NeoLKernel/drivers/input/mousedev.c:	if (wake_readers)
NeoLKernel/drivers/input/mousedev.c:		wake_up_interruptible(&mousedev->wait);
NeoLKernel/drivers/input/mousedev.c:	wake_up_interruptible(&client->mousedev->wait);
NeoLKernel/drivers/input/mousedev.c:	wake_up_interruptible(&mousedev->wait);
NeoLKernel/drivers/input/serio/hil_mlc.c:	/* TODO wake up interruptable */
NeoLKernel/drivers/input/serio/libps2.c:	wake_up(&ps2dev->wait);
NeoLKernel/drivers/input/serio/libps2.c:			wake_up(&ps2dev->wait);
NeoLKernel/drivers/input/serio/libps2.c:		wake_up(&ps2dev->wait);
NeoLKernel/drivers/input/serio/libps2.c:		wake_up(&ps2dev->wait);
NeoLKernel/drivers/input/serio/sa1111ps2.c:	enable_irq_wake(ps2if->dev->irq[0]);
NeoLKernel/drivers/input/serio/sa1111ps2.c:	disable_irq_wake(ps2if->dev->irq[0]);
NeoLKernel/drivers/input/serio/serio.c:	wake_up(&serio_wait);
NeoLKernel/drivers/input/serio/serio_raw.c:		wake_up_interruptible(&serio_raw->wait);
NeoLKernel/drivers/input/serio/serio_raw.c:		wake_up_interruptible(&serio_raw->wait);
NeoLKernel/drivers/input/serio/serport.c:	wake_up_interruptible(&serport->wait);
NeoLKernel/drivers/input/serio/serport.c:static void serport_ldisc_write_wakeup(struct tty_struct * tty)
NeoLKernel/drivers/input/serio/serport.c:		serio_drv_write_wakeup(serport->serio);
NeoLKernel/drivers/input/serio/serport.c:	.write_wakeup =	serport_ldisc_write_wakeup
NeoLKernel/drivers/input/tablet/wacom_sys.c:	wacom->intf->needs_remote_wakeup = 1;
NeoLKernel/drivers/input/tablet/wacom_sys.c:	wacom->intf->needs_remote_wakeup = 0;
NeoLKernel/drivers/input/touchscreen/clearpad_core.c:	wake_up_interruptible(&this->task_none_wq);
NeoLKernel/drivers/input/touchscreen/clearpad_core.c:		wake_up_interruptible(&this->task_none_wq);
NeoLKernel/drivers/input/touchscreen/clearpad_core.c:	bool should_wake;
NeoLKernel/drivers/input/touchscreen/clearpad_core.c:	should_wake = !(active & SYN_STANDBY) && users;
NeoLKernel/drivers/input/touchscreen/clearpad_core.c:	if (should_wake && !(active & SYN_ACTIVE_POWER)) {
NeoLKernel/drivers/input/touchscreen/clearpad_core.c:	} else if (!should_wake && (active & SYN_ACTIVE_POWER)) {
NeoLKernel/drivers/input/touchscreen/clearpad_core.c:		dev_info(&this->pdev->dev, "no change (%d)\n", should_wake);
NeoLKernel/drivers/input/touchscreen/clearpad_core.c:		/* wake up during flashing */
NeoLKernel/drivers/input/touchscreen/clearpad_core.c:	/* wake up */
NeoLKernel/drivers/input/touchscreen/cy8ctma300_spi.c:			wake_up_interruptible(&tp->wq);
NeoLKernel/drivers/input/touchscreen/cy8ctma300_spi.c:		wake_up_interruptible(&tp->wq);
NeoLKernel/drivers/input/touchscreen/cy8ctma300_spi.c:		wake_up_interruptible(&tp->wq);
NeoLKernel/drivers/input/touchscreen/cy8ctma300_spi.c:	dev_dbg(&spi->dev, "%s: SPI_CS wake-up sequence start\n", __func__);
NeoLKernel/drivers/input/touchscreen/cy8ctma300_spi.c:	dev_dbg(&spi->dev, "%s: SPI_CS wake-up sequence end, OK\n", __func__);
NeoLKernel/drivers/input/touchscreen/migor_ts.c:	device_init_wakeup(&client->dev, 1);
NeoLKernel/drivers/input/touchscreen/migor_ts.c:	if (device_may_wakeup(&client->dev))
NeoLKernel/drivers/input/touchscreen/migor_ts.c:		enable_irq_wake(priv->irq);
NeoLKernel/drivers/input/touchscreen/migor_ts.c:	if (device_may_wakeup(&client->dev))
NeoLKernel/drivers/input/touchscreen/migor_ts.c:		disable_irq_wake(priv->irq);
NeoLKernel/drivers/input/touchscreen/msm_ts.c:	if (device_may_wakeup(dev) &&
NeoLKernel/drivers/input/touchscreen/msm_ts.c:			device_may_wakeup(dev->parent))
NeoLKernel/drivers/input/touchscreen/msm_ts.c:		enable_irq_wake(ts->sample_irq);
NeoLKernel/drivers/input/touchscreen/msm_ts.c:	if (device_may_wakeup(dev) &&
NeoLKernel/drivers/input/touchscreen/msm_ts.c:			device_may_wakeup(dev->parent))
NeoLKernel/drivers/input/touchscreen/msm_ts.c:		disable_irq_wake(ts->sample_irq);
NeoLKernel/drivers/input/touchscreen/msm_ts.c:	device_init_wakeup(&pdev->dev, pdata->can_wakeup);
NeoLKernel/drivers/input/touchscreen/msm_ts.c:	device_init_wakeup(&pdev->dev, 0);
NeoLKernel/drivers/input/touchscreen/ucb1400_ts.c:		wake_up(&ucb->ts_wait);
NeoLKernel/drivers/input/touchscreen/ucb1400_ts.c:		wake_up(&ucb->ts_wait);
NeoLKernel/drivers/input/touchscreen/wm97xx-core.c: * stickyness and wake up.
NeoLKernel/drivers/input/touchscreen/wm97xx-core.c:		   enum wm97xx_gpio_wake wake)
NeoLKernel/drivers/input/touchscreen/wm97xx-core.c:	if (wake == WM97XX_GPIO_WAKE)
NeoLKernel/drivers/input/touchscreen/wm97xx-core.c: * wakeup sysfs entries.
NeoLKernel/drivers/input/touchscreen/wm97xx-core.c:	device_init_wakeup(&wm->input_dev->dev, mode != 0);
NeoLKernel/drivers/input/touchscreen/wm97xx-core.c:	if (device_may_wakeup(&wm->input_dev->dev))
NeoLKernel/drivers/input/touchscreen/cyttsp-i2c.c:	/* re-enable the interrupt prior to wake device */
NeoLKernel/drivers/input/touchscreen/cyttsp_core.c:#define cyttsp_wake_data cyttsp_xydata
NeoLKernel/drivers/input/touchscreen/cyttsp_core.c:		wake_up(&ts->wq);
NeoLKernel/drivers/input/touchscreen/cyttsp_core.c:		if (!ts->platform_data->wakeup) {
NeoLKernel/drivers/input/touchscreen/cyttsp_core.c:			retval = ts->platform_data->wakeup();
NeoLKernel/drivers/input/touchscreen/eeti_ts.c:	device_init_wakeup(&client->dev, 0);
NeoLKernel/drivers/input/touchscreen/eeti_ts.c:	if (device_may_wakeup(&client->dev))
NeoLKernel/drivers/input/touchscreen/eeti_ts.c:		enable_irq_wake(priv->irq);
NeoLKernel/drivers/input/touchscreen/eeti_ts.c:	if (device_may_wakeup(&client->dev))
NeoLKernel/drivers/input/touchscreen/eeti_ts.c:		disable_irq_wake(priv->irq);
NeoLKernel/drivers/input/touchscreen/elan8232_i2c.c:						"%s: wake up tp failed! \
NeoLKernel/drivers/input/touchscreen/elan8232_i2c.c:					"%s: wake up tp failed! err = %d\n",
NeoLKernel/drivers/isdn/capi/capi.c:		wake_up_interruptible(&cdev->recvwait);
NeoLKernel/drivers/isdn/capi/capi.c:		wake_up_interruptible(&cdev->recvwait);
NeoLKernel/drivers/isdn/capi/capi.c:	wake_up_interruptible(&cdev->recvwait);
NeoLKernel/drivers/isdn/capi/capi.c:		wake_up_interruptible(&cdev->recvwait);
NeoLKernel/drivers/isdn/capi/capi.c:			tty_wakeup(mp->tty);
NeoLKernel/drivers/isdn/capi/capi.c:		wake_up_interruptible(&cdev->recvwait);
NeoLKernel/drivers/isdn/divert/divert_procfs.c:	wake_up_interruptible(&(rd_queue));
NeoLKernel/drivers/isdn/gigaset/bas-gigaset.c:	wake_up(&ucs->waitqueue);
NeoLKernel/drivers/isdn/gigaset/bas-gigaset.c:	wake_up(&ucs->waitqueue);
NeoLKernel/drivers/isdn/gigaset/bas-gigaset.c:	wake_up(&ucs->waitqueue);
NeoLKernel/drivers/isdn/gigaset/bas-gigaset.c:	wake_up(&ucs->waitqueue);
NeoLKernel/drivers/isdn/gigaset/bas-gigaset.c:	if (cb->wake_tasklet)
NeoLKernel/drivers/isdn/gigaset/bas-gigaset.c:		tasklet_schedule(cb->wake_tasklet);
NeoLKernel/drivers/isdn/gigaset/bas-gigaset.c:	wake_up(&ucs->waitqueue);
NeoLKernel/drivers/isdn/gigaset/bas-gigaset.c: *	wake_tasklet	tasklet to run when transmission is completed
NeoLKernel/drivers/isdn/gigaset/bas-gigaset.c:			     struct tasklet_struct *wake_tasklet)
NeoLKernel/drivers/isdn/gigaset/bas-gigaset.c:	cb->wake_tasklet = wake_tasklet;
NeoLKernel/drivers/isdn/gigaset/bas-gigaset.c:	if (wake_tasklet)
NeoLKernel/drivers/isdn/gigaset/bas-gigaset.c:		tasklet_schedule(wake_tasklet);
NeoLKernel/drivers/isdn/gigaset/common.c:		wake_up_interruptible(&cs->waitqueue);
NeoLKernel/drivers/isdn/gigaset/ev-layer.c:	wake_up(&cs->waitqueue);
NeoLKernel/drivers/isdn/gigaset/ev-layer.c:	wake_up(&cs->waitqueue);
NeoLKernel/drivers/isdn/gigaset/ev-layer.c:		wake_up(&cs->waitqueue);
NeoLKernel/drivers/isdn/gigaset/ev-layer.c:		wake_up(&cs->waitqueue);
NeoLKernel/drivers/isdn/gigaset/ev-layer.c:		wake_up(&cs->waitqueue);
NeoLKernel/drivers/isdn/gigaset/gigaset.h:	struct tasklet_struct if_wake_tasklet;
NeoLKernel/drivers/isdn/gigaset/gigaset.h:	struct tasklet_struct *wake_tasklet;
NeoLKernel/drivers/isdn/gigaset/gigaset.h:			 struct tasklet_struct *wake_tasklet);
NeoLKernel/drivers/isdn/gigaset/interface.c:					    &cs->if_wake_tasklet);
NeoLKernel/drivers/isdn/gigaset/interface.c:/* wakeup tasklet for the write operation */
NeoLKernel/drivers/isdn/gigaset/interface.c:static void if_wake(unsigned long data)
NeoLKernel/drivers/isdn/gigaset/interface.c:		tty_wakeup(cs->tty);
NeoLKernel/drivers/isdn/gigaset/interface.c:	tasklet_init(&cs->if_wake_tasklet, &if_wake, (unsigned long) cs);
NeoLKernel/drivers/isdn/gigaset/interface.c:	tasklet_disable(&cs->if_wake_tasklet);
NeoLKernel/drivers/isdn/gigaset/interface.c:	tasklet_kill(&cs->if_wake_tasklet);
NeoLKernel/drivers/isdn/gigaset/ser-gigaset.c:		if (tcb->wake_tasklet)
NeoLKernel/drivers/isdn/gigaset/ser-gigaset.c:			tasklet_schedule(tcb->wake_tasklet);
NeoLKernel/drivers/isdn/gigaset/ser-gigaset.c:		if (cb->wake_tasklet)
NeoLKernel/drivers/isdn/gigaset/ser-gigaset.c:			tasklet_schedule(cb->wake_tasklet);
NeoLKernel/drivers/isdn/gigaset/ser-gigaset.c: *	wake_tasklet	tasklet to run when transmission is complete, or NULL
NeoLKernel/drivers/isdn/gigaset/ser-gigaset.c:                             int len, struct tasklet_struct *wake_tasklet)
NeoLKernel/drivers/isdn/gigaset/ser-gigaset.c:	cb->wake_tasklet = wake_tasklet;
NeoLKernel/drivers/isdn/gigaset/ser-gigaset.c:gigaset_tty_wakeup(struct tty_struct *tty)
NeoLKernel/drivers/isdn/gigaset/ser-gigaset.c:	.write_wakeup	= gigaset_tty_wakeup,
NeoLKernel/drivers/isdn/gigaset/usb-gigaset.c:			if (tcb->wake_tasklet)
NeoLKernel/drivers/isdn/gigaset/usb-gigaset.c:				tasklet_schedule(tcb->wake_tasklet);
NeoLKernel/drivers/isdn/gigaset/usb-gigaset.c:				cb->len = 0; /* skip urb => remove cb+wakeup
NeoLKernel/drivers/isdn/gigaset/usb-gigaset.c:			     int len, struct tasklet_struct *wake_tasklet)
NeoLKernel/drivers/isdn/gigaset/usb-gigaset.c:	cb->wake_tasklet = wake_tasklet;
NeoLKernel/drivers/isdn/hardware/eicon/divamnt.c: * wake up reader
NeoLKernel/drivers/isdn/hardware/eicon/divamnt.c:void diva_maint_wakeup_read(void)
NeoLKernel/drivers/isdn/hardware/eicon/divamnt.c:	wake_up_interruptible(&msgwaitq);
NeoLKernel/drivers/isdn/hardware/eicon/debug.c:      diva_maint_wakeup_read();
NeoLKernel/drivers/isdn/hardware/eicon/debug.c:        diva_maint_wakeup_read();
NeoLKernel/drivers/isdn/hardware/eicon/debug.c:    diva_maint_wakeup_read();
NeoLKernel/drivers/isdn/hardware/eicon/debug.c:    diva_maint_wakeup_read();
NeoLKernel/drivers/isdn/hardware/eicon/debug.c:        diva_maint_wakeup_read();
NeoLKernel/drivers/isdn/hardware/eicon/debug.c:      diva_maint_wakeup_read();
NeoLKernel/drivers/isdn/hardware/eicon/debug_if.h:void diva_maint_wakeup_read (void);
NeoLKernel/drivers/isdn/hardware/eicon/di.h:  void ( * istream_wakeup)(ADAPTER* a);
NeoLKernel/drivers/isdn/hardware/eicon/istream.c:  wake up corresponding application
NeoLKernel/drivers/isdn/hardware/eicon/s_pri.c:  a->istream_wakeup   = pr_stream;
NeoLKernel/drivers/isdn/hardware/eicon/um_idi.c:extern void diva_os_wakeup_read(void *os_context);
NeoLKernel/drivers/isdn/hardware/eicon/um_idi.c:extern void diva_os_wakeup_close(void *os_context);
NeoLKernel/drivers/isdn/hardware/eicon/um_idi.c:			diva_os_wakeup_read(e->os_context);
NeoLKernel/drivers/isdn/hardware/eicon/um_idi.c:			diva_os_wakeup_close(e->os_context);
NeoLKernel/drivers/isdn/hardware/eicon/um_idi.c:			diva_os_wakeup_read(e->os_context);
NeoLKernel/drivers/isdn/hardware/eicon/um_idi.c:			diva_os_wakeup_read(e->os_context);
NeoLKernel/drivers/isdn/hardware/eicon/um_idi.c:	int call_wakeup = 0;
NeoLKernel/drivers/isdn/hardware/eicon/um_idi.c:		if ((call_wakeup = process_idi_rc(e, e->e.Rc))) {
NeoLKernel/drivers/isdn/hardware/eicon/um_idi.c:		if (call_wakeup) {
NeoLKernel/drivers/isdn/hardware/eicon/um_idi.c:			diva_os_wakeup_read(e->os_context);
NeoLKernel/drivers/isdn/hardware/eicon/um_idi.c:			diva_os_wakeup_close(e->os_context);
NeoLKernel/drivers/isdn/hardware/eicon/um_idi.c:			call_wakeup = process_idi_ind(e, e->e.Ind);
NeoLKernel/drivers/isdn/hardware/eicon/um_idi.c:		if (call_wakeup) {
NeoLKernel/drivers/isdn/hardware/eicon/um_idi.c:			diva_os_wakeup_read(e->os_context);
NeoLKernel/drivers/isdn/hardware/eicon/um_idi.c:	int do_wakeup = 0;
NeoLKernel/drivers/isdn/hardware/eicon/um_idi.c:			do_wakeup = 1;
NeoLKernel/drivers/isdn/hardware/eicon/um_idi.c:		do_wakeup = 1;
NeoLKernel/drivers/isdn/hardware/eicon/um_idi.c:		do_wakeup = 0;
NeoLKernel/drivers/isdn/hardware/eicon/um_idi.c:	return (do_wakeup);
NeoLKernel/drivers/isdn/hardware/eicon/divasi.c:void diva_os_wakeup_read(void *os_context)
NeoLKernel/drivers/isdn/hardware/eicon/divasi.c:	wake_up_interruptible(&p_os->read_wait);
NeoLKernel/drivers/isdn/hardware/eicon/divasi.c:void diva_os_wakeup_close(void *os_context)
NeoLKernel/drivers/isdn/hardware/eicon/divasi.c:	wake_up_interruptible(&p_os->close_wait);
NeoLKernel/drivers/isdn/hardware/eicon/divasi.c:	wake_up_interruptible(&p_os->read_wait);
NeoLKernel/drivers/isdn/hardware/eicon/divasi.c:	wake_up_interruptible(&p_os->close_wait);
NeoLKernel/drivers/isdn/hardware/mISDN/hfcpci.c:	hc->hw.sctrl_e = HFCPCI_AUTO_AWAKE;	/* S/T Auto awake */
NeoLKernel/drivers/isdn/hisax/arcofi.c:		wake_up(&cs->dc.isac.arcofi_wait);
NeoLKernel/drivers/isdn/hisax/arcofi.c:						wake_up(&cs->dc.isac.arcofi_wait);
NeoLKernel/drivers/isdn/hisax/arcofi.c:					wake_up(&cs->dc.isac.arcofi_wait);
NeoLKernel/drivers/isdn/hisax/callc.c:lli_writewakeup(struct PStack *st, int len)
NeoLKernel/drivers/isdn/hisax/callc.c:		link_debug(chanp, 0, "llwakeup: %d", len);
NeoLKernel/drivers/isdn/hisax/elsa_ser.c:	 * here so the queue might never be waken up
NeoLKernel/drivers/isdn/hisax/isdnl1.c:		lli_writewakeup(bcs->st, ack);
NeoLKernel/drivers/isdn/hisax/isdnl2.c:			lli_writewakeup(st, len);
NeoLKernel/drivers/isdn/hisax/hfcscard.c:	cs->BC_Write_Reg(cs, HFCD_DATA, HFCD_TEST, HFCD_AUTO_AWAKE); /* S/T Auto awake */
NeoLKernel/drivers/isdn/hisax/hfc_pci.c:	Write_hfc(cs, HFCPCI_SCTRL_E, cs->hw.hfcpci.sctrl_e);	/* S/T Auto awake */
NeoLKernel/drivers/isdn/hisax/hfc_sx.c:	Write_hfc(cs, HFCSX_SCTRL_E, cs->hw.hfcsx.sctrl_e);	/* S/T Auto awake */
NeoLKernel/drivers/isdn/hisax/hisax.h:void lli_writewakeup(struct PStack *st, int len);
NeoLKernel/drivers/isdn/hysdn/hysdn_proclog.c:	wake_up_interruptible(&(pd->rd_queue));		/* announce new entry */
NeoLKernel/drivers/isdn/i4l/isdn_audio.c:			wake_up_interruptible(&dev->drv[di]->rcv_waitq[ch]);
NeoLKernel/drivers/isdn/i4l/isdn_audio.c:	wake_up_interruptible(&dev->drv[di]->rcv_waitq[ch]);
NeoLKernel/drivers/isdn/i4l/isdn_common.c:		wake_up_interruptible(&dev->drv[di]->rcv_waitq[channel]);
NeoLKernel/drivers/isdn/i4l/isdn_common.c:			wake_up_interruptible(&dev->drv[di]->snd_waitq[c->arg]);
NeoLKernel/drivers/isdn/i4l/isdn_common.c:			wake_up_interruptible(&dev->drv[di]->st_waitq);
NeoLKernel/drivers/isdn/i4l/isdn_common.c:	wake_up_interruptible(&(dev->info_waitq));
NeoLKernel/drivers/isdn/i4l/isdn_net.c: * wake up the network -> net_device queue.
NeoLKernel/drivers/isdn/i4l/isdn_net.c: * For slaves, wake the corresponding master interface.
NeoLKernel/drivers/isdn/i4l/isdn_net.c:static __inline__ void isdn_net_device_wake_queue(isdn_net_local *lp)
NeoLKernel/drivers/isdn/i4l/isdn_net.c:		netif_wake_queue(lp->master);
NeoLKernel/drivers/isdn/i4l/isdn_net.c:		netif_wake_queue(lp->netdev->dev);
NeoLKernel/drivers/isdn/i4l/isdn_net.c:			isdn_net_device_wake_queue(lp);
NeoLKernel/drivers/isdn/i4l/isdn_net.c:	   we need to call netif_start_queue, not netif_wake_queue here */
NeoLKernel/drivers/isdn/i4l/isdn_net.c:							isdn_ppp_wakeup_daemon(lp);
NeoLKernel/drivers/isdn/i4l/isdn_net.c:							isdn_net_device_wake_queue(lp);
NeoLKernel/drivers/isdn/i4l/isdn_net.c:		 * works at all because if we always wake up the interface,
NeoLKernel/drivers/isdn/i4l/isdn_net.c:	netif_wake_queue(ndev);
NeoLKernel/drivers/isdn/i4l/isdn_ppp.c:		isdn_ppp_closewait(lp->ppp_slot);	/* force wakeup on ippp device */
NeoLKernel/drivers/isdn/i4l/isdn_ppp.c: * (wakes up daemon after B-channel connect)
NeoLKernel/drivers/isdn/i4l/isdn_ppp.c:isdn_ppp_wakeup_daemon(isdn_net_local * lp)
NeoLKernel/drivers/isdn/i4l/isdn_ppp.c:	wake_up_interruptible(&ippp_table[lp->ppp_slot]->wq);
NeoLKernel/drivers/isdn/i4l/isdn_ppp.c: * force wakeup of the ippp device
NeoLKernel/drivers/isdn/i4l/isdn_ppp.c:		wake_up_interruptible(&is->wq);
NeoLKernel/drivers/isdn/i4l/isdn_ppp.c:		is->state &= ~IPPP_CONNECT;	/* -> effect: no call of wakeup */
NeoLKernel/drivers/isdn/i4l/isdn_ppp.c:		 * removing the IPPP_CONNECT flag omits calling of isdn_ppp_wakeup_daemon()
NeoLKernel/drivers/isdn/i4l/isdn_ppp.c:					netif_wake_queue(lp->netdev->dev);
NeoLKernel/drivers/isdn/i4l/isdn_ppp.c:	wake_up_interruptible(&is->wq);
NeoLKernel/drivers/isdn/i4l/isdn_ppp.c:/* Push an empty CCP Data Frame up to the daemon to wake it up and let it
NeoLKernel/drivers/isdn/i4l/isdn_ppp.h:extern void isdn_ppp_wakeup_daemon(isdn_net_local *);
NeoLKernel/drivers/isdn/i4l/isdn_tty.c:		tty_wakeup(tty);
NeoLKernel/drivers/isdn/i4l/isdn_tty.c:						 * c originally was non-zero, do a wakeup.
NeoLKernel/drivers/isdn/i4l/isdn_tty.c:						tty_wakeup(tty);
NeoLKernel/drivers/isdn/i4l/isdn_tty.c:	tty_wakeup(tty);
NeoLKernel/drivers/isdn/i4l/isdn_tty.c:		wake_up_interruptible(&info->open_wait);
NeoLKernel/drivers/isdn/i4l/isdn_tty.c:	wake_up_interruptible(&info->close_wait);
NeoLKernel/drivers/isdn/i4l/isdn_tty.c:	wake_up_interruptible(&info->open_wait);
NeoLKernel/drivers/isdn/i4l/isdn_tty.c:					wake_up_interruptible(&info->open_wait);
NeoLKernel/drivers/isdn/mISDN/stack.c:		wake_up_interruptible(&st->workq);
NeoLKernel/drivers/isdn/mISDN/stack.c:			printk(KERN_DEBUG "%s: %s wake status %08lx\n",
NeoLKernel/drivers/isdn/mISDN/stack.c:		wake_up_interruptible(&st->workq);
NeoLKernel/drivers/isdn/mISDN/timerdev.c:	wake_up_interruptible(&timer->dev->wait);
NeoLKernel/drivers/isdn/mISDN/timerdev.c:		wake_up_interruptible(&dev->wait);
NeoLKernel/drivers/isdn/pcbit/drv.c:	wake_up_interruptible(&dev->set_running_wq);
NeoLKernel/drivers/isdn/pcbit/layer2.c:		wake_up_interruptible(&dev->set_running_wq);
NeoLKernel/drivers/leds/leds-as3676.c:		 *  register and it affects the brightness soon after wakeup.
NeoLKernel/drivers/leds/leds-as3676.c:	device_init_wakeup(&client->dev, 0);
NeoLKernel/drivers/lguest/core.c:		 * clock timer will wake us.
NeoLKernel/drivers/lguest/interrupts_and_traps.c:	if (!wake_up_process(cpu->tsk))
NeoLKernel/drivers/lguest/lguest_user.c:	 * other Guests want to wake this one (eg. console input).
NeoLKernel/drivers/macintosh/adb.c:		wake_up_interruptible(&state->wait_queue);
NeoLKernel/drivers/macintosh/smu.c:	wake_up_all(&pp->wait);
NeoLKernel/drivers/macintosh/via-pmu.c:static int option_lid_wakeup = 1;
NeoLKernel/drivers/macintosh/via-pmu.c:		p += sprintf(p, "lid_wakeup=%d\n", option_lid_wakeup);
NeoLKernel/drivers/macintosh/via-pmu.c:		if (!strcmp(label, "lid_wakeup"))
NeoLKernel/drivers/macintosh/via-pmu.c:			option_lid_wakeup = ((*val) == '1');
NeoLKernel/drivers/macintosh/via-pmu.c:		 * wake up again
NeoLKernel/drivers/macintosh/via-pmu.c:	/* We're awake again, stop grackle PM */
NeoLKernel/drivers/macintosh/via-pmu.c:	/* Tell PMU what events will wake us up */
NeoLKernel/drivers/macintosh/via-pmu.c:		(option_lid_wakeup ? PMU_PWR_WAKEUP_LID_OPEN : 0));
NeoLKernel/drivers/macintosh/via-pmu.c:	/* OK, we're awake again, start restoring things */
NeoLKernel/drivers/macintosh/via-pmu.c:			wake_up_interruptible(&pp->wait);
NeoLKernel/drivers/macintosh/via-pmu.c:	/* Call platform functions marked "on wake" */
NeoLKernel/drivers/md/bitmap.c: * wait if count gets too high, wake when it drops to half.
NeoLKernel/drivers/md/bitmap.c:		wake_up(&bitmap->write_wait);
NeoLKernel/drivers/md/bitmap.c:		md_wakeup_thread(bitmap->mddev->thread);
NeoLKernel/drivers/md/bitmap.c: * bitmap daemon -- periodically wakes up to clean bits and flush pages
NeoLKernel/drivers/md/bitmap.c:			wake_up(&bitmap->overflow_wait);
NeoLKernel/drivers/md/bitmap.h:	 * the bitmap daemon - periodically wakes up and sweeps the bitmap
NeoLKernel/drivers/md/dm-io.c:			wake_up_process(io->sleeper);
NeoLKernel/drivers/md/dm-kcopyd.c:static void wake(struct dm_kcopyd_client *kc)
NeoLKernel/drivers/md/dm-kcopyd.c:		wake_up(&kc->destroyq);
NeoLKernel/drivers/md/dm-kcopyd.c:			wake(kc);
NeoLKernel/drivers/md/dm-kcopyd.c:	wake(kc);
NeoLKernel/drivers/md/dm-kcopyd.c:	 * list.  io jobs call wake when they complete and it all
NeoLKernel/drivers/md/dm-kcopyd.c:	wake(kc);
NeoLKernel/drivers/md/dm-kcopyd.c:		wake(kc);
NeoLKernel/drivers/md/dm.c:		wake_up(&md->wait);
NeoLKernel/drivers/md/dm.c:	int wakeup_waiters = 0;
NeoLKernel/drivers/md/dm.c:		wakeup_waiters = 1;
NeoLKernel/drivers/md/dm.c:	if (wakeup_waiters)
NeoLKernel/drivers/md/dm.c:		wake_up(&md->wait);
NeoLKernel/drivers/md/dm.c:			wake_up(&md->wait);
NeoLKernel/drivers/md/dm.c:	wake_up(&md->eventq);
NeoLKernel/drivers/md/md.c:	wake_up(&md_event_waiters);
NeoLKernel/drivers/md/md.c:	wake_up(&md_event_waiters);
NeoLKernel/drivers/md/md.c:		wake_up(&mddev->sb_wait);
NeoLKernel/drivers/md/md.c:	wake_up(&mddev->sb_wait);
NeoLKernel/drivers/md/md.c:	md_wakeup_thread(mddev->thread);
NeoLKernel/drivers/md/md.c:		wake_up(&mddev->sb_wait);
NeoLKernel/drivers/md/md.c:		wake_up(&mddev->sb_wait);
NeoLKernel/drivers/md/md.c:		wake_up(&mddev->sb_wait);
NeoLKernel/drivers/md/md.c:	wake_up(&mddev->sb_wait);
NeoLKernel/drivers/md/md.c:		wake_up(&rdev->blocked_wait);
NeoLKernel/drivers/md/md.c:		md_wakeup_thread(rdev->mddev->thread);
NeoLKernel/drivers/md/md.c:		md_wakeup_thread(rdev->mddev->thread);
NeoLKernel/drivers/md/md.c:		/* don't wakeup anyone, leave that to userspace. */
NeoLKernel/drivers/md/md.c:	md_wakeup_thread(mddev->thread);
NeoLKernel/drivers/md/md.c:			wake_up(&mddev->sb_wait);
NeoLKernel/drivers/md/md.c:	md_wakeup_thread(mddev->thread);
NeoLKernel/drivers/md/md.c:		wake_up(&resync_wait);
NeoLKernel/drivers/md/md.c:	wake_up(&mddev->recovery_wait);
NeoLKernel/drivers/md/md.c:	md_wakeup_thread(mddev->thread);
NeoLKernel/drivers/md/md.c:	md_wakeup_thread(mddev->thread);
NeoLKernel/drivers/md/md.c:	md_wakeup_thread(mddev->sync_thread); /* possibly kick off a reshape */
NeoLKernel/drivers/md/md.c:	md_wakeup_thread(mddev->thread);
NeoLKernel/drivers/md/md.c:	md_wakeup_thread(mddev->sync_thread);
NeoLKernel/drivers/md/md.c:		md_wakeup_thread(mddev->thread);
NeoLKernel/drivers/md/md.c:	md_wakeup_thread(mddev->thread);
NeoLKernel/drivers/md/md.c:			md_wakeup_thread(mddev->thread);
NeoLKernel/drivers/md/md.c:void md_wakeup_thread(mdk_thread_t *thread)
NeoLKernel/drivers/md/md.c:		wake_up(&thread->wqueue);
NeoLKernel/drivers/md/md.c:	md_wakeup_thread(mddev->thread);
NeoLKernel/drivers/md/md.c:	wake_up(&mddev->recovery_wait);
NeoLKernel/drivers/md/md.c:		md_wakeup_thread(mddev->thread);
NeoLKernel/drivers/md/md.c:		md_wakeup_thread(mddev->thread);
NeoLKernel/drivers/md/md.c:		md_wakeup_thread(mddev->sync_thread);
NeoLKernel/drivers/md/md.c:			md_wakeup_thread(mddev->thread);
NeoLKernel/drivers/md/md.c:			md_wakeup_thread(mddev->thread);
NeoLKernel/drivers/md/md.c:					wake_up(&resync_wait);
NeoLKernel/drivers/md/md.c:	wake_up(&resync_wait);
NeoLKernel/drivers/md/md.c:	md_wakeup_thread(mddev->thread);
NeoLKernel/drivers/md/md.c: * and wakeups up this thread which will reap the thread and finish up.
NeoLKernel/drivers/md/md.c:				md_wakeup_thread(mddev->sync_thread);
NeoLKernel/drivers/md/md.c:EXPORT_SYMBOL(md_wakeup_thread);
NeoLKernel/drivers/md/md.h:extern void md_wakeup_thread(mdk_thread_t *thread);
NeoLKernel/drivers/md/multipath.c:	md_wakeup_thread(mddev->thread);
NeoLKernel/drivers/md/raid1.c:	wake_up(&conf->wait_barrier);
NeoLKernel/drivers/md/raid1.c:	md_wakeup_thread(mddev->thread);
NeoLKernel/drivers/md/raid1.c:	md_wakeup_thread(mddev->thread);
NeoLKernel/drivers/md/raid1.c:	wake_up(&conf->wait_barrier);
NeoLKernel/drivers/md/raid1.c:	wake_up(&conf->wait_barrier);
NeoLKernel/drivers/md/raid1.c:	wake_up(&conf->wait_barrier);
NeoLKernel/drivers/md/raid1.c:	wake_up(&conf->wait_barrier);
NeoLKernel/drivers/md/raid1.c:		md_wakeup_thread(mddev->thread);
NeoLKernel/drivers/md/raid1.c:	md_wakeup_thread(mddev->thread);
NeoLKernel/drivers/md/raid10.c:	/* wake up frozen array... */
NeoLKernel/drivers/md/raid10.c:	wake_up(&conf->wait_barrier);
NeoLKernel/drivers/md/raid10.c:	md_wakeup_thread(mddev->thread);
NeoLKernel/drivers/md/raid10.c:	md_wakeup_thread(mddev->thread);
NeoLKernel/drivers/md/raid10.c:	wake_up(&conf->wait_barrier);
NeoLKernel/drivers/md/raid10.c:	wake_up(&conf->wait_barrier);
NeoLKernel/drivers/md/raid10.c:	wake_up(&conf->wait_barrier);
NeoLKernel/drivers/md/raid10.c:	wake_up(&conf->wait_barrier);
NeoLKernel/drivers/md/raid10.c:		md_wakeup_thread(mddev->thread);
NeoLKernel/drivers/md/raid10.c:		md_wakeup_thread(mddev->thread);
NeoLKernel/drivers/md/raid5.c:			md_wakeup_thread(conf->mddev->thread);
NeoLKernel/drivers/md/raid5.c:					md_wakeup_thread(conf->mddev->thread);
NeoLKernel/drivers/md/raid5.c:				wake_up(&conf->wait_for_stripe);
NeoLKernel/drivers/md/raid5.c:					md_wakeup_thread(conf->mddev->thread);
NeoLKernel/drivers/md/raid5.c:				wake_up(&sh->raid_conf->wait_for_overlap);
NeoLKernel/drivers/md/raid5.c:	wake_up(&sh->ops.wait_for_ops);
NeoLKernel/drivers/md/raid5.c:			wake_up(&conf->wait_for_overlap);
NeoLKernel/drivers/md/raid5.c:				wake_up(&conf->wait_for_overlap);
NeoLKernel/drivers/md/raid5.c:			md_wakeup_thread(conf->mddev->thread);
NeoLKernel/drivers/md/raid5.c:			md_wakeup_thread(conf->mddev->thread);
NeoLKernel/drivers/md/raid5.c:				md_wakeup_thread(conf->mddev->thread);
NeoLKernel/drivers/md/raid5.c:		wake_up(&conf->wait_for_overlap);
NeoLKernel/drivers/md/raid5.c:				md_wakeup_thread(conf->mddev->thread);
NeoLKernel/drivers/md/raid5.c:		wake_up(&conf->wait_for_overlap);
NeoLKernel/drivers/md/raid5.c:	md_wakeup_thread(mddev->thread);
NeoLKernel/drivers/md/raid5.c:	md_wakeup_thread(conf->mddev->thread);
NeoLKernel/drivers/md/raid5.c:			wake_up(&conf->wait_for_stripe);
NeoLKernel/drivers/md/raid5.c:		md_wakeup_thread(mddev->thread);
NeoLKernel/drivers/md/raid5.c:		wake_up(&conf->wait_for_overlap);
NeoLKernel/drivers/md/raid5.c:		md_wakeup_thread(mddev->thread);
NeoLKernel/drivers/md/raid5.c:		wake_up(&conf->wait_for_overlap);
NeoLKernel/drivers/md/raid5.c:		wake_up(&conf->wait_for_stripe);
NeoLKernel/drivers/md/raid5.c: * handler, so that they will not have to wait for our next wakeup.
NeoLKernel/drivers/md/raid5.c:	md_wakeup_thread(mddev->sync_thread);
NeoLKernel/drivers/md/raid5.c:		wake_up(&conf->wait_for_overlap);
NeoLKernel/drivers/md/raid5.c:		wake_up(&conf->wait_for_overlap);
NeoLKernel/drivers/md/raid5.c:		wake_up(&conf->wait_for_overlap);
NeoLKernel/drivers/md/raid5.c:		wake_up(&conf->wait_for_stripe);
NeoLKernel/drivers/md/raid5.c:		wake_up(&conf->wait_for_overlap);
NeoLKernel/drivers/md/raid5.c:		md_wakeup_thread(mddev->thread);
NeoLKernel/drivers/md/dm-raid1.c:static void wakeup_mirrord(void *context)
NeoLKernel/drivers/md/dm-raid1.c:static void delayed_wake_fn(unsigned long data)
NeoLKernel/drivers/md/dm-raid1.c:	wakeup_mirrord(ms);
NeoLKernel/drivers/md/dm-raid1.c:static void delayed_wake(struct mirror_set *ms)
NeoLKernel/drivers/md/dm-raid1.c:	ms->timer.function = delayed_wake_fn;
NeoLKernel/drivers/md/dm-raid1.c:static void wakeup_all_recovery_waiters(void *context)
NeoLKernel/drivers/md/dm-raid1.c:	wake_up_all(&_kmirrord_recovery_stopped);
NeoLKernel/drivers/md/dm-raid1.c:	int should_wake = 0;
NeoLKernel/drivers/md/dm-raid1.c:	should_wake = !(bl->head);
NeoLKernel/drivers/md/dm-raid1.c:	if (should_wake)
NeoLKernel/drivers/md/dm-raid1.c:		wakeup_mirrord(ms);
NeoLKernel/drivers/md/dm-raid1.c:	int should_wake = 0;
NeoLKernel/drivers/md/dm-raid1.c:			should_wake = 1;
NeoLKernel/drivers/md/dm-raid1.c:		if (should_wake)
NeoLKernel/drivers/md/dm-raid1.c:			wakeup_mirrord(ms);
NeoLKernel/drivers/md/dm-raid1.c:		delayed_wake(ms);
NeoLKernel/drivers/md/dm-raid1.c:		wakeup_mirrord(ms);
NeoLKernel/drivers/md/dm-raid1.c:	delayed_wake(ms);
NeoLKernel/drivers/md/dm-raid1.c:	ms->rh = dm_region_hash_create(ms, dispatch_bios, wakeup_mirrord,
NeoLKernel/drivers/md/dm-raid1.c:				       wakeup_all_recovery_waiters,
NeoLKernel/drivers/md/dm-raid1.c:	wakeup_mirrord(ms);
NeoLKernel/drivers/md/dm-region-hash.c:	/* Callback function to wakeup callers worker thread. */
NeoLKernel/drivers/md/dm-region-hash.c:	void (*wakeup_workers)(void *context);
NeoLKernel/drivers/md/dm-region-hash.c:	/* Callback function to wakeup callers recovery waiters. */
NeoLKernel/drivers/md/dm-region-hash.c:	void (*wakeup_all_recovery_waiters)(void *context);
NeoLKernel/drivers/md/dm-region-hash.c:		void (*wakeup_workers)(void *context),
NeoLKernel/drivers/md/dm-region-hash.c:		void (*wakeup_all_recovery_waiters)(void *context),
NeoLKernel/drivers/md/dm-region-hash.c:	rh->wakeup_workers = wakeup_workers;
NeoLKernel/drivers/md/dm-region-hash.c:	rh->wakeup_all_recovery_waiters = wakeup_all_recovery_waiters;
NeoLKernel/drivers/md/dm-region-hash.c:	 * Dispatch the bios before we call 'wake_up_all'.
NeoLKernel/drivers/md/dm-region-hash.c:	 * the work queue is flushed.  If we wake_up_all
NeoLKernel/drivers/md/dm-region-hash.c:	 * before we dispatch_bios (queue bios and call wake()),
NeoLKernel/drivers/md/dm-region-hash.c:		rh->wakeup_all_recovery_waiters(rh->context);
NeoLKernel/drivers/md/dm-region-hash.c:	int should_wake = 0;
NeoLKernel/drivers/md/dm-region-hash.c:		should_wake = 1;
NeoLKernel/drivers/md/dm-region-hash.c:	if (should_wake)
NeoLKernel/drivers/md/dm-region-hash.c:		rh->wakeup_workers(rh->context);
NeoLKernel/drivers/md/dm-region-hash.c:		rh->wakeup_all_recovery_waiters(rh->context);
NeoLKernel/drivers/md/dm-region-hash.c:	rh->wakeup_workers(rh->context);
NeoLKernel/drivers/md/dm-region-hash.c:	rh->wakeup_workers(rh->context);
NeoLKernel/drivers/md/dm-snap.c: * The percentage increment we will wake up users at
NeoLKernel/drivers/media/common/ir-keymaps.c:	 although it sends data (used for BIOS wakeup?) */
NeoLKernel/drivers/media/common/saa7146_core.c:		/* only wake up if we expect something */
NeoLKernel/drivers/media/common/saa7146_core.c:			wake_up(&dev->i2c_wq);
NeoLKernel/drivers/media/common/saa7146_fops.c:	wake_up(&q->curr->vb.done);
NeoLKernel/drivers/media/common/saa7146_fops.c:			wake_up(&dev->vv_data->vbi_wq);
NeoLKernel/drivers/media/common/tuners/mxl5007t.c:	/* wake from standby */
NeoLKernel/drivers/media/dvb/bt8xx/bt878.c:	/* wake up any waiting processes
NeoLKernel/drivers/media/dvb/dvb-core/dmxdev.c:		wake_up(&dvbdev->wait_queue);
NeoLKernel/drivers/media/dvb/dvb-core/dmxdev.c:	wake_up(&dmxdevfilter->buffer.queue);
NeoLKernel/drivers/media/dvb/dvb-core/dmxdev.c:		wake_up(&dmxdevfilter->buffer.queue);
NeoLKernel/drivers/media/dvb/dvb-core/dmxdev.c:	wake_up(&dmxdevfilter->buffer.queue);
NeoLKernel/drivers/media/dvb/dvb-core/dmxdev.c:		wake_up(&buffer->queue);
NeoLKernel/drivers/media/dvb/dvb-core/dmxdev.c:	wake_up(&buffer->queue);
NeoLKernel/drivers/media/dvb/dvb-core/dmxdev.c:	wake_up(&dmxdevfilter->buffer.queue);
NeoLKernel/drivers/media/dvb/dvb-core/dmxdev.c:		wake_up(&dmxdev->dvbdev->wait_queue);
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ca_en50221.c:	/* Flag indicating the thread should wake up now */
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ca_en50221.c:	unsigned int wakeup:1;
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ca_en50221.c:static void dvb_ca_en50221_thread_wakeup(struct dvb_ca_private *ca);
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ca_en50221.c:	/* wake up readers when a last_fragment is received */
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ca_en50221.c:		wake_up_interruptible(&ca->wait_queue);
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ca_en50221.c:	   already in progress, we do nothing but awake the kernel thread to
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ca_en50221.c:			dvb_ca_en50221_thread_wakeup(ca);
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ca_en50221.c:	/* need to wake up all processes to check if they're now
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ca_en50221.c:	wake_up_interruptible(&ca->wait_queue);
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ca_en50221.c:	dvb_ca_en50221_thread_wakeup(ca);
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ca_en50221.c:		dvb_ca_en50221_thread_wakeup(ca);
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ca_en50221.c:			dvb_ca_en50221_thread_wakeup(ca);
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ca_en50221.c:static void dvb_ca_en50221_thread_wakeup(struct dvb_ca_private *ca)
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ca_en50221.c:	ca->wakeup = 1;
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ca_en50221.c:	wake_up_process(ca->thread);
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ca_en50221.c:		if (!ca->wakeup) {
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ca_en50221.c:		ca->wakeup = 0;
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ca_en50221.c:				ca->wakeup = 1;
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ca_en50221.c:					ca->wakeup = 1;
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ca_en50221.c:						ca->wakeup = 1;
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ca_en50221.c:						ca->wakeup = 1;
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ca_en50221.c:		dvb_ca_en50221_thread_wakeup(ca);
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ca_en50221.c:	dvb_ca_en50221_thread_wakeup(ca);
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ca_en50221.c:	ca->wakeup = 0;
NeoLKernel/drivers/media/dvb/dvb-core/dvb_frontend.c:	unsigned int wakeup;
NeoLKernel/drivers/media/dvb/dvb-core/dvb_frontend.c:static void dvb_frontend_wakeup(struct dvb_frontend *fe);
NeoLKernel/drivers/media/dvb/dvb-core/dvb_frontend.c:	wake_up_interruptible (&events->wait_queue);
NeoLKernel/drivers/media/dvb/dvb-core/dvb_frontend.c:	dvb_frontend_wakeup(fe);
NeoLKernel/drivers/media/dvb/dvb-core/dvb_frontend.c:static int dvb_frontend_should_wakeup(struct dvb_frontend *fe)
NeoLKernel/drivers/media/dvb/dvb-core/dvb_frontend.c:	if (fepriv->wakeup) {
NeoLKernel/drivers/media/dvb/dvb-core/dvb_frontend.c:		fepriv->wakeup = 0;
NeoLKernel/drivers/media/dvb/dvb-core/dvb_frontend.c:static void dvb_frontend_wakeup(struct dvb_frontend *fe)
NeoLKernel/drivers/media/dvb/dvb-core/dvb_frontend.c:	fepriv->wakeup = 1;
NeoLKernel/drivers/media/dvb/dvb-core/dvb_frontend.c:	wake_up_interruptible(&fepriv->wait_queue);
NeoLKernel/drivers/media/dvb/dvb-core/dvb_frontend.c:	fepriv->wakeup = 0;
NeoLKernel/drivers/media/dvb/dvb-core/dvb_frontend.c:			dvb_frontend_should_wakeup(fe) || kthread_should_stop()
NeoLKernel/drivers/media/dvb/dvb-core/dvb_frontend.c:	dvb_frontend_wakeup(fe);
NeoLKernel/drivers/media/dvb/dvb-core/dvb_frontend.c: * Sleep until gettimeofday() > waketime + add_usec
NeoLKernel/drivers/media/dvb/dvb-core/dvb_frontend.c:void dvb_frontend_sleep_until(struct timeval *waketime, u32 add_usec)
NeoLKernel/drivers/media/dvb/dvb-core/dvb_frontend.c:	timeval_usec_add(waketime, add_usec);
NeoLKernel/drivers/media/dvb/dvb-core/dvb_frontend.c:	delta = timeval_usec_diff(lasttime, *waketime);
NeoLKernel/drivers/media/dvb/dvb-core/dvb_frontend.c:		newdelta = timeval_usec_diff(lasttime, *waketime);
NeoLKernel/drivers/media/dvb/dvb-core/dvb_frontend.c:		dvb_frontend_wakeup(fe);
NeoLKernel/drivers/media/dvb/dvb-core/dvb_frontend.c:			wake_up(&dvbdev->wait_queue);
NeoLKernel/drivers/media/dvb/dvb-core/dvb_frontend.h:extern void dvb_frontend_sleep_until(struct timeval *waketime, u32 add_usec);
NeoLKernel/drivers/media/dvb/dvb-core/dvb_net.c:		wake_up(&dvbdev->wait_queue);
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ringbuffer.c:void dvb_ringbuffer_flush_spinlock_wakeup(struct dvb_ringbuffer *rbuf)
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ringbuffer.c:	wake_up(&rbuf->queue);
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ringbuffer.c:EXPORT_SYMBOL(dvb_ringbuffer_flush_spinlock_wakeup);
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ringbuffer.h:/* flush buffer protected by spinlock and wake-up waiting task(s) */
NeoLKernel/drivers/media/dvb/dvb-core/dvb_ringbuffer.h:extern void dvb_ringbuffer_flush_spinlock_wakeup(struct dvb_ringbuffer *rbuf);
NeoLKernel/drivers/media/dvb/dvb-usb/dvb-usb.h: * @fe_init:  rerouted frontend-init (wakeup) function.
NeoLKernel/drivers/media/dvb/dvb-usb/dibusb.h: *                      0x01      wakeup
NeoLKernel/drivers/media/dvb/dvb-usb/dvb-usb-dvb.c:static int dvb_usb_fe_wakeup(struct dvb_frontend *fe)
NeoLKernel/drivers/media/dvb/dvb-usb/dvb-usb-dvb.c:	/* re-assign sleep and wakeup functions */
NeoLKernel/drivers/media/dvb/dvb-usb/dvb-usb-dvb.c:		adap->fe_init  = adap->fe->ops.init;  adap->fe->ops.init  = dvb_usb_fe_wakeup;
NeoLKernel/drivers/media/dvb/firewire/firedtv-avc.c:	wake_up(&fdtv->avc_wait);
NeoLKernel/drivers/media/dvb/frontends/cx24116.c: * Initialise or wake up device
NeoLKernel/drivers/media/dvb/frontends/dib0070.c:			ret = 50;	/* wakeup time */
NeoLKernel/drivers/media/dvb/frontends/dib0070.c:static int dib0070_wakeup(struct dvb_frontend *fe)
NeoLKernel/drivers/media/dvb/frontends/dib0070.c:	.init = dib0070_wakeup,
NeoLKernel/drivers/media/dvb/frontends/sp8870.c:static int sp8870_wake_up(struct sp8870_state* state)
NeoLKernel/drivers/media/dvb/frontends/sp8870.c:	sp8870_wake_up(state);
NeoLKernel/drivers/media/dvb/frontends/stb0899_drv.c:static int stb0899_wakeup(struct dvb_frontend *fe)
NeoLKernel/drivers/media/dvb/frontends/stb0899_drv.c://	.wakeup				= stb0899_wakeup,
NeoLKernel/drivers/media/dvb/frontends/stb0899_drv.c:	stb0899_wakeup(&state->frontend);
NeoLKernel/drivers/media/dvb/frontends/mt312.c:	/* wake up */
NeoLKernel/drivers/media/dvb/frontends/stv090x.c:static int stv090x_wakeup(struct dvb_frontend *fe)
NeoLKernel/drivers/media/dvb/frontends/stv090x.c:	if (stv090x_wakeup(fe) < 0) {
NeoLKernel/drivers/media/dvb/frontends/stv090x.c:	if (stv090x_wakeup(&state->frontend) < 0) {
NeoLKernel/drivers/media/dvb/frontends/tda10023.c:	/* wakeup if in standby */
NeoLKernel/drivers/media/dvb/frontends/tda1004x.c:	/* reset + wake up chip */
NeoLKernel/drivers/media/dvb/frontends/tda1004x.c:	tda1004x_write_mask(state, TDA1004X_CONFADC1, 0x10, 0); // wake up the ADC
NeoLKernel/drivers/media/dvb/frontends/dib7000m.c:static int dib7000m_wakeup(struct dvb_frontend *demod)
NeoLKernel/drivers/media/dvb/frontends/dib7000m.c:	.init                 = dib7000m_wakeup,
NeoLKernel/drivers/media/dvb/frontends/dib7000p.c:static int dib7000p_wakeup(struct dvb_frontend *demod)
NeoLKernel/drivers/media/dvb/frontends/dib7000p.c:	.init                 = dib7000p_wakeup,
NeoLKernel/drivers/media/dvb/frontends/dib8000.c:static int dib8000_wakeup(struct dvb_frontend *fe)
NeoLKernel/drivers/media/dvb/frontends/dib8000.c:	.init = dib8000_wakeup,
NeoLKernel/drivers/media/dvb/siano/smscoreapi.c:	wake_up_interruptible(&coredev->buffer_mng_waitq);
NeoLKernel/drivers/media/dvb/ttpci/av7110.c:		wake_up(&cibuf->queue);
NeoLKernel/drivers/media/dvb/ttpci/av7110.c:			wake_up(&av7110->bmpq);
NeoLKernel/drivers/media/dvb/ttpci/av7110.c:					       dvb_ringbuffer_flush_spinlock_wakeup(&av7110->avout);
NeoLKernel/drivers/media/dvb/ttpci/av7110.c:					       dvb_ringbuffer_flush_spinlock_wakeup(&av7110->aout);
NeoLKernel/drivers/media/dvb/ttpci/av7110_av.c:		wake_up(&buf->queue);
NeoLKernel/drivers/media/dvb/ttpci/av7110_av.c:		wake_up(&buf->queue);
NeoLKernel/drivers/media/dvb/ttpci/av7110_av.c:	wake_up(&buf->queue);
NeoLKernel/drivers/media/dvb/ttpci/av7110_av.c:	wake_up_interruptible(&events->wait_queue);
NeoLKernel/drivers/media/dvb/ttpci/av7110_av.c:		dvb_ringbuffer_flush_spinlock_wakeup(&av7110->avout);
NeoLKernel/drivers/media/dvb/ttpci/av7110_av.c:		dvb_ringbuffer_flush_spinlock_wakeup(&av7110->avout);
NeoLKernel/drivers/media/dvb/ttpci/av7110_av.c:		dvb_ringbuffer_flush_spinlock_wakeup(&av7110->aout);
NeoLKernel/drivers/media/dvb/ttpci/av7110_av.c:		dvb_ringbuffer_flush_spinlock_wakeup(&av7110->aout);
NeoLKernel/drivers/media/dvb/ttpci/av7110_av.c:		dvb_ringbuffer_flush_spinlock_wakeup(&av7110->avout);
NeoLKernel/drivers/media/dvb/ttpci/av7110_av.c:	dvb_ringbuffer_flush_spinlock_wakeup(&av7110->aout);
NeoLKernel/drivers/media/dvb/ttpci/av7110_ca.c:	wake_up_interruptible(&cibuf->queue);
NeoLKernel/drivers/media/dvb/ttpci/av7110_ca.c:	dvb_ringbuffer_flush_spinlock_wakeup(cirbuf);
NeoLKernel/drivers/media/dvb/ttpci/av7110_ca.c:	dvb_ringbuffer_flush_spinlock_wakeup(ciwbuf);
NeoLKernel/drivers/media/radio/radio-cadet.c:		wake_up_interruptible(&dev->read_queue);
NeoLKernel/drivers/media/radio/radio-tavarua.c:	/* wake up read queue */
NeoLKernel/drivers/media/radio/radio-tavarua.c:		wake_up_interruptible(&radio->read_queue);
NeoLKernel/drivers/media/radio/radio-tavarua.c:		wake_up_interruptible(&radio->event_queue);
NeoLKernel/drivers/media/radio/radio-tavarua.c:             FMDBG("Kfifo_put failed:: Not able to wake up the waiting processes\n");
NeoLKernel/drivers/media/radio/radio-tavarua.c:	retval = enable_irq_wake(irq);
NeoLKernel/drivers/media/radio/radio-tavarua.c:	disable_irq_wake(irq);
NeoLKernel/drivers/media/radio/si470x/radio-si470x-usb.c:			wake_up_interruptible(&radio->read_queue);
NeoLKernel/drivers/media/radio/si470x/radio-si470x-usb.c:		wake_up_interruptible(&radio->read_queue);
NeoLKernel/drivers/media/video/arv.c:		 * and wake a process up.
NeoLKernel/drivers/media/video/arv.c:			wake_up_interruptible(&ar->wait);
NeoLKernel/drivers/media/video/au0828/au0828-video.c:	au0828_isocdbg("[%p/%d] wakeup\n", buf, buf->vb.i);
NeoLKernel/drivers/media/video/au0828/au0828-video.c:	wake_up(&buf->vb.done);
NeoLKernel/drivers/media/video/au0828/au0828-video.c:	wake_up_interruptible_nr(&dev->open, 1);
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:bttv_irq_wakeup_video(struct bttv *btv, struct bttv_buffer_set *wakeup,
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:	if (wakeup->top == wakeup->bottom) {
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:		if (NULL != wakeup->top && curr->top != wakeup->top) {
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:				printk("bttv%d: wakeup: both=%p\n",btv->c.nr,wakeup->top);
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:			wakeup->top->vb.ts = ts;
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:			wakeup->top->vb.field_count = btv->field_count;
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:			wakeup->top->vb.state = state;
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:			wake_up(&wakeup->top->vb.done);
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:		if (NULL != wakeup->top && curr->top != wakeup->top) {
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:				printk("bttv%d: wakeup: top=%p\n",btv->c.nr,wakeup->top);
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:			wakeup->top->vb.ts = ts;
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:			wakeup->top->vb.field_count = btv->field_count;
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:			wakeup->top->vb.state = state;
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:			wake_up(&wakeup->top->vb.done);
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:		if (NULL != wakeup->bottom && curr->bottom != wakeup->bottom) {
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:				printk("bttv%d: wakeup: bottom=%p\n",btv->c.nr,wakeup->bottom);
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:			wakeup->bottom->vb.ts = ts;
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:			wakeup->bottom->vb.field_count = btv->field_count;
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:			wakeup->bottom->vb.state = state;
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:			wake_up(&wakeup->bottom->vb.done);
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:bttv_irq_wakeup_vbi(struct bttv *btv, struct bttv_buffer *wakeup,
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:	if (NULL == wakeup)
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:	wakeup->vb.ts = ts;
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:	wakeup->vb.field_count = btv->field_count;
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:	wakeup->vb.state = state;
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:	wake_up(&wakeup->vb.done);
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:	/* wake up */
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:	bttv_irq_wakeup_video(btv, &old, &new, VIDEOBUF_ERROR);
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:	bttv_irq_wakeup_vbi(btv, ovbi, VIDEOBUF_ERROR);
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:		wake_up(&item->vb.done);
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:		wake_up(&item->vb.done);
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:bttv_irq_wakeup_top(struct bttv *btv)
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:	struct bttv_buffer *wakeup = btv->curr.top;
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:	if (NULL == wakeup)
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:	do_gettimeofday(&wakeup->vb.ts);
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:	wakeup->vb.field_count = btv->field_count;
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:	wakeup->vb.state = VIDEOBUF_DONE;
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:	wake_up(&wakeup->vb.done);
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:	/* wake up finished buffers */
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:	bttv_irq_wakeup_video(btv, &old, &new, VIDEOBUF_DONE);
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:	bttv_irq_wakeup_vbi(btv, old, VIDEOBUF_DONE);
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:			wake_up(&btv->gpioq);
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:			wake_up(&btv->i2c_queue);
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:			bttv_irq_wakeup_top(btv);
NeoLKernel/drivers/media/video/bt8xx/bttv-driver.c:	wake_up(&btv->gpioq);
NeoLKernel/drivers/media/video/pvrusb2/pvrusb2-hdw.c:		wake_up(&hdw->state_wait_data);
NeoLKernel/drivers/media/video/pvrusb2/pvrusb2-context.c:	if (signal_flag) wake_up(&pvr2_context_sync_data);
NeoLKernel/drivers/media/video/pvrusb2/pvrusb2-context.c:		/* Trigger wakeup on control thread in case it is waiting
NeoLKernel/drivers/media/video/pvrusb2/pvrusb2-context.c:		wake_up(&pvr2_context_sync_data);
NeoLKernel/drivers/media/video/pvrusb2/pvrusb2-context.c:	wake_up(&pvr2_context_cleanup_data);
NeoLKernel/drivers/media/video/pvrusb2/pvrusb2-context.c:	wake_up(&pvr2_context_sync_data);
NeoLKernel/drivers/media/video/pvrusb2/pvrusb2-dvb.c:	wake_up(&adap->buffer_wait_data);
NeoLKernel/drivers/media/video/pvrusb2/pvrusb2-v4l2.c:	wake_up(&fhp->wait_data);
NeoLKernel/drivers/media/video/pwc/philips.txt:   will shut down, but never wake up). Consider this experimental. By
NeoLKernel/drivers/media/video/pwc/pwc-if.c:	int awake = 0;
NeoLKernel/drivers/media/video/pwc/pwc-if.c:			awake = 1; /* delay wake_ups */
NeoLKernel/drivers/media/video/pwc/pwc-if.c:	return awake;
NeoLKernel/drivers/media/video/pwc/pwc-if.c:	int awake;
NeoLKernel/drivers/media/video/pwc/pwc-if.c:	awake = 0;
NeoLKernel/drivers/media/video/pwc/pwc-if.c:			awake = 1;
NeoLKernel/drivers/media/video/pwc/pwc-if.c:			wake_up_interruptible(&pdev->frameq);
NeoLKernel/drivers/media/video/pwc/pwc-if.c:		awake = 1;
NeoLKernel/drivers/media/video/pwc/pwc-if.c:				   wake up read() process and let select()/poll() do something.
NeoLKernel/drivers/media/video/pwc/pwc-if.c:						awake = 1;
NeoLKernel/drivers/media/video/pwc/pwc-if.c:	if (awake)
NeoLKernel/drivers/media/video/pwc/pwc-if.c:		wake_up_interruptible(&pdev->frameq);
NeoLKernel/drivers/media/video/pwc/pwc-if.c:	wake_up_interruptible(&pdev->frameq);
NeoLKernel/drivers/media/video/pxa_camera.c:static void pxa_camera_wakeup(struct pxa_camera_dev *pcdev,
NeoLKernel/drivers/media/video/pxa_camera.c:	wake_up(&vb->done);
NeoLKernel/drivers/media/video/pxa_camera.c:			pxa_camera_wakeup(pcdev, vb, buf);
NeoLKernel/drivers/media/video/s2255drv.c:		/* wake up anything waiting for the firmware */
NeoLKernel/drivers/media/video/s2255drv.c:		wake_up(&data->wait_fw);
NeoLKernel/drivers/media/video/s2255drv.c:		/* wake up anything waiting for the firmware */
NeoLKernel/drivers/media/video/s2255drv.c:		wake_up(&data->wait_fw);
NeoLKernel/drivers/media/video/s2255drv.c:		/* wake up anything waiting for the firmware */
NeoLKernel/drivers/media/video/s2255drv.c:		wake_up(&data->wait_fw);
NeoLKernel/drivers/media/video/s2255drv.c:			/* wake up anything waiting for the firmware */
NeoLKernel/drivers/media/video/s2255drv.c:			wake_up(&data->wait_fw);
NeoLKernel/drivers/media/video/s2255drv.c:	dprintk(2, "wakeup: %p channel: %d\n", &dma_q, chn);
NeoLKernel/drivers/media/video/s2255drv.c:	dprintk(100, "[%p/%d] wakeup\n", buf, buf->vb.i);
NeoLKernel/drivers/media/video/s2255drv.c:	wake_up(&buf->vb.done);
NeoLKernel/drivers/media/video/s2255drv.c:	dprintk(2, "wakeup [buf/i] [%p/%d]\n", buf, buf->vb.i);
NeoLKernel/drivers/media/video/s2255drv.c:	wake_up(&dev->fw_data->wait_fw);
NeoLKernel/drivers/media/video/s2255drv.c:		wake_up(&dev->wait_setmode[i]);
NeoLKernel/drivers/media/video/s2255drv.c:					wake_up(&dev->wait_setmode[cc]);
NeoLKernel/drivers/media/video/s2255drv.c:					wake_up(&dev->fw_data->wait_fw);
NeoLKernel/drivers/media/video/s2255drv.c:	 * wake up any of the timers to allow open_lock to be
NeoLKernel/drivers/media/video/s2255drv.c:	wake_up(&dev->fw_data->wait_fw);
NeoLKernel/drivers/media/video/s2255drv.c:		wake_up(&dev->wait_setmode[i]);
NeoLKernel/drivers/media/video/saa6588.c:	wake_up_interruptible(&s->read_queue);
NeoLKernel/drivers/media/video/saa6588.c:		wake_up_interruptible(&s->read_queue);
NeoLKernel/drivers/media/video/saa7134/saa7134-alsa.c:	/* update status & wake waiting readers */
NeoLKernel/drivers/media/video/saa7134/saa7134-core.c:	wake_up(&q->curr->vb.done);
NeoLKernel/drivers/media/video/saa7134/saa7134-tvaudio.c:			wake_up_process(dev->thread.thread);
NeoLKernel/drivers/media/video/saa7134/saa7134-video.c:		/* wake up tvaudio audio carrier scan thread */
NeoLKernel/drivers/media/video/saa7164/saa7164-cmd.c:			wake_up(q);
NeoLKernel/drivers/media/video/saa7164/saa7164-cmd.c:		wake_up(q);
NeoLKernel/drivers/media/video/saa7164/saa7164-cmd.c:			dprintk(DBGLVL_CMD, "%s(seqno=%d) calling wake_up\n",
NeoLKernel/drivers/media/video/saa7164/saa7164-cmd.c:			wake_up(&dev->cmds[i].wait);
NeoLKernel/drivers/media/video/se401.c:				wake_up_interruptible(&se401->wq);
NeoLKernel/drivers/media/video/se401.c:				wake_up_interruptible(&se401->wq);
NeoLKernel/drivers/media/video/se401.c:			wake_up_interruptible(&se401->wq);
NeoLKernel/drivers/media/video/usbvideo/usbvideo.c:		wake_up_interruptible(&rq->wqh);
NeoLKernel/drivers/media/video/usbvision/usbvision-core.c:			wake_up_interruptible(&usbvision->wait_frame);
NeoLKernel/drivers/media/video/usbvision/usbvision-core.c:		wake_up_interruptible(&usbvision->wait_stream);
NeoLKernel/drivers/media/video/usbvision/usbvision-core.c:		wake_up_interruptible(&usbvision->ctrlUrb_wq);
NeoLKernel/drivers/media/video/usbvision/usbvision-video.c:		wake_up_interruptible(&usbvision->wait_frame);
NeoLKernel/drivers/media/video/usbvision/usbvision-video.c:		wake_up_interruptible(&usbvision->wait_stream);
NeoLKernel/drivers/media/video/uvc/uvc_queue.c: *    queue, marks it as ready (UVC_BUF_STATE_DONE) and wakes its wait queue.
NeoLKernel/drivers/media/video/uvc/uvc_queue.c: *    irq queue as being erroneous (UVC_BUF_STATE_ERROR) and wakes them up so
NeoLKernel/drivers/media/video/uvc/uvc_queue.c: * wakes them up and removes them from the queue.
NeoLKernel/drivers/media/video/uvc/uvc_queue.c:		wake_up(&buf->wait);
NeoLKernel/drivers/media/video/uvc/uvc_queue.c:	wake_up(&buf->wait);
NeoLKernel/drivers/media/video/uvc/uvc_video.c: * If an error occurs, disable the video queue. This will wake all pending
NeoLKernel/drivers/media/video/videobuf-core.c:	wake_up_interruptible_sync(&q->wait);
NeoLKernel/drivers/media/video/videobuf-core.c:			wake_up_all(&q->bufs[i]->done);
NeoLKernel/drivers/media/video/videobuf-core.c:	wake_up_interruptible_sync(&q->wait);
NeoLKernel/drivers/media/video/videobuf-core.c:	wake_up_interruptible_sync(&q->wait);
NeoLKernel/drivers/media/video/cx88/cx88-core.c:void cx88_wakeup(struct cx88_core *core,
NeoLKernel/drivers/media/video/cx88/cx88-core.c:		dprintk(2,"[%p/%d] wakeup reg=%d buf=%d\n",buf,buf->vb.i,
NeoLKernel/drivers/media/video/cx88/cx88-core.c:		wake_up(&buf->vb.done);
NeoLKernel/drivers/media/video/cx88/cx88-core.c:EXPORT_SYMBOL(cx88_wakeup);
NeoLKernel/drivers/media/video/cx88/cx88-mpeg.c:		wake_up(&buf->vb.done);
NeoLKernel/drivers/media/video/cx88/cx88-mpeg.c:		dprintk( 1, "wake up\n" );
NeoLKernel/drivers/media/video/cx88/cx88-mpeg.c:		cx88_wakeup(dev->core, &dev->mpegq, count);
NeoLKernel/drivers/media/video/cx88/cx88-vbi.c:		wake_up(&buf->vb.done);
NeoLKernel/drivers/media/video/cx88/cx88-video.c:		wake_up(&buf->vb.done);
NeoLKernel/drivers/media/video/cx88/cx88-video.c:		cx88_wakeup(core, &dev->vidq, count);
NeoLKernel/drivers/media/video/cx88/cx88-video.c:		cx88_wakeup(core, &dev->vbiq, count);
NeoLKernel/drivers/media/video/cx88/cx88.h:extern void cx88_wakeup(struct cx88_core *core,
NeoLKernel/drivers/media/video/dabusb.c:	wake_up (&s->wait);
NeoLKernel/drivers/media/video/dabusb.c:		wake_up (&s->remove_ok);
NeoLKernel/drivers/media/video/dabusb.c:		wake_up (&s->wait);
NeoLKernel/drivers/media/video/davinci/vpfe_capture.c:	wake_up_interruptible(&vpfe_dev->cur_frm->done);
NeoLKernel/drivers/media/video/davinci/vpif_capture.c: * wake up any process waiting on the QUEUE and set the next buffer
NeoLKernel/drivers/media/video/davinci/vpif_capture.c:	wake_up_interruptible(&common->cur_frm->done);
NeoLKernel/drivers/media/video/davinci/vpif_display.c:		wake_up_interruptible(&common->cur_frm->done);
NeoLKernel/drivers/media/video/davinci/vpif_display.c:				wake_up_interruptible(&common->cur_frm->done);
NeoLKernel/drivers/media/video/em28xx/em28xx-cards.c:	/* wake i2c devices */
NeoLKernel/drivers/media/video/em28xx/em28xx-cards.c:	em28xx_wake_i2c(dev);
NeoLKernel/drivers/media/video/em28xx/em28xx-cards.c:	wake_up_interruptible_all(&dev->open);
NeoLKernel/drivers/media/video/em28xx/em28xx-cards.c:		wake_up_interruptible(&dev->wait_frame);
NeoLKernel/drivers/media/video/em28xx/em28xx-cards.c:		wake_up_interruptible(&dev->wait_stream);
NeoLKernel/drivers/media/video/em28xx/em28xx-core.c: * em28xx_wake_i2c()
NeoLKernel/drivers/media/video/em28xx/em28xx-core.c:void em28xx_wake_i2c(struct em28xx *dev)
NeoLKernel/drivers/media/video/em28xx/em28xx-i2c.c:		printk(KERN_INFO "%s:\tUSB Remote wakeup capable\n", dev->name);
NeoLKernel/drivers/media/video/em28xx/em28xx-video.c:	em28xx_isocdbg("[%p/%d] wakeup\n", buf, buf->vb.i);
NeoLKernel/drivers/media/video/em28xx/em28xx-video.c:	wake_up(&buf->vb.done);
NeoLKernel/drivers/media/video/em28xx/em28xx-video.c:	em28xx_isocdbg("[%p/%d] wakeup\n", buf, buf->vb.i);
NeoLKernel/drivers/media/video/em28xx/em28xx-video.c:	wake_up(&buf->vb.done);
NeoLKernel/drivers/media/video/em28xx/em28xx-video.c:		em28xx_wake_i2c(dev);
NeoLKernel/drivers/media/video/em28xx/em28xx-video.c:	wake_up_interruptible_nr(&dev->open, 1);
NeoLKernel/drivers/media/video/em28xx/em28xx.h:void em28xx_wake_i2c(struct em28xx *dev);
NeoLKernel/drivers/media/video/et61x251/et61x251_core.c:		wake_up(&cam->wait_stream);
NeoLKernel/drivers/media/video/et61x251/et61x251_core.c:		wake_up_interruptible(&cam->wait_frame);
NeoLKernel/drivers/media/video/et61x251/et61x251_core.c:	wake_up_interruptible(&cam->wait_frame);
NeoLKernel/drivers/media/video/et61x251/et61x251_core.c:	wake_up_interruptible_nr(&cam->wait_open, 1);
NeoLKernel/drivers/media/video/et61x251/et61x251_core.c:		wake_up_interruptible(&cam->wait_frame);
NeoLKernel/drivers/media/video/et61x251/et61x251_core.c:		wake_up(&cam->wait_stream);
NeoLKernel/drivers/media/video/et61x251/et61x251_core.c:	wake_up_interruptible_all(&cam->wait_open);
NeoLKernel/drivers/media/video/gspca/gspca.c:	/* if last packet, wake up the application and advance in the queue */
NeoLKernel/drivers/media/video/gspca/gspca.c:		wake_up_interruptible(&gspca_dev->wq);	/* event = new frame */
NeoLKernel/drivers/media/video/gspca/gspca.c:		wake_up_interruptible(&gspca_dev->wq);
NeoLKernel/drivers/media/video/gspca/m5602/m5602_s5k83a.c:	wake_up_process(sens_priv->rotation_thread);
NeoLKernel/drivers/media/video/gspca/sonixj.c:	i2c_w1(gspca_dev, 0x02, 0);			/* sensor wakeup */
NeoLKernel/drivers/media/video/hdpvr/hdpvr-core.c:	wake_up_interruptible(&dev->wait_data);
NeoLKernel/drivers/media/video/hdpvr/hdpvr-core.c:	wake_up_interruptible(&dev->wait_buffer);
NeoLKernel/drivers/media/video/hdpvr/hdpvr-video.c:	/* marking buffer as received and wake waiting */
NeoLKernel/drivers/media/video/hdpvr/hdpvr-video.c:	wake_up_interruptible(&dev->wait_data);
NeoLKernel/drivers/media/video/hdpvr/hdpvr-video.c:	wake_up_interruptible(&dev->wait_buffer);
NeoLKernel/drivers/media/video/hdpvr/hdpvr-video.c:			wake_up_interruptible(&dev->wait_buffer);
NeoLKernel/drivers/media/video/ivtv/ivtv-driver.h:	wait_queue_head_t dma_waitq;    /* wake up when the current DMA is finished */
NeoLKernel/drivers/media/video/ivtv/ivtv-driver.h:	wait_queue_head_t eos_waitq;    /* wake up when EOS arrives */
NeoLKernel/drivers/media/video/ivtv/ivtv-driver.h:	wait_queue_head_t event_waitq;  /* wake up when the next decoder event arrives */
NeoLKernel/drivers/media/video/ivtv/ivtv-driver.h:	wait_queue_head_t vsync_waitq;  /* wake up when the next decoder vsync arrives */
NeoLKernel/drivers/media/video/ivtv/ivtv-irq.c:		wake_up(&s->waitq);
NeoLKernel/drivers/media/video/ivtv/ivtv-irq.c:		wake_up(&s->waitq);
NeoLKernel/drivers/media/video/ivtv/ivtv-irq.c:	wake_up(&itv->dma_waitq);
NeoLKernel/drivers/media/video/ivtv/ivtv-irq.c:	wake_up(&itv->dma_waitq);
NeoLKernel/drivers/media/video/ivtv/ivtv-irq.c:	wake_up(&itv->dma_waitq);
NeoLKernel/drivers/media/video/ivtv/ivtv-irq.c:	wake_up(&itv->dma_waitq);
NeoLKernel/drivers/media/video/ivtv/ivtv-irq.c:			wake_up(&itv->event_waitq);
NeoLKernel/drivers/media/video/ivtv/ivtv-irq.c:		wake_up(&itv->vsync_waitq);
NeoLKernel/drivers/media/video/ivtv/ivtv-irq.c:			wake_up(&s->waitq);
NeoLKernel/drivers/media/video/ivtv/ivtv-irq.c:		wake_up(&itv->eos_waitq);
NeoLKernel/drivers/media/video/ivtv/ivtv-irq.c:	wake_up(&itv->dma_waitq);
NeoLKernel/drivers/media/video/ivtv/ivtv-streams.c:	wake_up(&s->waitq);
NeoLKernel/drivers/media/video/ivtv/ivtv-streams.c:	wake_up(&itv->event_waitq);
NeoLKernel/drivers/media/video/ivtv/ivtv-streams.c:	/* wake up wait queues */
NeoLKernel/drivers/media/video/ivtv/ivtv-streams.c:	wake_up(&s->waitq);
NeoLKernel/drivers/media/video/meye.c:		wake_up_interruptible(&meye.proc_list);
NeoLKernel/drivers/media/video/meye.c:		wake_up_interruptible(&meye.proc_list);
NeoLKernel/drivers/media/video/sn9c102/sn9c102_core.c:		wake_up(&cam->wait_stream);
NeoLKernel/drivers/media/video/sn9c102/sn9c102_core.c:		wake_up_interruptible(&cam->wait_frame);
NeoLKernel/drivers/media/video/sn9c102/sn9c102_core.c:	wake_up_interruptible(&cam->wait_frame);
NeoLKernel/drivers/media/video/sn9c102/sn9c102_core.c:		   priority after any wake_up().
NeoLKernel/drivers/media/video/sn9c102/sn9c102_core.c:	wake_up_interruptible_nr(&cam->wait_open, 1);
NeoLKernel/drivers/media/video/sn9c102/sn9c102_core.c:		wake_up_interruptible(&cam->wait_frame);
NeoLKernel/drivers/media/video/sn9c102/sn9c102_core.c:		wake_up(&cam->wait_stream);
NeoLKernel/drivers/media/video/sn9c102/sn9c102_core.c:	wake_up_interruptible_all(&cam->wait_open);
NeoLKernel/drivers/media/video/stk-sensor.c:int stk_sensor_wakeup(struct stk_camera *dev)
NeoLKernel/drivers/media/video/stk-webcam.c:	if (stk_sensor_wakeup(dev))
NeoLKernel/drivers/media/video/stk-webcam.c:					wake_up(&dev->wait_frame);
NeoLKernel/drivers/media/video/stk-webcam.c:	wake_up_interruptible(&dev->wait_frame);
NeoLKernel/drivers/media/video/stk-webcam.h:int stk_sensor_wakeup(struct stk_camera *dev);
NeoLKernel/drivers/media/video/stradis.c:		wake_up_interruptible(&saa->audq);
NeoLKernel/drivers/media/video/stradis.c:		wake_up_interruptible(&saa->vidq);
NeoLKernel/drivers/media/video/stv680.c:				wake_up_interruptible (&stv680->wq);
NeoLKernel/drivers/media/video/stv680.c:				wake_up_interruptible (&stv680->wq);
NeoLKernel/drivers/media/video/stv680.c:	wake_up_interruptible (&stv680->wq);
NeoLKernel/drivers/media/video/tvaudio.c:static void chip_thread_wake(unsigned long data)
NeoLKernel/drivers/media/video/tvaudio.c:	wake_up_process(chip->thread);
NeoLKernel/drivers/media/video/tvaudio.c:		v4l2_dbg(1, debug, sd, "thread wakeup\n");
NeoLKernel/drivers/media/video/tvaudio.c:		chip->wt.function = chip_thread_wake;
NeoLKernel/drivers/media/video/cx25840/cx25840-core.c:	wake_up(&state->fw_wait);
NeoLKernel/drivers/media/video/cx25840/cx25840-core.h:	wait_queue_head_t fw_wait;    /* wake up when the fw load is finished */
NeoLKernel/drivers/media/video/sh_mobile_ceu_camera.c:	wake_up(&vb->done);
NeoLKernel/drivers/media/video/sh_mobile_ceu_camera.c:		wake_up_all(&pcdev->active->done);
NeoLKernel/drivers/media/video/msm/msm_gemini_sync.c:inline int msm_gemini_q_wakeup(struct msm_gemini_q *q_p)
NeoLKernel/drivers/media/video/msm/msm_gemini_sync.c:	wake_up(&q_p->wait);
NeoLKernel/drivers/media/video/msm/msm_gemini_sync.c:	wake_up(&q_p->wait);
NeoLKernel/drivers/media/video/msm/msm_gemini_sync.c:		rc = msm_gemini_q_wakeup(&pgmn_dev->evt_q);
NeoLKernel/drivers/media/video/msm/msm_gemini_sync.c:		rc = msm_gemini_q_wakeup(&pgmn_dev->evt_q);
NeoLKernel/drivers/media/video/msm/msm_gemini_sync.c:		rc = msm_gemini_q_wakeup(&pgmn_dev->output_rtn_q);
NeoLKernel/drivers/media/video/msm/msm_gemini_sync.c:		rc = msm_gemini_q_wakeup(&pgmn_dev->input_rtn_q);
NeoLKernel/drivers/media/video/msm/msm_gemini_sync.c:			msm_gemini_q_wakeup(&pgmn_dev->output_rtn_q);
NeoLKernel/drivers/media/video/msm/msm_vfe7x.c:			wake_up(&stopevent.wait);
NeoLKernel/drivers/media/video/msm/msm_vpe1_standalone.c:		wake_up(&vpe_ctrl->wait);
NeoLKernel/drivers/media/video/msm/msm_camera.c:	wake_up(&queue->wait);
NeoLKernel/drivers/media/video/msm/msm_camera.c:	/* wake up config thread */
NeoLKernel/drivers/media/video/msm/msm_camera.c:		/* wake up control thread */
NeoLKernel/drivers/media/video/msm/msm_camera.c:		wake_up(&(pmsm->sync->pict_q.wait));
NeoLKernel/drivers/media/video/msm/msm_camera.c:		wake_unlock(&sync->suspend_lock);
NeoLKernel/drivers/media/video/msm/msm_camera.c:		wake_unlock(&sync->wake_lock);
NeoLKernel/drivers/media/video/msm/msm_camera.c:	wake_up(&sync->frame_q.wait);
NeoLKernel/drivers/media/video/msm/msm_camera.c:		wake_lock(&sync->suspend_lock);
NeoLKernel/drivers/media/video/msm/msm_camera.c:		wake_lock(&sync->wake_lock);
NeoLKernel/drivers/media/video/msm/msm_camera.c:	/* wake up config thread, 4 is for V4L2 application */
NeoLKernel/drivers/media/video/msm/msm_camera.c:	wake_lock_init(&sync->suspend_lock,
NeoLKernel/drivers/media/video/msm/msm_camera.c:	wake_lock_init(&sync->wake_lock, WAKE_LOCK_IDLE, "msm_camera");
NeoLKernel/drivers/media/video/msm/msm_camera.c:		wake_lock_destroy(&sync->suspend_lock);
NeoLKernel/drivers/media/video/msm/msm_camera.c:		wake_lock_destroy(&sync->wake_lock);
NeoLKernel/drivers/media/video/msm/msm_camera.c:	wake_lock_destroy(&sync->suspend_lock);
NeoLKernel/drivers/media/video/msm/msm_camera.c:	wake_lock_destroy(&sync->wake_lock);
NeoLKernel/drivers/media/video/msp3400-driver.c:static void msp_wake_thread(struct i2c_client *client)
NeoLKernel/drivers/media/video/msp3400-driver.c:	wake_up_interruptible(&state->wq);
NeoLKernel/drivers/media/video/msp3400-driver.c:		msp_wake_thread(client);
NeoLKernel/drivers/media/video/msp3400-driver.c:	msp_wake_thread(client);
NeoLKernel/drivers/media/video/msp3400-driver.c:		msp_wake_thread(client);
NeoLKernel/drivers/media/video/msp3400-driver.c:	/* wake thread when a new input is chosen */
NeoLKernel/drivers/media/video/msp3400-driver.c:	msp_wake_thread(client);
NeoLKernel/drivers/media/video/msp3400-driver.c:	msp_wake_thread(client);
NeoLKernel/drivers/media/video/msp3400-driver.c:		msp_wake_thread(client);
NeoLKernel/drivers/media/video/msp3400-kthreads.c:		v4l_dbg(2, msp_debug, client, "msp3400 thread: wakeup\n");
NeoLKernel/drivers/media/video/msp3400-kthreads.c:		v4l_dbg(2, msp_debug, client, "msp3410 thread: wakeup\n");
NeoLKernel/drivers/media/video/msp3400-kthreads.c:		v4l_dbg(2, msp_debug, client, "msp34xxg thread: wakeup\n");
NeoLKernel/drivers/media/video/mx1_camera.c:static void mx1_camera_wakeup(struct mx1_camera_dev *pcdev,
NeoLKernel/drivers/media/video/mx1_camera.c:	wake_up(&vb->done);
NeoLKernel/drivers/media/video/mx1_camera.c:	mx1_camera_wakeup(pcdev, vb, buf);
NeoLKernel/drivers/media/video/mx3_camera.c:		wake_up(&vb->done);
NeoLKernel/drivers/media/video/mx3_camera.c:			wake_up(&vb->done);
NeoLKernel/drivers/media/video/omap24xxcam.c:	wake_up(&vb->done);
NeoLKernel/drivers/media/video/ov511.c:			wake_up_interruptible(&frame->wq);
NeoLKernel/drivers/media/video/ov511.c:		wake_up_interruptible(&frame->wq);
NeoLKernel/drivers/media/video/ov511.c:			wake_up_interruptible(&ov->wq);
NeoLKernel/drivers/media/video/ov511.c:		wake_up_interruptible(&ov->frame[n].wq);
NeoLKernel/drivers/media/video/ov511.c:	wake_up_interruptible(&ov->wq);
NeoLKernel/drivers/media/video/vino.c:	wake_up(&vcs->fb_queue.frame_wait_queue);
NeoLKernel/drivers/media/video/vivi.c:	wake_up(&buf->vb.done);
NeoLKernel/drivers/media/video/vivi.c:	dprintk(dev, 2, "[%p/%d] wakeup\n", buf, buf->vb. i);
NeoLKernel/drivers/media/video/vivi.c:	/* Calculate time to wake up */
NeoLKernel/drivers/media/video/vivi.c:	wake_up_interruptible(&dma_q->wq);
NeoLKernel/drivers/media/video/w9968cf.c:	wake_up_interruptible(&cam->wait_queue);
NeoLKernel/drivers/media/video/w9968cf.c:	wake_up_interruptible_nr(&cam->open, 1);
NeoLKernel/drivers/media/video/w9968cf.c:		wake_up_interruptible_all(&cam->open);
NeoLKernel/drivers/media/video/w9968cf.c:			wake_up_interruptible(&cam->wait_queue);
NeoLKernel/drivers/media/video/zc0301/zc0301_core.c:		wake_up(&cam->wait_stream);
NeoLKernel/drivers/media/video/zc0301/zc0301_core.c:		wake_up_interruptible(&cam->wait_frame);
NeoLKernel/drivers/media/video/zc0301/zc0301_core.c:	wake_up_interruptible(&cam->wait_frame);
NeoLKernel/drivers/media/video/zc0301/zc0301_core.c:	wake_up_interruptible_nr(&cam->wait_open, 1);
NeoLKernel/drivers/media/video/zc0301/zc0301_core.c:		wake_up_interruptible(&cam->wait_frame);
NeoLKernel/drivers/media/video/zc0301/zc0301_core.c:		wake_up(&cam->wait_stream);
NeoLKernel/drivers/media/video/zc0301/zc0301_core.c:	wake_up_interruptible_all(&cam->wait_open);
NeoLKernel/drivers/media/video/zoran/zoran_device.c:			"%s: jpeg_codec_sleep() - wake GPIO=0x%08x\n",
NeoLKernel/drivers/media/video/zoran/zoran_device.c:		wake_up_interruptible(&zr->jpg_capq);
NeoLKernel/drivers/media/video/zoran/zoran_device.c:		wake_up_interruptible(&zr->jpg_capq);
NeoLKernel/drivers/media/video/zoran/zoran_device.c:				wake_up_interruptible(&zr->test_q);
NeoLKernel/drivers/media/video/zoran/zoran_device.c:					wake_up_interruptible(&zr->v4l_capq);
NeoLKernel/drivers/media/video/zoran/zoran_device.c:			wake_up_interruptible(&zr->jpg_capq);
NeoLKernel/drivers/media/video/zoran/zoran_driver.c:		wake_up_interruptible(&zr->jpg_capq);
NeoLKernel/drivers/media/video/zoran/zoran_driver.c:		wake_up_interruptible(&zr->v4l_capq);
NeoLKernel/drivers/media/video/zr364xx.c:	DBG("wakeup: %p\n", &dma_q);
NeoLKernel/drivers/media/video/zr364xx.c:	DBG("[%p/%d] wakeup\n", buf, buf->vb.i);
NeoLKernel/drivers/media/video/zr364xx.c:	wake_up(&buf->vb.done);
NeoLKernel/drivers/media/video/zr364xx.c:	DBG("wakeup [buf/i] [%p/%d]\n", buf, buf->vb.i);
NeoLKernel/drivers/media/video/bw-qcam.c:			   until the camera wakes up. However, we are
NeoLKernel/drivers/media/video/bw-qcam.c:			   until the camera wakes up. However, we are
NeoLKernel/drivers/media/video/bw-qcam.c:		   until the camera wakes up. However, we are
NeoLKernel/drivers/media/video/cafe_ccic.c:	 * Go through the dance needed to wake the device up.
NeoLKernel/drivers/media/video/cafe_ccic.c:		wake_up(&cam->iowait);
NeoLKernel/drivers/media/video/cafe_ccic.c:		wake_up(&cam->iowait);
NeoLKernel/drivers/media/video/cafe_ccic.c:		wake_up(&cam->iowait);
NeoLKernel/drivers/media/video/cafe_ccic.c:		wake_up(&cam->smbus_wait);
NeoLKernel/drivers/media/video/cpia2/cpia2.h:		u8 wakeup;
NeoLKernel/drivers/media/video/cpia2/cpia2_core.c:static void wake_system(struct camera_data *cam);
NeoLKernel/drivers/media/video/cpia2/cpia2_core.c:		cam->params.vc_params.wakeup = cmd.buffer.block_data[0];
NeoLKernel/drivers/media/video/cpia2/cpia2_core.c:	/* Give VP time to wake up */
NeoLKernel/drivers/media/video/cpia2/cpia2_core.c:		/* Try to read something in VP to check if everything is awake */
NeoLKernel/drivers/media/video/cpia2/cpia2_core.c:			ERR("Camera did not wake up\n");
NeoLKernel/drivers/media/video/cpia2/cpia2_core.c:	wake_system(cam);
NeoLKernel/drivers/media/video/cpia2/cpia2_core.c: *  wake_system
NeoLKernel/drivers/media/video/cpia2/cpia2_core.c:static void wake_system(struct camera_data *cam)
NeoLKernel/drivers/media/video/cpia2/cpia2_usb.c:				wake_up_interruptible(&cam->wq_stream);
NeoLKernel/drivers/media/video/cpia2/cpia2_usb.c:			wake_up_interruptible(&cam->wq_stream);
NeoLKernel/drivers/media/video/cpia_usb.c:					wake_up_interruptible(&ucpia->wq_stream);
NeoLKernel/drivers/media/video/cpia_usb.c:		wake_up_interruptible(&ucpia->wq_stream);
NeoLKernel/drivers/media/video/cx18/cx18-irq.c:		wake_up(&cx->mb_cpu_waitq);
NeoLKernel/drivers/media/video/cx18/cx18-irq.c:		wake_up(&cx->mb_apu_waitq);
NeoLKernel/drivers/media/video/cx18/cx18-mailbox.c:	wake_up(&cx->dma_waitq);
NeoLKernel/drivers/media/video/cx18/cx18-mailbox.c:		wake_up(&s->waitq);
NeoLKernel/drivers/media/video/cx18/cx18-mailbox.c:	/* So we don't miss the wakeup, prepare to wait before notifying fw */
NeoLKernel/drivers/media/video/cx18/cx18-mailbox.c:					"waited %d msecs on req %u but awakened"
NeoLKernel/drivers/media/video/cx18/cx18-mailbox.c:		CX18_DEBUG_WARN("failed to be awakened upon RPU acknowledgment "
NeoLKernel/drivers/media/video/cx18/cx18-streams.c:	wake_up(&s->waitq);
NeoLKernel/drivers/media/video/cx231xx/cx231xx-cards.c:	wake_up_interruptible_all(&dev->open);
NeoLKernel/drivers/media/video/cx231xx/cx231xx-cards.c:		wake_up_interruptible(&dev->wait_frame);
NeoLKernel/drivers/media/video/cx231xx/cx231xx-cards.c:		wake_up_interruptible(&dev->wait_stream);
NeoLKernel/drivers/media/video/cx231xx/cx231xx-vbi.c:	/* cx231xx_info(DRIVER_NAME "[%p/%d] wakeup\n", buf, buf->vb.i); */
NeoLKernel/drivers/media/video/cx231xx/cx231xx-vbi.c:	wake_up(&buf->vb.done);
NeoLKernel/drivers/media/video/cx231xx/cx231xx-video.c:	cx231xx_isocdbg("[%p/%d] wakeup\n", buf, buf->vb.i);
NeoLKernel/drivers/media/video/cx231xx/cx231xx-video.c:	wake_up(&buf->vb.done);
NeoLKernel/drivers/media/video/cx231xx/cx231xx-video.c:		wake_up_interruptible_nr(&dev->open, 1);
NeoLKernel/drivers/media/video/cx231xx/cx231xx-video.c:	wake_up_interruptible_nr(&dev->open, 1);
NeoLKernel/drivers/media/video/cx23885/cx23885-core.c:void cx23885_wakeup(struct cx23885_tsport *port,
NeoLKernel/drivers/media/video/cx23885/cx23885-core.c:		dprintk(2, "[%p/%d] wakeup reg=%d buf=%d\n", buf, buf->vb.i,
NeoLKernel/drivers/media/video/cx23885/cx23885-core.c:		wake_up(&buf->vb.done);
NeoLKernel/drivers/media/video/cx23885/cx23885-core.c:		wake_up(&buf->vb.done);
NeoLKernel/drivers/media/video/cx23885/cx23885-core.c:		cx23885_wakeup(port, &port->mpegq, count);
NeoLKernel/drivers/media/video/cx23885/cx23885-core.c:		cx23885_wakeup(port, &port->mpegq, count);
NeoLKernel/drivers/media/video/cx23885/cx23885-vbi.c:		wake_up(&buf->vb.done);
NeoLKernel/drivers/media/video/cx23885/cx23885-video.c:static void cx23885_video_wakeup(struct cx23885_dev *dev,
NeoLKernel/drivers/media/video/cx23885/cx23885-video.c:		dprintk(2, "[%p/%d] wakeup reg=%d buf=%d\n", buf, buf->vb.i,
NeoLKernel/drivers/media/video/cx23885/cx23885-video.c:		wake_up(&buf->vb.done);
NeoLKernel/drivers/media/video/cx23885/cx23885-video.c:		wake_up(&buf->vb.done);
NeoLKernel/drivers/media/video/cx23885/cx23885-video.c:		cx23885_video_wakeup(dev, &dev->vidq, count);
NeoLKernel/drivers/media/video/cx23885/cx23885.h:extern void cx23885_wakeup(struct cx23885_tsport *port,
NeoLKernel/drivers/scsi/3w-9xxx.c:					wake_up(&tw_dev->ioctl_wqueue);
NeoLKernel/drivers/scsi/3w-9xxx.c:	pci_enable_wake(pdev, PCI_D0, 0);
NeoLKernel/drivers/scsi/ppa.c:		wake_up(dev->waiting);
NeoLKernel/drivers/scsi/ppa.c:static void ppa_wakeup(void *ref)
NeoLKernel/drivers/scsi/ppa.c:		return 1;	/* wait until ppa_wakeup claims parport */
NeoLKernel/drivers/scsi/ppa.c:	dev->dev = parport_register_device(pb, "ppa", NULL, ppa_wakeup,
NeoLKernel/drivers/scsi/qla2xxx/qla_attr.c:	qla2xxx_wake_dpc(vha);
NeoLKernel/drivers/scsi/qla2xxx/qla_attr.c:		qla2xxx_wake_dpc(vha);
NeoLKernel/drivers/scsi/qla2xxx/qla_def.h:#define VP_DPC_NEEDED		14	/* wake up for VP dpc handling */
NeoLKernel/drivers/scsi/qla2xxx/qla_gbl.h:extern void qla2xxx_wake_dpc(struct scsi_qla_host *);
NeoLKernel/drivers/scsi/qla2xxx/qla_isr.c:		qla2xxx_wake_dpc(vha);
NeoLKernel/drivers/scsi/qla2xxx/qla_isr.c:		qla2xxx_wake_dpc(vha);
NeoLKernel/drivers/scsi/qla2xxx/qla_mbx.c:			qla2xxx_wake_dpc(vha);
NeoLKernel/drivers/scsi/qla2xxx/qla_mbx.c:		qla2xxx_wake_dpc(vha);
NeoLKernel/drivers/scsi/qla2xxx/qla_os.c:		 * qla2xxx_wake_dpc checks for ->dpc_thread
NeoLKernel/drivers/scsi/qla2xxx/qla_os.c:		qla2xxx_wake_dpc(base_vha);
NeoLKernel/drivers/scsi/qla2xxx/qla_os.c:	qla2xxx_wake_dpc(vha);
NeoLKernel/drivers/scsi/qla2xxx/qla_os.c:* bits then wake us up.
NeoLKernel/drivers/scsi/qla2xxx/qla_os.c:	 * Make sure that nobody tries to wake us up again.
NeoLKernel/drivers/scsi/qla2xxx/qla_os.c:qla2xxx_wake_dpc(struct scsi_qla_host *vha)
NeoLKernel/drivers/scsi/qla2xxx/qla_os.c:		wake_up_process(t);
NeoLKernel/drivers/scsi/qla2xxx/qla_os.c:		qla2xxx_wake_dpc(vha);
NeoLKernel/drivers/scsi/qla2xxx/qla_sup.c:	qla2xxx_wake_dpc(vha);
NeoLKernel/drivers/scsi/scsi_error.c:void scsi_eh_wakeup(struct Scsi_Host *shost)
NeoLKernel/drivers/scsi/scsi_error.c:		wake_up_process(shost->ehandler);
NeoLKernel/drivers/scsi/scsi_error.c:		scsi_eh_wakeup(shost);
NeoLKernel/drivers/scsi/scsi_error.c:	scsi_eh_wakeup(shost);
NeoLKernel/drivers/scsi/scsi_error.c:		 * if the device is not started, we need to wake
NeoLKernel/drivers/scsi/scsi_error.c:		 * returning FAILED will wake the error handler thread
NeoLKernel/drivers/scsi/scsi_error.c:	wake_up(&shost->host_wait);
NeoLKernel/drivers/scsi/scsi_error.c:	 * be sure to wake up anyone who was sleeping or had their queue
NeoLKernel/drivers/scsi/scsi_error.c:	wake_up(&shost->host_wait);
NeoLKernel/drivers/scsi/scsi_lib.c:		scsi_eh_wakeup(shost);
NeoLKernel/drivers/scsi/hptiop.c:		wake_up(&hba->reset_wq);
NeoLKernel/drivers/scsi/ibmvscsi/ibmvfc.c:	wake_up(&vhost->work_wait_q);
NeoLKernel/drivers/scsi/ibmvscsi/ibmvfc.c:	wake_up(&vhost->work_wait_q);
NeoLKernel/drivers/scsi/ibmvscsi/ibmvfc.c:		wake_up(&vhost->work_wait_q);
NeoLKernel/drivers/scsi/ibmvscsi/ibmvfc.c:		wake_up(&vhost->work_wait_q);
NeoLKernel/drivers/scsi/ibmvscsi/ibmvfc.c:	wake_up(&vhost->work_wait_q);
NeoLKernel/drivers/scsi/ibmvscsi/ibmvfc.c:	wake_up(&tgt->vhost->work_wait_q);
NeoLKernel/drivers/scsi/ibmvscsi/ibmvfc.c:		wake_up(&tgt->vhost->work_wait_q);
NeoLKernel/drivers/scsi/ibmvscsi/ibmvfc.c:	wake_up(&vhost->work_wait_q);
NeoLKernel/drivers/scsi/ibmvscsi/ibmvfc.c:	wake_up(&vhost->work_wait_q);
NeoLKernel/drivers/scsi/ibmvscsi/ibmvfc.c:		wake_up(&vhost->work_wait_q);
NeoLKernel/drivers/scsi/ibmvscsi/ibmvfc.c:	wake_up(&vhost->work_wait_q);
NeoLKernel/drivers/scsi/ibmvscsi/ibmvfc.c:	wake_up(&vhost->work_wait_q);
NeoLKernel/drivers/scsi/ibmvscsi/ibmvfc.c:	wake_up(&vhost->work_wait_q);
NeoLKernel/drivers/scsi/ibmvscsi/ibmvfc.c:	wake_up(&vhost->work_wait_q);
NeoLKernel/drivers/scsi/ibmvscsi/ibmvfc.c:	wake_up(&vhost->work_wait_q);
NeoLKernel/drivers/scsi/ibmvscsi/ibmvfc.c:		wake_up(&vhost->work_wait_q);
NeoLKernel/drivers/scsi/ibmvscsi/ibmvfc.c:		wake_up(&vhost->work_wait_q);
NeoLKernel/drivers/scsi/ibmvscsi/ibmvfc.c:	wake_up(&vhost->work_wait_q);
NeoLKernel/drivers/scsi/ibmvscsi/ibmvfc.c:					wake_up(&vhost->init_wait_q);
NeoLKernel/drivers/scsi/ibmvscsi/ibmvfc.c:			wake_up(&vhost->init_wait_q);
NeoLKernel/drivers/scsi/imm.c:		wake_up(dev->waiting);
NeoLKernel/drivers/scsi/imm.c:static void imm_wakeup(void *ref)
NeoLKernel/drivers/scsi/imm.c:		return 1;	/* wait until imm_wakeup claims parport */
NeoLKernel/drivers/scsi/imm.c:	dev->dev = parport_register_device(pb, "imm", NULL, imm_wakeup,
NeoLKernel/drivers/scsi/ipr.c: * blocking op. It simply wakes the sleeping thread.
NeoLKernel/drivers/scsi/ipr.c:	 * abort's done function to wake the sleeping eh thread
NeoLKernel/drivers/scsi/ipr.c: * It wakes any reset sleepers.
NeoLKernel/drivers/scsi/ipr.c:	wake_up_all(&ioa_cfg->reset_wait_q);
NeoLKernel/drivers/scsi/ipr.c: * wakes any reset sleepers.
NeoLKernel/drivers/scsi/ipr.c:	wake_up_all(&ioa_cfg->reset_wait_q);
NeoLKernel/drivers/scsi/ipr.c:			wake_up_all(&ioa_cfg->reset_wait_q);
NeoLKernel/drivers/scsi/ipr.c:	wake_up(&ioa_cfg->msi_wait_q);
NeoLKernel/drivers/scsi/libiscsi.c:	wake_up(&conn->ehwait);
NeoLKernel/drivers/scsi/libiscsi.c:			wake_up(&session->leadconn->ehwait);
NeoLKernel/drivers/scsi/libiscsi.c:		wake_up(&conn->ehwait);
NeoLKernel/drivers/scsi/libiscsi.c:		wake_up(&ihost->session_removal_wq);
NeoLKernel/drivers/scsi/libiscsi.c:		wake_up(&conn->ehwait);
NeoLKernel/drivers/scsi/libiscsi.c:		wake_up(&conn->ehwait);
NeoLKernel/drivers/scsi/libiscsi.c:	wake_up(&conn->ehwait);
NeoLKernel/drivers/scsi/libsas/sas_scsi_host.c:	wake_up_process(core->queue_thread);
NeoLKernel/drivers/scsi/lpfc/lpfc.h:lpfc_worker_wake_up(struct lpfc_hba *phba)
NeoLKernel/drivers/scsi/lpfc/lpfc.h:	wake_up(&phba->work_waitq);
NeoLKernel/drivers/scsi/lpfc/lpfc_bsg.c:		wake_up_interruptible(&evt->wq);
NeoLKernel/drivers/scsi/lpfc/lpfc_crtn.h:void lpfc_dump_wakeup_param(struct lpfc_hba *, LPFC_MBOXQ_t *);
NeoLKernel/drivers/scsi/lpfc/lpfc_crtn.h:void lpfc_worker_wake_up(struct lpfc_hba *);
NeoLKernel/drivers/scsi/lpfc/lpfc_crtn.h:void lpfc_sli_wake_mbox_wait(struct lpfc_hba *, LPFC_MBOXQ_t *);
NeoLKernel/drivers/scsi/lpfc/lpfc_ct.c:		lpfc_worker_wake_up(phba);
NeoLKernel/drivers/scsi/lpfc/lpfc_els.c: * lpfc_worker_wake_up() routine to wake up worker thread to process the
NeoLKernel/drivers/scsi/lpfc/lpfc_els.c:		lpfc_worker_wake_up(phba);
NeoLKernel/drivers/scsi/lpfc/lpfc_els.c: * event bitmap and then invokes the lpfc_worker_wake_up() routine to wake
NeoLKernel/drivers/scsi/lpfc/lpfc_els.c:		lpfc_worker_wake_up(phba);
NeoLKernel/drivers/scsi/lpfc/lpfc_els.c: * lpfc_worker_wake_up() routine to wake up the worker thread. It is for
NeoLKernel/drivers/scsi/lpfc/lpfc_els.c:		lpfc_worker_wake_up(phba);
NeoLKernel/drivers/scsi/lpfc/lpfc_hbadisc.c:		lpfc_worker_wake_up(phba);
NeoLKernel/drivers/scsi/lpfc/lpfc_hbadisc.c:		/* Signal wakeup shall terminate the worker thread */
NeoLKernel/drivers/scsi/lpfc/lpfc_hbadisc.c:	lpfc_worker_wake_up(phba);
NeoLKernel/drivers/scsi/lpfc/lpfc_hbadisc.c:			wake_up_interruptible(&phba->wait_4_mlo_m_q);
NeoLKernel/drivers/scsi/lpfc/lpfc_hbadisc.c:		lpfc_worker_wake_up(phba);
NeoLKernel/drivers/scsi/lpfc/lpfc_init.c: * lpfc_dump_wakeup_param_cmpl - dump memory mailbox command completion handler
NeoLKernel/drivers/scsi/lpfc/lpfc_init.c: * wake up parameters. When this command complete, the response contain
NeoLKernel/drivers/scsi/lpfc/lpfc_init.c:lpfc_dump_wakeup_param_cmpl(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmboxq)
NeoLKernel/drivers/scsi/lpfc/lpfc_init.c:	lpfc_dump_wakeup_param(phba, pmb);
NeoLKernel/drivers/scsi/lpfc/lpfc_init.c:	pmb->mbox_cmpl = lpfc_dump_wakeup_param_cmpl;
NeoLKernel/drivers/scsi/lpfc/lpfc_init.c:		lpfc_worker_wake_up(phba);
NeoLKernel/drivers/scsi/lpfc/lpfc_mbox.c: * lpfc_dump_wakeup_param - Prepare mailbox command for retrieving wakeup params
NeoLKernel/drivers/scsi/lpfc/lpfc_mbox.c: * This function create a dump memory mailbox command to dump wake up
NeoLKernel/drivers/scsi/lpfc/lpfc_mbox.c:lpfc_dump_wakeup_param(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)
NeoLKernel/drivers/scsi/lpfc/lpfc_mbox.c:	    mboxq->mbox_cmpl != lpfc_sli_wake_mbox_wait) {
NeoLKernel/drivers/scsi/lpfc/lpfc_scsi.c:	lpfc_worker_wake_up(phba);
NeoLKernel/drivers/scsi/lpfc/lpfc_scsi.c: * posts at most 1 event each second. This routine wakes up worker thread of
NeoLKernel/drivers/scsi/lpfc/lpfc_scsi.c:		lpfc_worker_wake_up(phba);
NeoLKernel/drivers/scsi/lpfc/lpfc_scsi.c: * last_rsrc_error_time.  This routine wakes up worker thread of @phba
NeoLKernel/drivers/scsi/lpfc/lpfc_scsi.c:		lpfc_worker_wake_up(phba);
NeoLKernel/drivers/scsi/lpfc/lpfc_scsi.c:	lpfc_worker_wake_up(phba);
NeoLKernel/drivers/scsi/lpfc/lpfc_scsi.c:			lpfc_worker_wake_up(phba);
NeoLKernel/drivers/scsi/lpfc/lpfc_scsi.c:		 * wake up the thread.
NeoLKernel/drivers/scsi/lpfc/lpfc_scsi.c:			wake_up(lpfc_cmd->waitq);
NeoLKernel/drivers/scsi/lpfc/lpfc_scsi.c:	 * wake up the thread.
NeoLKernel/drivers/scsi/lpfc/lpfc_scsi.c:		wake_up(lpfc_cmd->waitq);
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c:			lpfc_worker_wake_up(phba);
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c: * lpfc_sli_wake_mbox_wait - lpfc_sli_issue_mbox_wait mbox completion handler
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c: * will wake up thread waiting on the wait queue pointed by context1
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c:lpfc_sli_wake_mbox_wait(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmboxq)
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c:		wake_up_interruptible(pdone_q);
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c:	lpfc_worker_wake_up(phba);
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c: * and wake up worker thread to process it. Otherwise, it will set up the
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c:		lpfc_worker_wake_up(phba);
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c: * expected time. This function wakes up the worker thread to
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c:		lpfc_worker_wake_up(phba);
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c:		pmbox->mbox_cmpl != lpfc_sli_wake_mbox_wait) {
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c:	/* wake up worker thread to post asynchronlous mailbox command */
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c:	lpfc_worker_wake_up(phba);
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c:	lpfc_worker_wake_up(phba);
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c: * lpfc_sli_wake_iocb_wait - lpfc_sli_issue_iocb_wait's completion handler
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c: * lpfc_sli_issue_iocb_wait and then wakes up the thread which
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c:lpfc_sli_wake_iocb_wait(struct lpfc_hba *phba,
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c:		wake_up(pdone_q);
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c: * flag and wakes this thread when the iocb completes.
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c:	piocb->iocb_cmpl = lpfc_sli_wake_iocb_wait;
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c:					"0331 IOCB wake signaled\n");
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c:					"wake response Data x%x\n", timeout);
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c:					"0330 IOCB wake NOT set, "
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c:	/* setup wake call as IOCB callback */
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c:	pmboxq->mbox_cmpl = lpfc_sli_wake_mbox_wait;
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c:	/* setup context field to pass wait_queue pointer to wake function  */
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c:		lpfc_worker_wake_up(phba);
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c:	lpfc_worker_wake_up(phba);
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c:	/* wake up worker thread if there are works to be done */
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c:		lpfc_worker_wake_up(phba);
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c:	/* wake up worker thread if there are works to be done */
NeoLKernel/drivers/scsi/lpfc/lpfc_sli.c:		lpfc_worker_wake_up(phba);
NeoLKernel/drivers/scsi/megaraid/megaraid_mbox.c:	wake_up(&raid_dev->sysfs_wait_q);
NeoLKernel/drivers/scsi/megaraid/megaraid_mbox.c:	wake_up(&raid_dev->sysfs_wait_q);
NeoLKernel/drivers/scsi/megaraid/megaraid_mm.c:	 * on this kioc. We don't have to wake up anybody. Instead, we just
NeoLKernel/drivers/scsi/megaraid/megaraid_mm.c:		wake_up(&wait_q);
NeoLKernel/drivers/scsi/megaraid/megaraid_mm.c:	wake_up(&wait_q);
NeoLKernel/drivers/scsi/megaraid/megaraid_sas.c: * after it issues a command. This function wakes up that waiting routine by
NeoLKernel/drivers/scsi/megaraid/megaraid_sas.c: * calling wake_up() on the wait queue.
NeoLKernel/drivers/scsi/megaraid/megaraid_sas.c:	wake_up(&instance->int_cmd_wait_q);
NeoLKernel/drivers/scsi/megaraid/megaraid_sas.c: * wakes up all functions waiting on the same wait queue.
NeoLKernel/drivers/scsi/megaraid/megaraid_sas.c:		wake_up(&instance->abort_cmd_wait_q);
NeoLKernel/drivers/scsi/megaraid/megaraid_sas.c:	pci_enable_wake(pdev, PCI_D0, 0);
NeoLKernel/drivers/scsi/sg.c:			wake_up_interruptible(&sdp->o_excl_wait);
NeoLKernel/drivers/scsi/sg.c:	wake_up_interruptible(&sdp->o_excl_wait);
NeoLKernel/drivers/scsi/sg.c:		/* Now wake up any sg_read() that is waiting for this
NeoLKernel/drivers/scsi/sg.c:		wake_up_interruptible(&sfp->read_wait);
NeoLKernel/drivers/scsi/sg.c:		wake_up_interruptible(&sfp->read_wait);
NeoLKernel/drivers/scsi/sg.c:	wake_up_interruptible(&sdp->o_excl_wait);
NeoLKernel/drivers/scsi/sun3_NCR5380.c:     * need to 'wake up' the commands by a request_sense
NeoLKernel/drivers/scsi/sun3_NCR5380.c:     * conflicts when the mid-level code tries to wake up the affected 
NeoLKernel/drivers/scsi/sun3_NCR5380.c:    /* we did no complete reset of all commands, so a wakeup is required */
NeoLKernel/drivers/scsi/sym53c8xx_2/sym_glue.c:	sym_wakeup_done(np);
NeoLKernel/drivers/scsi/sym53c8xx_2/sym_hipd.c:static int sym_wakeup_done (struct sym_hcb *np)
NeoLKernel/drivers/scsi/sym53c8xx_2/sym_hipd.c:		sym_wakeup_done(np);
NeoLKernel/drivers/scsi/sym53c8xx_2/sym_nvram.c: *  Send START condition to NVRAM to wake it up.
NeoLKernel/drivers/scsi/wd7000.c:		 * used in mail_out(), wake_up() should correspondingly be called
NeoLKernel/drivers/scsi/dc395x.c:/* Sets the timer to wake us up */
NeoLKernel/drivers/scsi/dc395x.c:/* Sets the timer to wake us up */
NeoLKernel/drivers/scsi/dpt/dpti_ioctl.h:	int      wakebase;         /* mpx wakeup base index.          */
NeoLKernel/drivers/scsi/dpt/osd_util.h:/* wakes up the specifed thread */
NeoLKernel/drivers/scsi/dpt_i2o.c:			wake_up_interruptible(p1->wq);
NeoLKernel/drivers/scsi/dpt_i2o.c:			   free these because controller may awake and corrupt
NeoLKernel/drivers/scsi/dpt_i2o.c:				   awake and corrupt those bytes at any time */
NeoLKernel/drivers/scsi/dpt_i2o.c:			   awake and corrupt those bytes at any time */
NeoLKernel/drivers/scsi/eata_pio.c:		DBG(DBG_ABNORM, printk(KERN_WARNING "eata_pio_reset: exit, wakeup.\n"));
NeoLKernel/drivers/scsi/fcoe/fcoe.c:		wake_up_process(thread);
NeoLKernel/drivers/scsi/fcoe/fcoe.c:		wake_up_process(fps->thread);
NeoLKernel/drivers/scsi/fcoe/fcoe.c:			wake_up_process(pp->thread);
NeoLKernel/drivers/scsi/fnic/fnic_scsi.c:	 * wake up this thread.
NeoLKernel/drivers/scsi/g_NCR5380.c:			/* wakeup sequence for the NCR53C400A and DTC3181E */
NeoLKernel/drivers/scsi/aha1542.c:   We use this if we know the board is alive and awake, but we are not sure
NeoLKernel/drivers/scsi/pmcraid.c:	 * field. Response path needs to wake up any waiters waiting for cmd
NeoLKernel/drivers/scsi/pmcraid.c:		 * return. callers might be waiting on the reset wait_q, wake
NeoLKernel/drivers/scsi/pmcraid.c:		 * operational and wake up any waiters
NeoLKernel/drivers/scsi/pmcraid.c:	 * OPERATIONAL. Reset all control variables used during reset, wake up
NeoLKernel/drivers/scsi/pmcraid.c:		wake_up_all(&pinstance->reset_wait_q);
NeoLKernel/drivers/scsi/pmcraid.c:	 * will wake up the 'completion' queue.
NeoLKernel/drivers/scsi/pmcraid.c:	 * it. Delete the timer and wakeup the reset engine to proceed with
NeoLKernel/drivers/scsi/pmcraid.c:	pci_enable_wake(pdev, PCI_D0, 0);
NeoLKernel/drivers/scsi/mpt2sas/mpt2sas_base.c:			wake_up(&ioc->reset_wq);
NeoLKernel/drivers/scsi/mpt2sas/mpt2sas_ctl.c:		wake_up_interruptible(&ctl_poll_wait);
NeoLKernel/drivers/scsi/mpt2sas/mpt2sas_scsih.c:	pci_enable_wake(pdev, PCI_D0, 0);
NeoLKernel/drivers/scsi/ncr53c8xx.c:**	completion (ncr_wakeup()). Doing so, we are sure that the header 
NeoLKernel/drivers/scsi/ncr53c8xx.c:static  void    ncr_wakeup      (struct ncb *np, u_long code);
NeoLKernel/drivers/scsi/ncr53c8xx.c:static  void    ncr_wakeup_done (struct ncb *np);
NeoLKernel/drivers/scsi/ncr53c8xx.c:**	Insert a CCB into the start queue and wake up the 
NeoLKernel/drivers/scsi/ncr53c8xx.c: * First, look in the wakeup list
NeoLKernel/drivers/scsi/ncr53c8xx.c:	ncr_wakeup(np, HS_RESET);
NeoLKernel/drivers/scsi/ncr53c8xx.c: * Then, look in the wakeup list
NeoLKernel/drivers/scsi/ncr53c8xx.c:	**      Let's wake it up, since it may have to work.
NeoLKernel/drivers/scsi/ncr53c8xx.c:void ncr_wakeup_done (struct ncb *np)
NeoLKernel/drivers/scsi/ncr53c8xx.c:void ncr_wakeup (struct ncb *np, u_long code)
NeoLKernel/drivers/scsi/ncr53c8xx.c:	ncr_wakeup (np, code);
NeoLKernel/drivers/scsi/ncr53c8xx.c:		ncr_wakeup_done (np);
NeoLKernel/drivers/scsi/ncr53c8xx.c:		ncr_wakeup_done(np);
NeoLKernel/drivers/scsi/ncr53c8xx.c:		wakeup ((caddr_t) cp);
NeoLKernel/drivers/scsi/ncr53c8xx.c:	**	Chain into wakeup list and free ccb queue and take it 
NeoLKernel/drivers/scsi/nsp32.c:	pci_enable_wake    (pdev, PCI_D0, 0);
NeoLKernel/drivers/scsi/scsi_priv.h:extern void scsi_eh_wakeup(struct Scsi_Host *shost);
NeoLKernel/drivers/scsi/scsi_tgt_if.c:	wake_up_interruptible(&tgt_poll_wait);
NeoLKernel/drivers/scsi/aic7xxx/aic79xx_osm.c:		printf("Recovery code awake\n");
NeoLKernel/drivers/scsi/aic7xxx/aic7xxx_osm.c:		printf("Recovery code awake\n");
NeoLKernel/drivers/scsi/aic94xx/aic94xx_scb.c:		 * that the EH will wake up and do something.
NeoLKernel/drivers/scsi/arm/fas216.c:	wake_up(&info->eh_wait);
NeoLKernel/drivers/scsi/arm/fas216.c:	wake_up(&info->eh_wait);
NeoLKernel/drivers/scsi/arm/fas216.c: * @SCpnt: Command to wake
NeoLKernel/drivers/scsi/arm/fas216.c: * and wake up any error handler process so it can continue.
NeoLKernel/drivers/scsi/arm/fas216.c:	wake_up(&info->eh_wait);
NeoLKernel/drivers/scsi/atari_NCR5380.c:	 * need to 'wake up' the commands by a request_sense
NeoLKernel/drivers/scsi/atari_NCR5380.c:	 * conflicts when the mid-level code tries to wake up the affected
NeoLKernel/drivers/scsi/atari_NCR5380.c:	/* we did no complete reset of all commands, so a wakeup is required */
NeoLKernel/drivers/scsi/atari_scsi.c:		wake_up(&falcon_fairness_wait);
NeoLKernel/drivers/scsi/atari_scsi.c: * waked up when the DMA is unlocked by some SCSI interrupt. After that
NeoLKernel/drivers/scsi/atari_scsi.c:			wake_up(&falcon_try_wait);
NeoLKernel/drivers/scsi/bfa/bfad_im.c:		wake_up(wq);
NeoLKernel/drivers/scsi/bfa/include/cna/pstats/ethport_defs.h:	u64 netif_queue_wakeup;
NeoLKernel/drivers/scsi/bnx2i/bnx2i_hwi.c: * bnx2i_ring_sq_dbell - Ring SQ doorbell to wake-up the processing engine
NeoLKernel/drivers/scsi/bnx2i/bnx2i_hwi.c:	wake_up_interruptible(&ep->ofld_wait);
NeoLKernel/drivers/scsi/bnx2i/bnx2i_hwi.c: * process iSCSI TMF Response CQE and wake up the driver eh thread.
NeoLKernel/drivers/scsi/bnx2i/bnx2i_hwi.c:	wake_up_interruptible(&conn->ep->ofld_wait);
NeoLKernel/drivers/scsi/bnx2i/bnx2i_hwi.c:	wake_up_interruptible(&ep->ofld_wait);
NeoLKernel/drivers/scsi/bnx2i/bnx2i_hwi.c:	wake_up_interruptible(&ep->ofld_wait);
NeoLKernel/drivers/scsi/bnx2i/bnx2i_hwi.c:	wake_up_interruptible(&ep->ofld_wait);
NeoLKernel/drivers/scsi/bnx2i/bnx2i_hwi.c:	wake_up_interruptible(&ep->ofld_wait);
NeoLKernel/drivers/scsi/bnx2i/bnx2i_hwi.c:	wake_up_interruptible(&ep->ofld_wait);
NeoLKernel/drivers/scsi/3w-xxxx.c:					wake_up(&tw_dev->ioctl_wqueue);
NeoLKernel/drivers/scsi/aacraid/commsup.c:	 * fib, and then set the event to wake up the
NeoLKernel/drivers/scsi/aacraid/commsup.c:			 * Set the event to wake up the
NeoLKernel/drivers/scsi/aacraid/commsup.c:				 * fib, and then set the event to wake up the
NeoLKernel/drivers/scsi/aacraid/commsup.c:						 * Set the event to wake up the
NeoLKernel/drivers/scsi/aacraid/dpcsup.c: *	all QE there are and wake up all the waiters before exiting. We will
NeoLKernel/drivers/scsi/aacraid/dpcsup.c: *	pull off all QE there are and wake up all the waiters before exiting.
NeoLKernel/drivers/scsi/aacraid/dpcsup.c:		        wake_up_interruptible(&q->cmdready);
NeoLKernel/drivers/scsi/aacraid/dpcsup.c: *	all QE there are and wake up all the waiters before exiting.
NeoLKernel/drivers/scsi/aacraid/dpcsup.c:	        wake_up_interruptible(&q->cmdready);
NeoLKernel/drivers/serial/amba-pl011.c:		uart_write_wakeup(&uap->port);
NeoLKernel/drivers/serial/amba-pl011.c:	wake_up_interruptible(&uap->port.state->port.delta_msr_wait);
NeoLKernel/drivers/serial/Kconfig:	 clock is off, using a wakeup GPIO.
NeoLKernel/drivers/serial/21285.c:		uart_write_wakeup(port);
NeoLKernel/drivers/serial/68328serial.c:			wake_up(&keypress_wait);
NeoLKernel/drivers/serial/68328serial.c:		tty_wakeup(tty);
NeoLKernel/drivers/serial/68328serial.c:	tty_wakeup(tty);
NeoLKernel/drivers/serial/68328serial.c:		wake_up_interruptible(&info->open_wait);
NeoLKernel/drivers/serial/68328serial.c:	wake_up_interruptible(&info->close_wait);
NeoLKernel/drivers/serial/68328serial.c:	wake_up_interruptible(&info->open_wait);
NeoLKernel/drivers/serial/68360serial.c:		wake_up_interruptible(&info->delta_msr_wait);
NeoLKernel/drivers/serial/68360serial.c:			wake_up_interruptible(&info->open_wait);
NeoLKernel/drivers/serial/68360serial.c:		tty_wakeup(tty);
NeoLKernel/drivers/serial/68360serial.c:	tty_wakeup(tty);
NeoLKernel/drivers/serial/68360serial.c:	 * No need to wake up processes in open wait, since they
NeoLKernel/drivers/serial/68360serial.c:		wake_up_interruptible(&info->open_wait);
NeoLKernel/drivers/serial/68360serial.c:		wake_up_interruptible(&info->open_wait);
NeoLKernel/drivers/serial/68360serial.c:	wake_up_interruptible(&info->close_wait);
NeoLKernel/drivers/serial/68360serial.c:	wake_up_interruptible(&info->open_wait);
NeoLKernel/drivers/serial/8250.c:		uart_write_wakeup(&up->port);
NeoLKernel/drivers/serial/8250.c:		wake_up_interruptible(&up->port.state->port.delta_msr_wait);
NeoLKernel/drivers/serial/amba-pl010.c:		uart_write_wakeup(&uap->port);
NeoLKernel/drivers/serial/amba-pl010.c:	wake_up_interruptible(&uap->port.state->port.delta_msr_wait);
NeoLKernel/drivers/serial/m32r_sio.c:		uart_write_wakeup(&up->port);
NeoLKernel/drivers/serial/max3100.c:			uart_write_wakeup(&s->port);
NeoLKernel/drivers/serial/mcf.c:		uart_write_wakeup(port);
NeoLKernel/drivers/serial/mpc52xx_uart.c:/*	.set_wake	= mpc52xx_uart_set_wake,	Not supported yet */
NeoLKernel/drivers/serial/mpc52xx_uart.c:		uart_write_wakeup(port);
NeoLKernel/drivers/serial/mpsc.c:				uart_write_wakeup(&pi->port);
NeoLKernel/drivers/serial/msm_serial.c:/* optional low power wakeup, typically on a GPIO RX irq */
NeoLKernel/drivers/serial/msm_serial.c:struct msm_wakeup {
NeoLKernel/drivers/serial/msm_serial.c:	int irq;  /* < 0 indicates low power wakeup disabled */
NeoLKernel/drivers/serial/msm_serial.c:	/* bool: inject char into rx tty on wakeup */
NeoLKernel/drivers/serial/msm_serial.c:	struct msm_wakeup wakeup;
NeoLKernel/drivers/serial/msm_serial.c:static inline unsigned int use_low_power_wakeup(struct msm_port *msm_port)
NeoLKernel/drivers/serial/msm_serial.c:	return (msm_port->wakeup.irq >= 0);
NeoLKernel/drivers/serial/msm_serial.c:			if (use_low_power_wakeup(msm_port)) {
NeoLKernel/drivers/serial/msm_serial.c:				msm_port->wakeup.ignore = 1;
NeoLKernel/drivers/serial/msm_serial.c:				enable_irq(msm_port->wakeup.irq);
NeoLKernel/drivers/serial/msm_serial.c:		if (use_low_power_wakeup(msm_port))
NeoLKernel/drivers/serial/msm_serial.c:			disable_irq(msm_port->wakeup.irq);
NeoLKernel/drivers/serial/msm_serial.c:	int inject_wakeup = 0;
NeoLKernel/drivers/serial/msm_serial.c:		if (msm_port->wakeup.ignore)
NeoLKernel/drivers/serial/msm_serial.c:			msm_port->wakeup.ignore = 0;
NeoLKernel/drivers/serial/msm_serial.c:			inject_wakeup = 1;
NeoLKernel/drivers/serial/msm_serial.c:	/* we missed an rx while asleep - it must be a wakeup indicator
NeoLKernel/drivers/serial/msm_serial.c:	if (inject_wakeup) {
NeoLKernel/drivers/serial/msm_serial.c:		uart_write_wakeup(port);
NeoLKernel/drivers/serial/msm_serial.c:	wake_up_interruptible(&port->state->port.delta_msr_wait);
NeoLKernel/drivers/serial/msm_serial.c:	if (use_low_power_wakeup(msm_port)) {
NeoLKernel/drivers/serial/msm_serial.c:		ret = set_irq_wake(msm_port->wakeup.irq, 1);
NeoLKernel/drivers/serial/msm_serial.c:		ret = request_irq(msm_port->wakeup.irq, msm_rx_irq,
NeoLKernel/drivers/serial/msm_serial.c:				  "msm_serial_wakeup", msm_port);
NeoLKernel/drivers/serial/msm_serial.c:		disable_irq(msm_port->wakeup.irq);
NeoLKernel/drivers/serial/msm_serial.c:	if (use_low_power_wakeup(msm_port)) {
NeoLKernel/drivers/serial/msm_serial.c:		set_irq_wake(msm_port->wakeup.irq, 0);
NeoLKernel/drivers/serial/msm_serial.c:		free_irq(msm_port->wakeup.irq, msm_port);
NeoLKernel/drivers/serial/msm_serial.c:	if (unlikely(set_irq_wake(port->irq, 1)))
NeoLKernel/drivers/serial/msm_serial.c:		msm_port->wakeup.irq = -1;
NeoLKernel/drivers/serial/msm_serial.c:		msm_port->wakeup.irq = pdata->wakeup_irq;
NeoLKernel/drivers/serial/msm_serial.c:		msm_port->wakeup.ignore = 1;
NeoLKernel/drivers/serial/msm_serial.c:		msm_port->wakeup.inject_rx = pdata->inject_rx_on_wakeup;
NeoLKernel/drivers/serial/msm_serial.c:		msm_port->wakeup.rx_to_inject = pdata->rx_to_inject;
NeoLKernel/drivers/serial/msm_serial.c:		if (unlikely(msm_port->wakeup.irq <= 0))
NeoLKernel/drivers/serial/msm_serial_hs.c:/* This driver has optional support for low power wakeup on a rx gpio. This is
NeoLKernel/drivers/serial/msm_serial_hs.c:#include <linux/wakelock.h>
NeoLKernel/drivers/serial/msm_serial_hs.c:	struct wake_lock wake_lock;
NeoLKernel/drivers/serial/msm_serial_hs.c:/* optional low power wakeup, typically on a GPIO RX irq */
NeoLKernel/drivers/serial/msm_serial_hs.c:struct msm_hs_wakeup {
NeoLKernel/drivers/serial/msm_serial_hs.c:	int irq;  /* < 0 indicates low power wakeup disabled */
NeoLKernel/drivers/serial/msm_serial_hs.c:	/* bool: inject char into rx tty on wakeup */
NeoLKernel/drivers/serial/msm_serial_hs.c:	struct msm_hs_wakeup wakeup;
NeoLKernel/drivers/serial/msm_serial_hs.c:	struct wake_lock dma_wake_lock;  /* held while any DMA active */
NeoLKernel/drivers/serial/msm_serial_hs.c:static inline unsigned int use_low_power_wakeup(struct msm_hs_port *msm_uport)
NeoLKernel/drivers/serial/msm_serial_hs.c:	return (msm_uport->wakeup.irq > 0);
NeoLKernel/drivers/serial/msm_serial_hs.c:	wake_lock_destroy(&msm_uport->rx.wake_lock);
NeoLKernel/drivers/serial/msm_serial_hs.c:	wake_lock_destroy(&msm_uport->dma_wake_lock);
NeoLKernel/drivers/serial/msm_serial_hs.c:	wake_lock(&msm_uport->dma_wake_lock);
NeoLKernel/drivers/serial/msm_serial_hs.c:		wake_lock(&msm_uport->rx.wake_lock);
NeoLKernel/drivers/serial/msm_serial_hs.c:		wake_lock(&msm_uport->rx.wake_lock);
NeoLKernel/drivers/serial/msm_serial_hs.c:		wake_up(&msm_uport->rx.wait);
NeoLKernel/drivers/serial/msm_serial_hs.c:	/* release wakelock in 500ms, not immediately, because higher layers
NeoLKernel/drivers/serial/msm_serial_hs.c:	 * don't always take wakelocks when they should */
NeoLKernel/drivers/serial/msm_serial_hs.c:	wake_lock_timeout(&msm_uport->rx.wake_lock, HZ / 2);
NeoLKernel/drivers/serial/msm_serial_hs.c:	wake_up_interruptible(&uport->state->port.delta_msr_wait);
NeoLKernel/drivers/serial/msm_serial_hs.c:	if (use_low_power_wakeup(msm_uport)) {
NeoLKernel/drivers/serial/msm_serial_hs.c:		msm_uport->wakeup.ignore = 1;
NeoLKernel/drivers/serial/msm_serial_hs.c:		enable_irq(msm_uport->wakeup.irq);
NeoLKernel/drivers/serial/msm_serial_hs.c:	wake_unlock(&msm_uport->dma_wake_lock);
NeoLKernel/drivers/serial/msm_serial_hs.c:		wake_lock(&rx->wake_lock);  /* hold wakelock while rx dma */
NeoLKernel/drivers/serial/msm_serial_hs.c:			uart_write_wakeup(uport);
NeoLKernel/drivers/serial/msm_serial_hs.c:		wake_lock(&msm_uport->dma_wake_lock);
NeoLKernel/drivers/serial/msm_serial_hs.c:		disable_irq_nosync(msm_uport->wakeup.irq);
NeoLKernel/drivers/serial/msm_serial_hs.c:static irqreturn_t msm_hs_wakeup_isr(int irq, void *dev)
NeoLKernel/drivers/serial/msm_serial_hs.c:	unsigned int wakeup = 0;
NeoLKernel/drivers/serial/msm_serial_hs.c:		if (msm_uport->wakeup.ignore)
NeoLKernel/drivers/serial/msm_serial_hs.c:			msm_uport->wakeup.ignore = 0;
NeoLKernel/drivers/serial/msm_serial_hs.c:			wakeup = 1;
NeoLKernel/drivers/serial/msm_serial_hs.c:	if (wakeup) {
NeoLKernel/drivers/serial/msm_serial_hs.c:		/* the uart was clocked off during an rx, wake up and
NeoLKernel/drivers/serial/msm_serial_hs.c:		if (msm_uport->wakeup.inject_rx) {
NeoLKernel/drivers/serial/msm_serial_hs.c:					     msm_uport->wakeup.rx_to_inject,
NeoLKernel/drivers/serial/msm_serial_hs.c:	if (wakeup && msm_uport->wakeup.inject_rx)
NeoLKernel/drivers/serial/msm_serial_hs.c:	if (use_low_power_wakeup(msm_uport)) {
NeoLKernel/drivers/serial/msm_serial_hs.c:		ret = set_irq_wake(msm_uport->wakeup.irq, 1);
NeoLKernel/drivers/serial/msm_serial_hs.c:	ret = set_irq_wake(uport->irq, 1);
NeoLKernel/drivers/serial/msm_serial_hs.c:	if (use_low_power_wakeup(msm_uport)) {
NeoLKernel/drivers/serial/msm_serial_hs.c:		ret = request_irq(msm_uport->wakeup.irq, msm_hs_wakeup_isr,
NeoLKernel/drivers/serial/msm_serial_hs.c:				  "msm_hs_wakeup", msm_uport);
NeoLKernel/drivers/serial/msm_serial_hs.c:		disable_irq(msm_uport->wakeup.irq);
NeoLKernel/drivers/serial/msm_serial_hs.c:	wake_lock_init(&rx->wake_lock, WAKE_LOCK_SUSPEND, "msm_serial_hs_rx");
NeoLKernel/drivers/serial/msm_serial_hs.c:	wake_lock_init(&msm_uport->dma_wake_lock, WAKE_LOCK_SUSPEND,
NeoLKernel/drivers/serial/msm_serial_hs.c:	wake_lock_destroy(&msm_uport->rx.wake_lock);
NeoLKernel/drivers/serial/msm_serial_hs.c:	wake_lock_destroy(&msm_uport->dma_wake_lock);
NeoLKernel/drivers/serial/msm_serial_hs.c:		msm_uport->wakeup.irq = -1;
NeoLKernel/drivers/serial/msm_serial_hs.c:		msm_uport->wakeup.irq = pdata->wakeup_irq;
NeoLKernel/drivers/serial/msm_serial_hs.c:		msm_uport->wakeup.ignore = 1;
NeoLKernel/drivers/serial/msm_serial_hs.c:		msm_uport->wakeup.inject_rx = pdata->inject_rx_on_wakeup;
NeoLKernel/drivers/serial/msm_serial_hs.c:		msm_uport->wakeup.rx_to_inject = pdata->rx_to_inject;
NeoLKernel/drivers/serial/msm_serial_hs.c:		if (unlikely(msm_uport->wakeup.irq < 0))
NeoLKernel/drivers/serial/msm_serial_hs.c:		wake_unlock(&msm_uport->dma_wake_lock);
NeoLKernel/drivers/serial/msm_serial_hs.c:	if (use_low_power_wakeup(msm_uport))
NeoLKernel/drivers/serial/msm_serial_hs.c:		set_irq_wake(msm_uport->wakeup.irq, 0);
NeoLKernel/drivers/serial/msm_serial_hs.c:	set_irq_wake(uport->irq, 0);
NeoLKernel/drivers/serial/msm_serial_hs.c:	if (use_low_power_wakeup(msm_uport))
NeoLKernel/drivers/serial/msm_serial_hs.c:		free_irq(msm_uport->wakeup.irq, msm_uport);
NeoLKernel/drivers/serial/msm_serial_hs_lite.c:		uart_write_wakeup(port);
NeoLKernel/drivers/serial/msm_serial_hs_lite.c:	wake_up_interruptible(&port->state->port.delta_msr_wait);
NeoLKernel/drivers/serial/msm_serial_hs_lite.c:	if (unlikely(set_irq_wake(port->irq, 1))) {
NeoLKernel/drivers/serial/msm_serial_hs_lite.c:		printk(KERN_ERR "%s: set_irq_wake failed\n", __func__);
NeoLKernel/drivers/serial/mux.c:		uart_write_wakeup(port);
NeoLKernel/drivers/serial/netx-serial.c:		uart_write_wakeup(port);
NeoLKernel/drivers/serial/pmac_zilog.c:		wake_up_interruptible(&uap->port.state->port.delta_msr_wait);
NeoLKernel/drivers/serial/pmac_zilog.c:		uart_write_wakeup(&uap->port);
NeoLKernel/drivers/serial/pmac_zilog.c:		uart_write_wakeup(&uap->port);
NeoLKernel/drivers/serial/pmac_zilog.c:			uart_write_wakeup(&uap->port);
NeoLKernel/drivers/serial/pnx8xxx_uart.c:	wake_up_interruptible(&sport->port.state->port.delta_msr_wait);
NeoLKernel/drivers/serial/pnx8xxx_uart.c:		uart_write_wakeup(&sport->port);
NeoLKernel/drivers/serial/pxa.c:		uart_write_wakeup(&up->port);
NeoLKernel/drivers/serial/pxa.c:	wake_up_interruptible(&up->port.state->port.delta_msr_wait);
NeoLKernel/drivers/serial/sa1100.c:	wake_up_interruptible(&sport->port.state->port.delta_msr_wait);
NeoLKernel/drivers/serial/sa1100.c:		uart_write_wakeup(&sport->port);
NeoLKernel/drivers/serial/sa1100.c:	sa1100_pops.set_wake = fns->set_wake;
NeoLKernel/drivers/serial/samsung.c:		uart_write_wakeup(port);
NeoLKernel/drivers/serial/sb1250-duart.c:			uart_write_wakeup(&sport->port);
NeoLKernel/drivers/serial/sb1250-duart.c:		wake_up_interruptible(&uport->state->port.delta_msr_wait);
NeoLKernel/drivers/serial/sc26xx.c:		uart_write_wakeup(port);
NeoLKernel/drivers/serial/serial_core.c:void uart_write_wakeup(struct uart_port *port)
NeoLKernel/drivers/serial/serial_core.c:	if (port->ops->wake_peer)
NeoLKernel/drivers/serial/serial_core.c:		port->ops->wake_peer(port);
NeoLKernel/drivers/serial/serial_core.c:	tty_wakeup(state->port.tty);
NeoLKernel/drivers/serial/serial_core.c:		wake_up_interruptible(&port->delta_msr_wait);
NeoLKernel/drivers/serial/serial_core.c:	tty_wakeup(tty);
NeoLKernel/drivers/serial/serial_core.c:	 * No need to wake up processes in open wait, since they
NeoLKernel/drivers/serial/serial_core.c:		wake_up_interruptible(&state->uart_port.open_wait);
NeoLKernel/drivers/serial/serial_core.c:	wake_up_interruptible(&port->open_wait);
NeoLKernel/drivers/serial/serial_core.c:		wake_up_interruptible(&port->open_wait);
NeoLKernel/drivers/serial/serial_core.c:		wake_up_interruptible(&port->delta_msr_wait);
NeoLKernel/drivers/serial/serial_core.c:	if (device_may_wakeup(tty_dev)) {
NeoLKernel/drivers/serial/serial_core.c:		enable_irq_wake(uport->irq);
NeoLKernel/drivers/serial/serial_core.c:	if (!uport->suspended && device_may_wakeup(tty_dev)) {
NeoLKernel/drivers/serial/serial_core.c:		disable_irq_wake(uport->irq);
NeoLKernel/drivers/serial/serial_core.c:		device_init_wakeup(tty_dev, 1);
NeoLKernel/drivers/serial/serial_core.c:		device_set_wakeup_enable(tty_dev, 0);
NeoLKernel/drivers/serial/serial_core.c:EXPORT_SYMBOL(uart_write_wakeup);
NeoLKernel/drivers/serial/serial_cs.c:	void (*wakeup)(struct pcmcia_device *);
NeoLKernel/drivers/serial/serial_cs.c:static void quirk_wakeup_oxsemi(struct pcmcia_device *link)
NeoLKernel/drivers/serial/serial_cs.c:static void quirk_wakeup_possio_gcc(struct pcmcia_device *link)
NeoLKernel/drivers/serial/serial_cs.c:		.wakeup	= quirk_wakeup_oxsemi,
NeoLKernel/drivers/serial/serial_cs.c:		.wakeup	= quirk_wakeup_possio_gcc,
NeoLKernel/drivers/serial/serial_cs.c:	if (info->quirk && info->quirk->wakeup)
NeoLKernel/drivers/serial/serial_cs.c:		info->quirk->wakeup(link);
NeoLKernel/drivers/serial/serial_cs.c:		 * FIXME: We really should wake up the port prior to
NeoLKernel/drivers/serial/serial_cs.c:		if (info->quirk && info->quirk->wakeup)
NeoLKernel/drivers/serial/serial_cs.c:			info->quirk->wakeup(link);
NeoLKernel/drivers/serial/serial_ks8695.c:		uart_write_wakeup(port);
NeoLKernel/drivers/serial/serial_ks8695.c:	wake_up_interruptible(&port->state->port.delta_msr_wait);
NeoLKernel/drivers/serial/serial_lh7a40x.c:		uart_write_wakeup (port);
NeoLKernel/drivers/serial/serial_lh7a40x.c:	wake_up_interruptible (&port->state->port.delta_msr_wait);
NeoLKernel/drivers/serial/serial_txx9.c:		uart_write_wakeup(&up->port);
NeoLKernel/drivers/serial/sh-sci.c:		uart_write_wakeup(port);
NeoLKernel/drivers/serial/sn_console.c:		void (*sal_wakeup_transmit) (struct sn_cons_port *, int);
NeoLKernel/drivers/serial/sn_console.c:	.sal_wakeup_transmit = sn_transmit_chars
NeoLKernel/drivers/serial/sn_console.c:	if (sal_console_port.sc_ops->sal_wakeup_transmit)
NeoLKernel/drivers/serial/sn_console.c:		sal_console_port.sc_ops->sal_wakeup_transmit(&sal_console_port,
NeoLKernel/drivers/serial/sn_console.c:		uart_write_wakeup(&port->sc_port);
NeoLKernel/drivers/serial/sunhv.c:		uart_write_wakeup(port);
NeoLKernel/drivers/serial/sunsab.c:		uart_write_wakeup(&up->port);
NeoLKernel/drivers/serial/sunsab.c:	wake_up_interruptible(&up->port.state->port.delta_msr_wait);
NeoLKernel/drivers/serial/sunsu.c:		uart_write_wakeup(&up->port);
NeoLKernel/drivers/serial/sunsu.c:	wake_up_interruptible(&up->port.state->port.delta_msr_wait);
NeoLKernel/drivers/serial/sunzilog.c:		wake_up_interruptible(&up->port.state->port.delta_msr_wait);
NeoLKernel/drivers/serial/sunzilog.c:		uart_write_wakeup(&up->port);
NeoLKernel/drivers/serial/sunzilog.c:			uart_write_wakeup(&up->port);
NeoLKernel/drivers/serial/timbuart.c:			uart_write_wakeup(port);
NeoLKernel/drivers/serial/timbuart.c:	 * we wake up the upper layer later when we got the interrupt
NeoLKernel/drivers/serial/timbuart.c:		wake_up_interruptible(&port->state->port.delta_msr_wait);
NeoLKernel/drivers/serial/uartlite.c:	/* wake up */
NeoLKernel/drivers/serial/uartlite.c:		uart_write_wakeup(port);
NeoLKernel/drivers/serial/ucc_uart.c:		uart_write_wakeup(port);
NeoLKernel/drivers/serial/vr41xx_siu.c:	wake_up_interruptible(&port->state->port.delta_msr_wait);
NeoLKernel/drivers/serial/vr41xx_siu.c:		uart_write_wakeup(port);
NeoLKernel/drivers/serial/zs.c:		uart_write_wakeup(&zport->port);
NeoLKernel/drivers/serial/zs.c:			wake_up_interruptible(&uport->state->port.delta_msr_wait);
NeoLKernel/drivers/serial/atmel_serial.c:	int			may_wakeup;	/* cached value of device_may_wakeup for times we need to disable it */
NeoLKernel/drivers/serial/atmel_serial.c:		uart_write_wakeup(port);
NeoLKernel/drivers/serial/atmel_serial.c:		uart_write_wakeup(port);
NeoLKernel/drivers/serial/atmel_serial.c:		wake_up_interruptible(&port->state->port.delta_msr_wait);
NeoLKernel/drivers/serial/atmel_serial.c:	atmel_pops.set_wake	= fns->set_wake;
NeoLKernel/drivers/serial/atmel_serial.c:	/* we can not wake up if we're running on slow clock */
NeoLKernel/drivers/serial/atmel_serial.c:	atmel_port->may_wakeup = device_may_wakeup(&pdev->dev);
NeoLKernel/drivers/serial/atmel_serial.c:		device_set_wakeup_enable(&pdev->dev, 0);
NeoLKernel/drivers/serial/atmel_serial.c:	device_set_wakeup_enable(&pdev->dev, atmel_port->may_wakeup);
NeoLKernel/drivers/serial/atmel_serial.c:	device_init_wakeup(&pdev->dev, 1);
NeoLKernel/drivers/serial/atmel_serial.c:	device_init_wakeup(&pdev->dev, 0);
NeoLKernel/drivers/serial/bcm63xx_uart.c:		uart_write_wakeup(port);
NeoLKernel/drivers/serial/bcm_bt_lpm.c:	unsigned int gpio_wake;
NeoLKernel/drivers/serial/bcm_bt_lpm.c:	unsigned int gpio_host_wake;
NeoLKernel/drivers/serial/bcm_bt_lpm.c:	int wake;
NeoLKernel/drivers/serial/bcm_bt_lpm.c:	int host_wake;
NeoLKernel/drivers/serial/bcm_bt_lpm.c:static void set_wake_locked(int wake)
NeoLKernel/drivers/serial/bcm_bt_lpm.c:	if (wake == bt_lpm.wake)
NeoLKernel/drivers/serial/bcm_bt_lpm.c:	bt_lpm.wake = wake;
NeoLKernel/drivers/serial/bcm_bt_lpm.c:	if (wake || bt_lpm.host_wake) {
NeoLKernel/drivers/serial/bcm_bt_lpm.c:		gpio_set_value(bt_lpm.gpio_wake, wake);
NeoLKernel/drivers/serial/bcm_bt_lpm.c:		gpio_set_value(bt_lpm.gpio_wake, 0);
NeoLKernel/drivers/serial/bcm_bt_lpm.c:	set_wake_locked(0);
NeoLKernel/drivers/serial/bcm_bt_lpm.c:	set_wake_locked(1);
NeoLKernel/drivers/serial/bcm_bt_lpm.c:static void update_host_wake_locked(int host_wake)
NeoLKernel/drivers/serial/bcm_bt_lpm.c:	if (host_wake == bt_lpm.host_wake)
NeoLKernel/drivers/serial/bcm_bt_lpm.c:	bt_lpm.host_wake = host_wake;
NeoLKernel/drivers/serial/bcm_bt_lpm.c:	if (bt_lpm.wake || host_wake) {
NeoLKernel/drivers/serial/bcm_bt_lpm.c:static irqreturn_t host_wake_isr(int irq, void *dev)
NeoLKernel/drivers/serial/bcm_bt_lpm.c:	int host_wake;
NeoLKernel/drivers/serial/bcm_bt_lpm.c:	host_wake = gpio_get_value(bt_lpm.gpio_host_wake);
NeoLKernel/drivers/serial/bcm_bt_lpm.c:		bt_lpm.host_wake = host_wake;
NeoLKernel/drivers/serial/bcm_bt_lpm.c:	update_host_wake_locked(host_wake);
NeoLKernel/drivers/serial/bcm_bt_lpm.c:	bt_lpm.gpio_wake = pdata->gpio_wake;
NeoLKernel/drivers/serial/bcm_bt_lpm.c:	bt_lpm.gpio_host_wake = pdata->gpio_host_wake;
NeoLKernel/drivers/serial/bcm_bt_lpm.c:	gpio_set_value(bt_lpm.gpio_wake, 0);
NeoLKernel/drivers/serial/bcm_bt_lpm.c:	bt_lpm.host_wake = 0;
NeoLKernel/drivers/serial/bcm_bt_lpm.c:	irq = gpio_to_irq(bt_lpm.gpio_host_wake);
NeoLKernel/drivers/serial/bcm_bt_lpm.c:	ret = request_irq(irq, host_wake_isr,
NeoLKernel/drivers/serial/bcm_bt_lpm.c:			"bt host_wake", NULL);
NeoLKernel/drivers/serial/bcm_bt_lpm.c:	ret = set_irq_wake(irq, 1);
NeoLKernel/drivers/serial/bfin_5xx.c:		uart_write_wakeup(&uart->port);
NeoLKernel/drivers/serial/bfin_5xx.c:			uart_write_wakeup(&uart->port);
NeoLKernel/drivers/serial/bfin_sport_uart.c:		uart_write_wakeup(&up->port);
NeoLKernel/drivers/serial/clps711x.c:		uart_write_wakeup(port);
NeoLKernel/drivers/serial/cpm_uart/cpm_uart_core.c:		uart_write_wakeup(port);
NeoLKernel/drivers/serial/crisv10.c:	/* if there is only a few chars left in the buf, wake up the blocked
NeoLKernel/drivers/serial/crisv10.c:	/* Don't send all in one DMA transfer - divide it so we wake up
NeoLKernel/drivers/serial/crisv10.c:		tty_wakeup(tty);
NeoLKernel/drivers/serial/crisv10.c:	tty_wakeup(tty);
NeoLKernel/drivers/serial/crisv10.c:		wake_up_interruptible(&info->open_wait);
NeoLKernel/drivers/serial/crisv10.c:	wake_up_interruptible(&info->close_wait);
NeoLKernel/drivers/serial/crisv10.c:	wake_up_interruptible(&info->open_wait);
NeoLKernel/drivers/serial/dz.c:		uart_write_wakeup(&dport->port);
NeoLKernel/drivers/serial/icom.c:		wake_up_interruptible(&icom_port->uart_port.state->
NeoLKernel/drivers/serial/icom.c:			uart_write_wakeup(&icom_port->uart_port);
NeoLKernel/drivers/serial/imx.c:#define  UCR3_AIRINTEN   (1<<5)  /* Async IR wake interrupt enable */
NeoLKernel/drivers/serial/imx.c:#define  UCR3_AWAKEN	 (1<<4)  /* Async wake interrupt enable */
NeoLKernel/drivers/serial/imx.c:#define  USR1_AIRINT	 (1<<5)	 /* Async IR wake interrupt flag */
NeoLKernel/drivers/serial/imx.c:#define  USR1_AWAKE 	 (1<<4)	 /* Aysnc wake interrupt flag */
NeoLKernel/drivers/serial/imx.c:	wake_up_interruptible(&sport->port.state->port.delta_msr_wait);
NeoLKernel/drivers/serial/imx.c:		uart_write_wakeup(&sport->port);
NeoLKernel/drivers/serial/imx.c:	wake_up_interruptible(&sport->port.state->port.delta_msr_wait);
NeoLKernel/drivers/serial/imx.c:		uart_write_wakeup(&sport->port);
NeoLKernel/drivers/serial/ioc3_serial.c:		uart_write_wakeup(the_port);
NeoLKernel/drivers/serial/ioc3_serial.c:						wake_up_interruptible
NeoLKernel/drivers/serial/ioc3_serial.c:				wake_up_interruptible
NeoLKernel/drivers/serial/ioc3_serial.c:				wake_up_interruptible
NeoLKernel/drivers/serial/ioc3_serial.c:	wake_up_interruptible(&state->port.delta_msr_wait);
NeoLKernel/drivers/serial/ioc4_serial.c:		uart_write_wakeup(the_port);
NeoLKernel/drivers/serial/ioc4_serial.c:				wake_up_interruptible
NeoLKernel/drivers/serial/ioc4_serial.c:				wake_up_interruptible
NeoLKernel/drivers/serial/ioc4_serial.c:						wake_up_interruptible
NeoLKernel/drivers/serial/ioc4_serial.c:	wake_up_interruptible(&state->port.delta_msr_wait);
NeoLKernel/drivers/serial/ip22zilog.c:		wake_up_interruptible(&up->port.state->port.delta_msr_wait);
NeoLKernel/drivers/serial/ip22zilog.c:		uart_write_wakeup(&up->port);
NeoLKernel/drivers/serial/ip22zilog.c:			uart_write_wakeup(&up->port);
NeoLKernel/drivers/serial/jsm/jsm_neo.c:		uart_write_wakeup(&ch->uart_port);
NeoLKernel/drivers/serial/jsm/jsm_tty.c:		 * When carrier rises, wake any threads waiting
NeoLKernel/drivers/serial/jsm/jsm_tty.c:			wake_up_interruptible(&ch->ch_flags_wait);
NeoLKernel/drivers/serial/jsm/jsm_tty.c:		 * When carrier rises, wake any threads waiting
NeoLKernel/drivers/serial/jsm/jsm_tty.c:			wake_up_interruptible(&ch->ch_flags_wait);
NeoLKernel/drivers/serial/jsm/jsm_tty.c:			wake_up_interruptible(&ch->ch_flags_wait);
NeoLKernel/drivers/sh/intc.c:static int intc_set_wake(unsigned int irq, unsigned int on)
NeoLKernel/drivers/sh/intc.c:	return 0; /* allow wakeup, but setup hardware in intc_suspend() */
NeoLKernel/drivers/sh/intc.c:	d->chip.set_wake = intc_set_wake;
NeoLKernel/drivers/sh/intc.c:		/* enable wakeup irqs belonging to this intc controller */
NeoLKernel/drivers/sh/maple/maple.c:				wake_up(&mdev->maple_wait);
NeoLKernel/drivers/sh/maple/maple.c:				wake_up(&mdev->maple_wait);
NeoLKernel/drivers/sh/maple/maple.c:				wake_up(&mdev->maple_wait);
NeoLKernel/drivers/sh/maple/maple.c:				wake_up(&mdev->maple_wait);
NeoLKernel/drivers/spi/amba-pl022.c:	 * execution path (pump_messages) would be required to call wake_up or
NeoLKernel/drivers/spi/mpc52xx_psc_spi.c:/* wake up when 80% fifo full */
NeoLKernel/drivers/spi/mpc52xx_psc_spi.c:		/* enable interrupts and wait for wake up
NeoLKernel/drivers/spi/mpc52xx_psc_spi.c:	/* disable interrupt and wake up the work queue */
NeoLKernel/drivers/spi/omap2_mcspi.c:	u32 wakeupenable;
NeoLKernel/drivers/spi/omap2_mcspi.c:			omap2_mcspi_ctx[spi_cntrl->bus_num - 1].wakeupenable);
NeoLKernel/drivers/spi/omap2_mcspi.c:	omap2_mcspi_ctx[master->bus_num - 1].wakeupenable = tmp;
NeoLKernel/drivers/spi/pxa2xx_spi.c:	 * execution path (pump_messages) would be required to call wake_up or
NeoLKernel/drivers/spi/spi_bfin5xx.c:	 * execution path (pump_messages) would be required to call wake_up or
NeoLKernel/drivers/spi/spi_qsd.c:		wake_up_interruptible(&dd->continue_suspend);
NeoLKernel/drivers/spi/spi_txx9.c:	wake_up(&c->waitq);
NeoLKernel/drivers/staging/panel/panel.c:		wake_up_interruptible(&keypad_read_wait);
NeoLKernel/drivers/staging/altpciechdma/altpciechdma.c: *   to wake us on completion.
NeoLKernel/drivers/staging/android/binder.c:		wake_up(&binder_user_error_wait);
NeoLKernel/drivers/staging/android/binder.c:			wake_up_interruptible(&node->proc->wait);
NeoLKernel/drivers/staging/android/binder.c:				wake_up_interruptible(&target_thread->wait);
NeoLKernel/drivers/staging/android/binder.c:		wake_up_interruptible(target_wait);
NeoLKernel/drivers/staging/android/binder.c:						wake_up_interruptible(&proc->wait);
NeoLKernel/drivers/staging/android/binder.c:						wake_up_interruptible(&proc->wait);
NeoLKernel/drivers/staging/android/binder.c:					wake_up_interruptible(&proc->wait);
NeoLKernel/drivers/staging/android/binder.c:				wake_up_interruptible(&proc->wait);
NeoLKernel/drivers/staging/android/binder.c:	int wake_count = 0;
NeoLKernel/drivers/staging/android/binder.c:			wake_up_interruptible(&thread->wait);
NeoLKernel/drivers/staging/android/binder.c:			wake_count++;
NeoLKernel/drivers/staging/android/binder.c:	wake_up_interruptible_all(&proc->wait);
NeoLKernel/drivers/staging/android/binder.c:		     wake_count);
NeoLKernel/drivers/staging/android/binder.c:						wake_up_interruptible(&ref->proc->wait);
NeoLKernel/drivers/staging/android/logger.c:	/* wake up any blocked readers */
NeoLKernel/drivers/staging/android/logger.c:	wake_up_interruptible(&log->wq);
NeoLKernel/drivers/staging/b3dfg/b3dfg.c:	wake_up_interruptible(&fgdev->buffer_waitqueue);
NeoLKernel/drivers/staging/b3dfg/b3dfg.c:	 * Record cable state change timestamp & wake anyone waiting
NeoLKernel/drivers/staging/b3dfg/b3dfg.c:	wake_up_interruptible(&fgdev->buffer_waitqueue);
NeoLKernel/drivers/staging/b3dfg/b3dfg.c:		wake_up_interruptible(&fgdev->buffer_waitqueue);
NeoLKernel/drivers/staging/comedi/comedi.h:#define TRIG_WAKE_EOS	0x0020	/* wake up on end-of-scan events */
NeoLKernel/drivers/staging/comedi/comedi_fops.c:			wake_up_interruptible(&async->wait_head);
NeoLKernel/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c:			/*  don't we want wake up every scan? */
NeoLKernel/drivers/staging/comedi/drivers/adl_pci9118.c:	/*  we want wake up every scan? */
NeoLKernel/drivers/staging/comedi/drivers/adv_pci1710.c:	unsigned char ai_eos;	/*  1=EOS wake up */
NeoLKernel/drivers/staging/comedi/drivers/adv_pci1710.c:	if ((devpriv->ai_flags & TRIG_WAKE_EOS)) {	/*  don't we want wake up every scan?            devpriv->ai_eos=1; */
NeoLKernel/drivers/staging/comedi/drivers/pcl812.c:	unsigned char ai_eos;	/*  1=EOS wake up */
NeoLKernel/drivers/staging/comedi/drivers/pcl812.c:	if ((devpriv->ai_flags & TRIG_WAKE_EOS)) {	/*  don't we want wake up every scan? */
NeoLKernel/drivers/staging/comedi/drivers/pcl816.c:	if ((cmd->flags & TRIG_WAKE_EOS)) {	/*  don't we want wake up every scan? */
NeoLKernel/drivers/staging/comedi/drivers/vmk80xx.c:	wake_up_interruptible(&dev->write_wait);
NeoLKernel/drivers/staging/comedi/drivers/vmk80xx.c:	wake_up_interruptible(&dev->read_wait);
NeoLKernel/drivers/staging/comedi/drivers/amplc_pc236.c:used to wake up tasks.  This is like the comedi_parport device, but the
NeoLKernel/drivers/staging/comedi/drivers/amplc_pci230.c:	unsigned int wake;
NeoLKernel/drivers/staging/comedi/drivers/amplc_pci230.c:		wake = scanlen - devpriv->ai_scan_pos;
NeoLKernel/drivers/staging/comedi/drivers/amplc_pci230.c:			wake = PCI230_ADC_FIFOLEVEL_HALFFULL;
NeoLKernel/drivers/staging/comedi/drivers/amplc_pci230.c:			wake = (devpriv->ai_scan_count * scanlen)
NeoLKernel/drivers/staging/comedi/drivers/amplc_pci230.c:	if (wake >= PCI230_ADC_FIFOLEVEL_HALFFULL) {
NeoLKernel/drivers/staging/comedi/drivers/amplc_pci230.c:		if ((wake > 1) && (devpriv->hwver > 0)) {
NeoLKernel/drivers/staging/comedi/drivers/amplc_pci230.c:			if (devpriv->adcfifothresh != wake) {
NeoLKernel/drivers/staging/comedi/drivers/amplc_pci230.c:				devpriv->adcfifothresh = wake;
NeoLKernel/drivers/staging/comedi/drivers/amplc_pci230.c:				outw(wake, dev->iobase + PCI230P_ADCFFTH);
NeoLKernel/drivers/staging/comedi/drivers/comedi_parport.c:pin, which can be used to wake up tasks.
NeoLKernel/drivers/staging/comedi/drivers/ni_labpc.c:		   /*  wake-end-of-scan should interrupt on fifo not empty */
NeoLKernel/drivers/staging/comedi/drivers/ni_mio_common.c:			/* wake on end-of-scan */
NeoLKernel/drivers/staging/cx25821/cx25821-video.c:void cx25821_video_wakeup(struct cx25821_dev *dev, struct cx25821_dmaqueue *q,
NeoLKernel/drivers/staging/cx25821/cx25821-video.c:		wake_up(&buf->vb.done);
NeoLKernel/drivers/staging/cx25821/cx25821-video.c:		wake_up(&buf->vb.done);
NeoLKernel/drivers/staging/cx25821/cx25821-video.c:		cx25821_video_wakeup(dev, &dev->vidq[channel->i], count);
NeoLKernel/drivers/staging/cx25821/cx25821-video.h:extern void cx25821_video_wakeup(struct cx25821_dev *dev,
NeoLKernel/drivers/staging/dream/camera/msm_camera.c:	/* wake up config thread */
NeoLKernel/drivers/staging/dream/camera/msm_camera.c:	wake_up(&sync->msg_event_wait);
NeoLKernel/drivers/staging/dream/camera/msm_camera.c:		/* wake up control thread */
NeoLKernel/drivers/staging/dream/camera/msm_camera.c:		wake_up(&ctrl_pmsm->ctrl_q.ctrl_status_wait);
NeoLKernel/drivers/staging/dream/camera/msm_camera.c:	wake_up(&sync->pict_frame_wait);
NeoLKernel/drivers/staging/dream/camera/msm_camera.c:		wake_unlock(&sync->wake_lock);
NeoLKernel/drivers/staging/dream/camera/msm_camera.c:	wake_up(&sync->prev_frame_wait);
NeoLKernel/drivers/staging/dream/camera/msm_camera.c:			wake_up(&sync->prev_frame_wait);
NeoLKernel/drivers/staging/dream/camera/msm_camera.c:			wake_up(&sync->pict_frame_wait);
NeoLKernel/drivers/staging/dream/camera/msm_camera.c:	wake_up(&sync->msg_event_wait);
NeoLKernel/drivers/staging/dream/camera/msm_camera.c:		wake_lock(&sync->wake_lock);
NeoLKernel/drivers/staging/dream/camera/msm_camera.c:	/* wake up config thread, 4 is for V4L2 application */
NeoLKernel/drivers/staging/dream/camera/msm_camera.c:	wake_lock_init(&sync->wake_lock, WAKE_LOCK_IDLE, "msm_camera");
NeoLKernel/drivers/staging/dream/camera/msm_camera.c:		wake_lock_destroy(&sync->wake_lock);
NeoLKernel/drivers/staging/dream/camera/msm_camera.c:	wake_lock_destroy(&sync->wake_lock);
NeoLKernel/drivers/staging/dream/camera/msm_vfe7x.c:			wake_up(&stopevent.wait);
NeoLKernel/drivers/staging/dream/gpio_input.c:#include <linux/wakelock.h>
NeoLKernel/drivers/staging/dream/gpio_input.c:	struct wake_lock wake_lock;
NeoLKernel/drivers/staging/dream/gpio_input.c:		wake_unlock(&ds->wake_lock);
NeoLKernel/drivers/staging/dream/gpio_input.c:				wake_lock(&ds->wake_lock);
NeoLKernel/drivers/staging/dream/gpio_input.c:		enable_irq_wake(irq);
NeoLKernel/drivers/staging/dream/gpio_input.c:		wake_lock_init(&ds->wake_lock, WAKE_LOCK_SUSPEND, "gpio_input");
NeoLKernel/drivers/staging/dream/gpio_input.c:	wake_lock_destroy(&ds->wake_lock);
NeoLKernel/drivers/staging/dream/gpio_matrix.c:#include <linux/wakelock.h>
NeoLKernel/drivers/staging/dream/gpio_matrix.c:	struct wake_lock wake_lock;
NeoLKernel/drivers/staging/dream/gpio_matrix.c:	wake_unlock(&kp->wake_lock);
NeoLKernel/drivers/staging/dream/gpio_matrix.c:	wake_lock(&kp->wake_lock);
NeoLKernel/drivers/staging/dream/gpio_matrix.c:		err = set_irq_wake(irq, 1);
NeoLKernel/drivers/staging/dream/gpio_matrix.c:			pr_err("gpiomatrix: set_irq_wake failed for input %d, "
NeoLKernel/drivers/staging/dream/gpio_matrix.c:		wake_lock_init(&kp->wake_lock, WAKE_LOCK_SUSPEND, "gpio_kp");
NeoLKernel/drivers/staging/dream/gpio_matrix.c:			wake_lock(&kp->wake_lock);
NeoLKernel/drivers/staging/dream/gpio_matrix.c:	wake_lock_destroy(&kp->wake_lock);
NeoLKernel/drivers/staging/dream/qdsp5/adsp.c:#include <linux/wakelock.h>
NeoLKernel/drivers/staging/dream/qdsp5/adsp.c:static struct wake_lock adsp_wake_lock;
NeoLKernel/drivers/staging/dream/qdsp5/adsp.c:	wake_lock(&adsp_wake_lock);
NeoLKernel/drivers/staging/dream/qdsp5/adsp.c:	wake_unlock(&adsp_wake_lock);
NeoLKernel/drivers/staging/dream/qdsp5/adsp.c:		wake_up(&adsp_info.init_info_wait);
NeoLKernel/drivers/staging/dream/qdsp5/adsp.c:		wake_up(&module->state_wait);
NeoLKernel/drivers/staging/dream/qdsp5/adsp.c:		wake_up(&module->state_wait);
NeoLKernel/drivers/staging/dream/qdsp5/adsp.c:		wake_up(&module->state_wait);
NeoLKernel/drivers/staging/dream/qdsp5/adsp.c:	wake_lock_init(&adsp_wake_lock, WAKE_LOCK_SUSPEND, "adsp");
NeoLKernel/drivers/staging/dream/qdsp5/adsp_driver.c:		wake_up(&adev->event_wait);
NeoLKernel/drivers/staging/dream/qdsp5/adsp_driver.c:	wake_up(&adev->event_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_aac.c:		wake_up(&audio->write_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_aac.c:		wake_up(&audio->read_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_aac.c:	wake_up(&audio->read_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_aac.c:			wake_up(&audio->write_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_aac.c:	wake_up(&audio->write_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_aac.c:	wake_up(&audio->read_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_amrnb.c:		wake_up(&audio->write_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_amrnb.c:		wake_up(&audio->read_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_amrnb.c:	wake_up(&audio->read_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_amrnb.c:			wake_up(&audio->write_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_amrnb.c:			/* Make sure we're stopped and we wake any threads
NeoLKernel/drivers/staging/dream/qdsp5/audio_amrnb.c:			wake_up(&audio->write_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_amrnb.c:			wake_up(&audio->read_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_evrc.c:		wake_up(&audio->write_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_evrc.c:		wake_up(&audio->read_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_evrc.c:	wake_up(&audio->read_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_evrc.c:			wake_up(&audio->write_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_in.c:		wake_up(&audio->wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_in.c:	wake_up(&audio->wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_in.c:			/* Make sure we're stopped and we wake any threads
NeoLKernel/drivers/staging/dream/qdsp5/audio_in.c:			wake_up(&audio->wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_mp3.c:		wake_up(&audio->write_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_mp3.c:		wake_up(&audio->read_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_mp3.c:	wake_up(&audio->read_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_mp3.c:		  wake_up(&audio->write_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_mp3.c:	wake_up(&audio->write_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_mp3.c:	wake_up(&audio->read_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_out.c:#include <linux/wakelock.h>
NeoLKernel/drivers/staging/dream/qdsp5/audio_out.c:	struct wake_lock wakelock;
NeoLKernel/drivers/staging/dream/qdsp5/audio_out.c:	struct wake_lock idlelock;
NeoLKernel/drivers/staging/dream/qdsp5/audio_out.c:	wake_lock(&audio->wakelock);
NeoLKernel/drivers/staging/dream/qdsp5/audio_out.c:	wake_lock(&audio->idlelock);
NeoLKernel/drivers/staging/dream/qdsp5/audio_out.c:	wake_unlock(&audio->wakelock);
NeoLKernel/drivers/staging/dream/qdsp5/audio_out.c:	wake_unlock(&audio->idlelock);
NeoLKernel/drivers/staging/dream/qdsp5/audio_out.c:		wake_up(&audio->wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_out.c:			wake_up(&audio->wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_out.c:			/* Make sure we're stopped and we wake any threads
NeoLKernel/drivers/staging/dream/qdsp5/audio_out.c:			wake_up(&audio->wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_out.c:	wake_lock_init(&the_audio.wakelock, WAKE_LOCK_SUSPEND, "audio_pcm");
NeoLKernel/drivers/staging/dream/qdsp5/audio_out.c:	wake_lock_init(&the_audio.idlelock, WAKE_LOCK_IDLE, "audio_pcm_idle");
NeoLKernel/drivers/staging/dream/qdsp5/audio_qcelp.c:		wake_up(&audio->write_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_qcelp.c:		wake_up(&audio->read_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_qcelp.c:	wake_up(&audio->read_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_qcelp.c:			wake_up(&audio->write_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_qcelp.c:			/* Make sure we're stopped and we wake any threads
NeoLKernel/drivers/staging/dream/qdsp5/audio_qcelp.c:			wake_up(&audio->write_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audio_qcelp.c:			wake_up(&audio->read_wait);
NeoLKernel/drivers/staging/dream/qdsp5/audmgr.c:		wake_up(&am->wait);
NeoLKernel/drivers/staging/dream/qdsp5/audmgr.c:		wake_up(&am->wait);
NeoLKernel/drivers/staging/dream/qdsp5/audmgr.c:		wake_up(&am->wait);
NeoLKernel/drivers/staging/dream/qdsp5/audmgr.c:	wake_up(&am->wait);
NeoLKernel/drivers/staging/dream/smd/smd.c:			int_info->aArm_wakeup_reason);
NeoLKernel/drivers/staging/dream/smd/smd.c:	r = enable_irq_wake(INT_A9_M2A_0);
NeoLKernel/drivers/staging/dream/smd/smd.c:		pr_err("smd_core_init: enable_irq_wake failed for A9_M2A_0\n");
NeoLKernel/drivers/staging/dream/smd/smd.c:	r = enable_irq_wake(INT_A9_M2A_5);
NeoLKernel/drivers/staging/dream/smd/smd.c:		pr_err("smd_core_init: enable_irq_wake failed for A9_M2A_5\n");
NeoLKernel/drivers/staging/dream/smd/smd_private.h:	uint32_t aArm_wakeup_reason;
NeoLKernel/drivers/staging/dream/smd/smd_qmi.c:#include <linux/wakelock.h>
NeoLKernel/drivers/staging/dream/smd/smd_qmi.c:	struct wake_lock wake_lock;
NeoLKernel/drivers/staging/dream/smd/smd_qmi.c:	wake_lock_init(&ctxt->wake_lock, WAKE_LOCK_SUSPEND, ctxt->misc.name);
NeoLKernel/drivers/staging/dream/smd/smd_qmi.c:	wake_up(&qmi_wait_queue);
NeoLKernel/drivers/staging/dream/smd/smd_qmi.c:			wake_lock_timeout(&ctxt->wake_lock, HZ / 2);
NeoLKernel/drivers/staging/dream/smd/smd_qmi.c:		wake_up(&qmi_wait_queue);
NeoLKernel/drivers/staging/dream/smd/smd_qmi.c:		wake_up(&qmi_wait_queue);
NeoLKernel/drivers/staging/dream/smd/smd_rpcrouter.c:#include <linux/wakelock.h>
NeoLKernel/drivers/staging/dream/smd/smd_rpcrouter.c:static struct wake_lock rpcrouter_wake_lock;
NeoLKernel/drivers/staging/dream/smd/smd_rpcrouter.c:	wake_lock_init(&ept->read_q_wake_lock, WAKE_LOCK_SUSPEND, "rpc_read");
NeoLKernel/drivers/staging/dream/smd/smd_rpcrouter.c:	wake_lock_destroy(&ept->read_q_wake_lock);
NeoLKernel/drivers/staging/dream/smd/smd_rpcrouter.c:		wake_up(&r_ept->quota_wait);
NeoLKernel/drivers/staging/dream/smd/smd_rpcrouter.c:			wake_up(&newserver_wait);
NeoLKernel/drivers/staging/dream/smd/smd_rpcrouter.c:		wake_lock(&rpcrouter_wake_lock);
NeoLKernel/drivers/staging/dream/smd/smd_rpcrouter.c:	wake_up(&smd_wait);
NeoLKernel/drivers/staging/dream/smd/smd_rpcrouter.c:		wake_unlock(&rpcrouter_wake_lock);
NeoLKernel/drivers/staging/dream/smd/smd_rpcrouter.c:	wake_lock(&ept->read_q_wake_lock);
NeoLKernel/drivers/staging/dream/smd/smd_rpcrouter.c:	wake_up(&ept->wait_q);
NeoLKernel/drivers/staging/dream/smd/smd_rpcrouter.c:	wake_unlock(&rpcrouter_wake_lock);
NeoLKernel/drivers/staging/dream/smd/smd_rpcrouter.c:		wake_unlock(&ept->read_q_wake_lock);
NeoLKernel/drivers/staging/dream/smd/smd_rpcrouter.c:	wake_lock_init(&rpcrouter_wake_lock, WAKE_LOCK_SUSPEND, "SMD_RPCCALL");
NeoLKernel/drivers/staging/dream/smd/smd_rpcrouter.h:#include <linux/wakelock.h>
NeoLKernel/drivers/staging/dream/smd/smd_rpcrouter.h:	struct wake_lock read_q_wake_lock;
NeoLKernel/drivers/staging/dream/smd/smd_rpcrouter_servers.c:#include <linux/wakelock.h>
NeoLKernel/drivers/staging/dream/smd/smd_rpcrouter_servers.c:static struct wake_lock rpc_servers_wake_lock;
NeoLKernel/drivers/staging/dream/smd/smd_rpcrouter_servers.c:		wake_unlock(&rpc_servers_wake_lock);
NeoLKernel/drivers/staging/dream/smd/smd_rpcrouter_servers.c:		wake_lock(&rpc_servers_wake_lock);
NeoLKernel/drivers/staging/dream/smd/smd_rpcrouter_servers.c:	wake_lock_init(&rpc_servers_wake_lock, WAKE_LOCK_SUSPEND, "rpc_server");
NeoLKernel/drivers/staging/dream/smd/smd_tty.c:#include <linux/wakelock.h>
NeoLKernel/drivers/staging/dream/smd/smd_tty.c:	struct wake_lock wake_lock;
NeoLKernel/drivers/staging/dream/smd/smd_tty.c:		wake_lock_timeout(&info->wake_lock, HZ / 2);
NeoLKernel/drivers/staging/dream/smd/smd_tty.c:	tty_wakeup(tty);
NeoLKernel/drivers/staging/dream/smd/smd_tty.c:	wake_lock_init(&info->wake_lock, WAKE_LOCK_SUSPEND, name);
NeoLKernel/drivers/staging/dream/smd/smd_tty.c:		wake_lock_destroy(&info->wake_lock);
NeoLKernel/drivers/staging/dst/dcore.c:	wake_up(&st->thread_wait);
NeoLKernel/drivers/staging/dst/dcore.c: * why there is a wakeup if reference counter is not equal to zero.
NeoLKernel/drivers/staging/dst/dcore.c:		wake_up(&n->wait);
NeoLKernel/drivers/staging/dst/export.c: * and wake up processing thread, which gets completed request and
NeoLKernel/drivers/staging/dst/export.c:			wake_up(&st->thread_wait);
NeoLKernel/drivers/staging/dst/export.c:	wake_up(&st->thread_wait);
NeoLKernel/drivers/staging/dst/state.c:static int dst_queue_wake(wait_queue_t *wait, unsigned mode, int sync, void *key)
NeoLKernel/drivers/staging/dst/state.c:	wake_up(&st->thread_wait);
NeoLKernel/drivers/staging/dst/state.c:	init_waitqueue_func_entry(&st->wait, dst_queue_wake);
NeoLKernel/drivers/staging/dst/state.c:	wake_up(&st->thread_wait);
NeoLKernel/drivers/staging/dst/thread_pool.c:		wake_up(&p->wait);
NeoLKernel/drivers/staging/dst/thread_pool.c:				wake_up(&w->wait);
NeoLKernel/drivers/staging/et131x/et1310_pm.c: *          -- wake on phy_interrupt; Perform software reset JAGCore,
NeoLKernel/drivers/staging/et131x/et1310_tx.c:	 * timer to wake us up if this packet isn't followed by N more.
NeoLKernel/drivers/staging/et131x/et1310_tx.c:		netif_wake_queue(etdev->netdev);
NeoLKernel/drivers/staging/et131x/et131x_isr.c:			 * This is a secondary interrupt for wake on LAN.
NeoLKernel/drivers/staging/et131x/et131x_netdev.c:	netif_wake_queue(netdev);
NeoLKernel/drivers/staging/et131x/et131x_netdev.c:	netif_wake_queue(netdev);
NeoLKernel/drivers/staging/frontier/alphatrack.c:	wake_up_interruptible(&dev->read_wait);
NeoLKernel/drivers/staging/frontier/alphatrack.c:	wake_up_interruptible(&dev->write_wait);
NeoLKernel/drivers/staging/frontier/tranzport.c:	wake_up_interruptible(&dev->read_wait);
NeoLKernel/drivers/staging/frontier/tranzport.c:	wake_up_interruptible(&dev->write_wait);
NeoLKernel/drivers/staging/go7007/go7007-driver.c: * Send the boot firmware to the encoder, which just wakes it up and lets
NeoLKernel/drivers/staging/go7007/go7007-driver.c:		wake_up_interruptible(&go->frame_waitq);
NeoLKernel/drivers/staging/go7007/go7007-usb.c:			wake_up(&go->interrupt_waitq);
NeoLKernel/drivers/staging/go7007/go7007-usb.c:	wake_up(&go->interrupt_waitq);
NeoLKernel/drivers/staging/go7007/go7007-usb.c:		wake_up_interruptible(&go->frame_waitq);
NeoLKernel/drivers/staging/hv/osd.c:	wake_up_interruptible(&waitEvent->event);
NeoLKernel/drivers/staging/hv/blkvsc_drv.c:	wake_up_interruptible(&blkvsc_req->wevent);
NeoLKernel/drivers/staging/hv/netvsc_drv.c:			netif_wake_queue(net);
NeoLKernel/drivers/staging/hv/netvsc_drv.c:		netif_wake_queue(net);
NeoLKernel/drivers/staging/iio/industrialio-core.c:		wake_up_interruptible(&ev_int->wait);
NeoLKernel/drivers/staging/line6/dumprequest.c:	wake_up_interruptible(&l6dr->wait);
NeoLKernel/drivers/staging/line6/midi.c:		wake_up_interruptible(&line6->line6midi->send_wait);
NeoLKernel/drivers/staging/line6/pod.c:						wake_up_interruptible(&pod->x.wait); \
NeoLKernel/drivers/staging/line6/pod.c:				wake_up_interruptible(&pod->clipping.wait);
NeoLKernel/drivers/staging/mimio/mimio.c:	wake_up(&mimio->waitq);
NeoLKernel/drivers/staging/otus/80211core/cinit.c:        /*Sometimes we wake up to tx/rx but AP still think we are sleeping, so still need to set this bit*/
NeoLKernel/drivers/staging/otus/80211core/cmmap.c:    u8_t uapsdStaAwake = 0;
NeoLKernel/drivers/staging/otus/80211core/cmmap.c:                    uapsdStaAwake = 1;
NeoLKernel/drivers/staging/otus/80211core/cmmap.c:    if (uapsdStaAwake == 1)
NeoLKernel/drivers/staging/otus/80211core/cpsmgr.c:                                //zm_debug_msg0("wake up and send PS-Poll\n");
NeoLKernel/drivers/staging/otus/80211core/cpsmgr.c:                                zm_debug_msg0("wake up and send null data\n");
NeoLKernel/drivers/staging/otus/80211core/struct.h:    u8_t                    tempWakeUp; /*enable when wake up but still in ps mode */
NeoLKernel/drivers/staging/otus/hal/hpani.h:#define AR_PHY_RX_DELAY_DELAY   0x00003FFF  /* delay from wakeup to rx ena */
NeoLKernel/drivers/staging/otus/hal/hpmain.c:        reg_write(0x982C, 0x0000a000); //wake up ADDAC
NeoLKernel/drivers/staging/otus/ioctl.c:*			// wakeup
NeoLKernel/drivers/staging/poch/poch.c:	wake_up_interruptible(&channel->wq);
NeoLKernel/drivers/staging/pohmelfs/crypto.c:	wake_up(&psb->wait);
NeoLKernel/drivers/staging/pohmelfs/crypto.c:	wake_up(&psb->wait);
NeoLKernel/drivers/staging/pohmelfs/crypto.c:			wake_up(&t->wait);
NeoLKernel/drivers/staging/pohmelfs/dir.c:	wake_up(&psb->wait);
NeoLKernel/drivers/staging/pohmelfs/dir.c:	dprintk("%s: awake dir: %llu, ret: %ld, err: %d.\n", __func__, pi->ino, ret, pi->error);
NeoLKernel/drivers/staging/pohmelfs/net.c: * and caller will be awakened.
NeoLKernel/drivers/staging/pohmelfs/net.c:static int netfs_queue_wake(wait_queue_t *wait, unsigned mode, int sync, void *key)
NeoLKernel/drivers/staging/pohmelfs/net.c:	wake_up(&st->thread_wait);
NeoLKernel/drivers/staging/pohmelfs/net.c:	init_waitqueue_func_entry(&st->wait, netfs_queue_wake);
NeoLKernel/drivers/staging/pohmelfs/net.c: * data and wakeup listener, who will copy it to userspace.
NeoLKernel/drivers/staging/pohmelfs/net.c:	wake_up(&st->psb->wait);
NeoLKernel/drivers/staging/pohmelfs/net.c:	wake_up(&st->psb->wait);
NeoLKernel/drivers/staging/pohmelfs/net.c: * Readdir response from server. If special field is set, we wakeup
NeoLKernel/drivers/staging/pohmelfs/net.c:		wake_up(&st->psb->wait);
NeoLKernel/drivers/staging/pohmelfs/net.c:	wake_up(&st->psb->wait);
NeoLKernel/drivers/staging/pohmelfs/net.c:	wake_up(&st->psb->wait);
NeoLKernel/drivers/staging/pohmelfs/net.c:	wake_up(&st->psb->wait);
NeoLKernel/drivers/staging/pohmelfs/net.c:	wake_up(&st->psb->wait);
NeoLKernel/drivers/staging/pohmelfs/net.c:	wake_up(&st->psb->wait);
NeoLKernel/drivers/staging/pohmelfs/net.c:	wake_up(&st->psb->wait);
NeoLKernel/drivers/staging/pohmelfs/net.c:		wake_up(&psb->wait);
NeoLKernel/drivers/staging/pohmelfs/net.c:	wake_up(&psb->wait);
NeoLKernel/drivers/staging/pohmelfs/net.c:		wake_up(&psb->wait);
NeoLKernel/drivers/staging/quatech_usb2/quatech_usb2.c:	wake_up_interruptible(&port_extra->wait);
NeoLKernel/drivers/staging/quatech_usb2/quatech_usb2.c:	/* this wakes up the otherwise indefinitely waiting code for
NeoLKernel/drivers/staging/rt2860/2860_main_dev.c:	retval = pci_enable_wake(pci_dev, pci_choose_state(pci_dev, state), 1);
NeoLKernel/drivers/staging/rt2860/2860_main_dev.c:			netif_wake_queue(net_dev);
NeoLKernel/drivers/staging/rt2860/2860_main_dev.c:    // wake up and enable device
NeoLKernel/drivers/staging/rt2860/2860_main_dev.c:	// We need to check it before handle the INT_SOURCE_CSR, ASIC must be wake up.
NeoLKernel/drivers/staging/rt2860/2860_main_dev.c:		RTMPHandleTwakeupInterrupt(pAd);
NeoLKernel/drivers/staging/rt2860/common/cmm_data.c:	// outgoing frame always wakeup PHY to prevent frame lost
NeoLKernel/drivers/staging/rt2860/common/cmm_data.c:	// outgoing frame always wakeup PHY to prevent frame lost
NeoLKernel/drivers/staging/rt2860/common/cmm_data_2860.c:		// 1. Set auto wake up timer.
NeoLKernel/drivers/staging/rt2860/common/cmm_data_2860.c:		This routine sends command to firmware and turn our chip to wake up mode from power save mode.
NeoLKernel/drivers/staging/rt2860/common/cmm_data_2860.c:		Level = other value : normal wake up function.
NeoLKernel/drivers/staging/rt2860/common/cmm_data_2860.c:	// 2. Send wake up command.
NeoLKernel/drivers/staging/rt2860/common/cmm_data_2860.c:		// If this is called from Halt. ALWAYS force wakeup!!!
NeoLKernel/drivers/staging/rt2860/common/cmm_data_2860.c:		// 2. Send wake up command.
NeoLKernel/drivers/staging/rt2860/common/cmm_sync.c:		// BBP and RF are not accessible in PS mode, we has to wake them up first
NeoLKernel/drivers/staging/rt2860/common/mlme.c:		put PHY to sleep here, and set next wakeup timer. PHY doesn't not wakeup
NeoLKernel/drivers/staging/rt2860/common/mlme.c:		automatically. Instead, MCU will issue a TwakeUpInterrupt to host after
NeoLKernel/drivers/staging/rt2860/common/mlme.c:		the wakeup timer timeout. Driver has to issue a separate command to wake
NeoLKernel/drivers/staging/rt2860/common/mlme.c:		AsicForceWakeup() is used whenever manual wakeup is required
NeoLKernel/drivers/staging/rt2860/common/mlme.c:		AsicForceWakeup() is used whenever Twakeup timer (set via AsicSleepThenAutoWakeup)
NeoLKernel/drivers/staging/rt2860/common/mlme.c:	//			  that NIC will never wakes up because TSF stops and no more
NeoLKernel/drivers/staging/rt2860/common/rtmp_init.c:	// Before program BBP, we need to wait BBP/RF get wake up.
NeoLKernel/drivers/staging/rt2860/common/rtmp_init.c:		// This patch is for driver wake up from standby mode, system will do scan right away.
NeoLKernel/drivers/staging/rt2860/rt28xx.h:		UINT32		EnableAutoWakeup:1;	// 0:sleep, 1:awake
NeoLKernel/drivers/staging/rt2860/rtmp.h:void RTMPHandleTwakeupInterrupt(
NeoLKernel/drivers/staging/rt2860/rtmp_def.h:#define FROM_TX				4	// Force wake up from Tx packet.
NeoLKernel/drivers/staging/rt2860/rt_main_dev.c:	netif_wake_queue(net_dev);
NeoLKernel/drivers/staging/rt2860/rt_main_dev.c:	DECLARE_WAIT_QUEUE_HEAD_ONSTACK(unlink_wakeup);
NeoLKernel/drivers/staging/rt2860/rt_main_dev.c:		// If dirver doesn't wake up firmware here,
NeoLKernel/drivers/staging/rt2860/rt_main_dev.c:	add_wait_queue (&unlink_wakeup, &wait);
NeoLKernel/drivers/staging/rt2860/rt_main_dev.c:	pAd->wait = &unlink_wakeup;
NeoLKernel/drivers/staging/rt2860/rt_main_dev.c:	remove_wait_queue (&unlink_wakeup, &wait);
NeoLKernel/drivers/staging/rt2860/sta/connect.c:	// BBP and RF are not accessible in PS mode, we has to wake them up first
NeoLKernel/drivers/staging/rt2860/sta/rtmp_data.c:VOID	RTMPHandleTwakeupInterrupt(
NeoLKernel/drivers/staging/rt2860/sta/rtmp_data.c:	If no frame need to send, go to sleep, else, still wake up.
NeoLKernel/drivers/staging/rt2860/sta/rtmp_data.c:	//		outgoing frame always wakeup PHY to prevent frame lost and
NeoLKernel/drivers/staging/rt2870/2870_main_dev.c:	netif_wake_queue(net_dev);
NeoLKernel/drivers/staging/rt2870/2870_main_dev.c:			//wake_up(&timerWaitQ);
NeoLKernel/drivers/staging/rt3090/common/cmm_asic.c:		put PHY to sleep here, and set next wakeup timer. PHY doesn't not wakeup
NeoLKernel/drivers/staging/rt3090/common/cmm_asic.c:		automatically. Instead, MCU will issue a TwakeUpInterrupt to host after
NeoLKernel/drivers/staging/rt3090/common/cmm_asic.c:		the wakeup timer timeout. Driver has to issue a separate command to wake
NeoLKernel/drivers/staging/rt3090/common/cmm_asic.c:		AsicForceWakeup() is used whenever manual wakeup is required
NeoLKernel/drivers/staging/rt3090/common/cmm_asic.c:		AsicForceWakeup() is used whenever Twakeup timer (set via AsicSleepThenAutoWakeup)
NeoLKernel/drivers/staging/rt3090/common/cmm_asic.c:	//			  that NIC will never wakes up because TSF stops and no more
NeoLKernel/drivers/staging/rt3090/common/cmm_data.c:		// outgoing frame always wakeup PHY to prevent frame lost
NeoLKernel/drivers/staging/rt3090/common/cmm_data_pci.c:		// outgoing frame always wakeup PHY to prevent frame lost
NeoLKernel/drivers/staging/rt3090/common/cmm_mac_pci.c:	// For rt30xx power solution 3, Use software timer to wake up in psm. So call
NeoLKernel/drivers/staging/rt3090/common/cmm_mac_pci.c:	// AsicForceWakeup here instead of handling twakeup interrupt.
NeoLKernel/drivers/staging/rt3090/common/cmm_mac_pci.c:		// 2. Send wake up command.
NeoLKernel/drivers/staging/rt3090/common/cmm_mac_pci.c:		This routine sends command to firmware and turn our chip to wake up mode from power save mode.
NeoLKernel/drivers/staging/rt3090/common/cmm_mac_pci.c:		Level = other value : normal wake up function.
NeoLKernel/drivers/staging/rt3090/common/cmm_mac_pci.c:	// 2. Send wake up command.
NeoLKernel/drivers/staging/rt3090/common/cmm_mac_pci.c:		// 1. Set auto wake up timer.
NeoLKernel/drivers/staging/rt3090/common/cmm_sync.c:		// BBP and RF are not accessible in PS mode, we has to wake them up first
NeoLKernel/drivers/staging/rt3090/common/rtmp_init.c:	// Before program BBP, we need to wait BBP/RF get wake up.
NeoLKernel/drivers/staging/rt3090/common/rtmp_init.c:		// This patch is for driver wake up from standby mode, system will do scan right away.
NeoLKernel/drivers/staging/rt3090/common/rtmp_init.c:	// If dirver doesn't wake up firmware here,
NeoLKernel/drivers/staging/rt3090/pci_main_dev.c:	retval = pci_enable_wake(pci_dev, pci_choose_state(pci_dev, state), 1);
NeoLKernel/drivers/staging/rt3090/pci_main_dev.c:			netif_wake_queue(net_dev);
NeoLKernel/drivers/staging/rt3090/pci_main_dev.c:	// wake up and enable device
NeoLKernel/drivers/staging/rt3090/rtmp.h:void RTMPHandleTwakeupInterrupt(
NeoLKernel/drivers/staging/rt3090/rtmp_mac.h:		UINT32		EnableAutoWakeup:1;	// 0:sleep, 1:awake
NeoLKernel/drivers/staging/rt3090/rtmp_mac.h:		UINT32		EnableAutoWakeup:1;	// 0:sleep, 1:awake
NeoLKernel/drivers/staging/rt3090/rt_linux.h:	        wake_up(&(_pTask)->kthread_q); \
NeoLKernel/drivers/staging/rt3090/rt_linux.h:#define RTMP_OS_NETDEV_WAKE_QUEUE(_pNetDev)	netif_wake_queue((_pNetDev))
NeoLKernel/drivers/staging/rt3090/rt_main_dev.c:	netif_wake_queue(net_dev);
NeoLKernel/drivers/staging/rt3090/rt_main_dev.c:		// If dirver doesn't wake up firmware here,
NeoLKernel/drivers/staging/rt3090/rt_pci_rbus.c:	// We need to check it before handle the INT_SOURCE_CSR, ASIC must be wake up.
NeoLKernel/drivers/staging/rt3090/rt_pci_rbus.c:			RTMPHandleTwakeupInterrupt(pAd);
NeoLKernel/drivers/staging/rt3090/sta/rtmp_data.c:VOID	RTMPHandleTwakeupInterrupt(
NeoLKernel/drivers/staging/rt3090/sta/rtmp_data.c:	//		outgoing frame always wakeup PHY to prevent frame lost and
NeoLKernel/drivers/staging/rt3090/sta/sync.c:							The WMM STA shall remain awake until it receives a
NeoLKernel/drivers/staging/rtl8187se/ieee80211/ieee80211.h:	unsigned int swtxawake;
NeoLKernel/drivers/staging/rtl8187se/ieee80211/ieee80211.h://	struct work_struct hw_wakeup_wq;
NeoLKernel/drivers/staging/rtl8187se/ieee80211/ieee80211.h:	struct delayed_work hw_wakeup_wq;
NeoLKernel/drivers/staging/rtl8187se/ieee80211/ieee80211.h:	void (*sta_wake_up) (struct net_device *dev);
NeoLKernel/drivers/staging/rtl8187se/ieee80211/ieee80211.h: * wake/stop for the driver, taking care of 802.11
NeoLKernel/drivers/staging/rtl8187se/ieee80211/ieee80211.h:extern void ieee80211_rtl_wake_queue(struct ieee80211_device *ieee);
NeoLKernel/drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c:void ieee80211_sta_wakeup(struct ieee80211_device *ieee, short nl);
NeoLKernel/drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c:	ieee80211_sta_wakeup(ieee,0);
NeoLKernel/drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c:		ieee80211_sta_wakeup(ieee, 1);
NeoLKernel/drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c://	printk("===>%s,%d[2 wake, 1 sleep, 0 do nothing], ieee->sta_sleep = %d\n",__func__, sleep,ieee->sta_sleep);
NeoLKernel/drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c:	/* 2 wake, 1 sleep, 0 do nothing */
NeoLKernel/drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c:	//	printk("send wakeup packet\n");
NeoLKernel/drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c:		ieee80211_sta_wakeup(ieee,1);
NeoLKernel/drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c:void ieee80211_sta_wakeup(struct ieee80211_device *ieee, short nl)
NeoLKernel/drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c:		ieee->sta_wake_up(ieee->dev);
NeoLKernel/drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c:		 * has not RXed so we can't assume the AP believe us awake
NeoLKernel/drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c: * Instead of using netif_[stop/wake]_queue the driver
NeoLKernel/drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c: * to the driver later, when it wakes the queue.
NeoLKernel/drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c:	ieee80211_sta_wakeup(ieee,0);
NeoLKernel/drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c:void ieee80211_rtl_wake_queue(struct ieee80211_device *ieee)
NeoLKernel/drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c:			//printk(KERN_ALERT "ieee80211_wake_queue \n");
NeoLKernel/drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c:		ieee->softmac_stats.swtxawake++;
NeoLKernel/drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c:		netif_wake_queue(ieee->dev);
NeoLKernel/drivers/staging/rtl8187se/ieee80211/ieee80211_softmac_wx.c:		(!ieee->sta_wake_up) ||
NeoLKernel/drivers/staging/rtl8187se/r8180.h:	void (*rf_wakeup)(struct net_device *dev);
NeoLKernel/drivers/staging/rtl8187se/r8180.h:	bool	bApBufOurFrame;// TRUE if AP buffer our unicast data , we will keep eAwake untill receive data or timeout.
NeoLKernel/drivers/staging/rtl8187se/r8180_core.c:	* the ieee stack, or from the try_wake_queue (again trought
NeoLKernel/drivers/staging/rtl8187se/r8180_core.c:void rtl8180_hw_wakeup(struct net_device *dev)
NeoLKernel/drivers/staging/rtl8187se/r8180_core.c:	if (priv->rf_wakeup)
NeoLKernel/drivers/staging/rtl8187se/r8180_core.c:		priv->rf_wakeup(dev);
NeoLKernel/drivers/staging/rtl8187se/r8180_core.c:	 * short then give up and remain awake
NeoLKernel/drivers/staging/rtl8187se/r8180_core.c:		queue_delayed_work(priv->ieee80211->wq, &priv->ieee80211->hw_wakeup_wq, tmp); //as tl may be less than rb
NeoLKernel/drivers/staging/rtl8187se/r8180_core.c:void rtl8180_hw_wakeup_wq(struct work_struct *work);
NeoLKernel/drivers/staging/rtl8187se/r8180_core.c:	priv->ieee80211->sta_wake_up = rtl8180_hw_wakeup;
NeoLKernel/drivers/staging/rtl8187se/r8180_core.c:	INIT_DELAYED_WORK(&priv->ieee80211->hw_wakeup_wq,(void*) rtl8180_hw_wakeup_wq);
NeoLKernel/drivers/staging/rtl8187se/r8180_core.c:	priv->rf_wakeup = rtl8225z4_rf_wakeup;
NeoLKernel/drivers/staging/rtl8187se/r8180_core.c:void rtl8180_hw_wakeup_wq (struct work_struct *work)
NeoLKernel/drivers/staging/rtl8187se/r8180_core.c:	struct ieee80211_device *ieee = container_of(dwork,struct ieee80211_device,hw_wakeup_wq);
NeoLKernel/drivers/staging/rtl8187se/r8180_core.c:	rtl8180_hw_wakeup(dev);
NeoLKernel/drivers/staging/rtl8187se/r8180_core.c:	cancel_delayed_work(&priv->ieee80211->hw_wakeup_wq);
NeoLKernel/drivers/staging/rtl8187se/r8180_core.c:	cancel_delayed_work(&priv->ieee80211->hw_wakeup_wq);
NeoLKernel/drivers/staging/rtl8187se/r8180_core.c:void rtl8180_try_wake_queue(struct net_device *dev, int pri)
NeoLKernel/drivers/staging/rtl8187se/r8180_core.c:		ieee80211_rtl_wake_queue(priv->ieee80211);
NeoLKernel/drivers/staging/rtl8187se/r8180_core.c:		rtl8180_try_wake_queue(dev, BE_PRIORITY);
NeoLKernel/drivers/staging/rtl8187se/r8180_core.c:		rtl8180_try_wake_queue(dev, BE_PRIORITY);
NeoLKernel/drivers/staging/rtl8187se/r8180_core.c:		rtl8180_try_wake_queue(dev, NORM_PRIORITY);
NeoLKernel/drivers/staging/rtl8187se/r8180_core.c:		rtl8180_try_wake_queue(dev, LOW_PRIORITY);
NeoLKernel/drivers/staging/rtl8187se/r8180_core.c:		rtl8180_try_wake_queue(dev, LOW_PRIORITY);
NeoLKernel/drivers/staging/rtl8187se/r8180_core.c:		rtl8180_try_wake_queue(dev, BE_PRIORITY);
NeoLKernel/drivers/staging/rtl8187se/r8180_core.c:		rtl8180_try_wake_queue(dev, BE_PRIORITY);
NeoLKernel/drivers/staging/rtl8187se/r8180_dm.c:	u32 			AwakePeriodIn2Sec=0;
NeoLKernel/drivers/staging/rtl8187se/r8180_dm.c:	AwakePeriodIn2Sec = (2000-priv ->DozePeriodInPast2Sec);
NeoLKernel/drivers/staging/rtl8187se/r8180_dm.c:	//printk("&&& DozePeriod=%d AwakePeriod=%d\n", priv->DozePeriodInPast2Sec, AwakePeriodIn2Sec);
NeoLKernel/drivers/staging/rtl8187se/r8180_dm.c:	if(AwakePeriodIn2Sec)
NeoLKernel/drivers/staging/rtl8187se/r8180_dm.c:		//RT_TRACE(COMP_DIG, DBG_TRACE, ("DIG: AwakePeriodIn2Sec(%d) - FATh(0x%X , 0x%X) ->",AwakePeriodIn2Sec, OfdmFA1, OfdmFA2));
NeoLKernel/drivers/staging/rtl8187se/r8180_dm.c:		OfdmFA1 =  (u16)((OfdmFA1*AwakePeriodIn2Sec)  / 2000) ;
NeoLKernel/drivers/staging/rtl8187se/r8180_dm.c:		OfdmFA2 =  (u16)((OfdmFA2*AwakePeriodIn2Sec)  / 2000) ;
NeoLKernel/drivers/staging/rtl8187se/r8180_dm.c:		;//RT_TRACE(COMP_DIG, DBG_WARNING, ("ERROR!!  AwakePeriodIn2Sec should not be ZERO!!\n"));
NeoLKernel/drivers/staging/rtl8187se/r8180_rtl8225.h:void rtl8225z4_rf_wakeup(struct net_device *dev);
NeoLKernel/drivers/staging/rtl8187se/r8180_rtl8225z2.c:void rtl8225z4_rf_wakeup(struct net_device *dev)
NeoLKernel/drivers/staging/rtl8187se/r8180_wx.c:	priv->rf_wakeup(dev);
NeoLKernel/drivers/staging/rtl8187se/r8185b_init.c:	// Schedule an workitem to wake up for ps mode, 070109, by rcnjko.
NeoLKernel/drivers/staging/rtl8187se/r8185b_init.c:	if(pMgntInfo->mPss != eAwake)
NeoLKernel/drivers/staging/rtl8187se/r8185b_init.c:		// PlatformScheduleWorkItem( &(pMgntInfo->AwakeWorkItem) );
NeoLKernel/drivers/staging/rtl8187se/r8185b_init.c:		PlatformSetTimer( Adapter, &(pMgntInfo->AwakeTimer), 0 );
NeoLKernel/drivers/staging/rtl8192e/ieee80211/ieee80211.h:#define ieee80211_wake_queue		ieee80211_wake_queue_rsl
NeoLKernel/drivers/staging/rtl8192e/ieee80211/ieee80211.h:	unsigned int swtxawake;
NeoLKernel/drivers/staging/rtl8192e/ieee80211/ieee80211.h:	 struct delayed_work hw_wakeup_wq;
NeoLKernel/drivers/staging/rtl8192e/ieee80211/ieee80211.h:	struct work_struct hw_wakeup_wq;
NeoLKernel/drivers/staging/rtl8192e/ieee80211/ieee80211.h:	void (*sta_wake_up) (struct net_device *dev);
NeoLKernel/drivers/staging/rtl8192e/ieee80211/ieee80211.h: * wake/stop for the driver, taking care of 802.11
NeoLKernel/drivers/staging/rtl8192e/ieee80211/ieee80211.h:extern void ieee80211_wake_queue(struct ieee80211_device *ieee);
NeoLKernel/drivers/staging/rtl8192e/ieee80211/ieee80211_softmac.c:void ieee80211_sta_wakeup(struct ieee80211_device *ieee, short nl);
NeoLKernel/drivers/staging/rtl8192e/ieee80211/ieee80211_softmac.c:	ieee80211_sta_wakeup(ieee,0);
NeoLKernel/drivers/staging/rtl8192e/ieee80211/ieee80211_softmac.c:		ieee80211_sta_wakeup(ieee, 1);
NeoLKernel/drivers/staging/rtl8192e/ieee80211/ieee80211_softmac.c:	/* 2 wake, 1 sleep, 0 do nothing */
NeoLKernel/drivers/staging/rtl8192e/ieee80211/ieee80211_softmac.c:		ieee80211_sta_wakeup(ieee,1);
NeoLKernel/drivers/staging/rtl8192e/ieee80211/ieee80211_softmac.c:void ieee80211_sta_wakeup(struct ieee80211_device *ieee, short nl)
NeoLKernel/drivers/staging/rtl8192e/ieee80211/ieee80211_softmac.c:		ieee->sta_wake_up(ieee->dev);
NeoLKernel/drivers/staging/rtl8192e/ieee80211/ieee80211_softmac.c:		 * has not RXed so we can't assume the AP believe us awake
NeoLKernel/drivers/staging/rtl8192e/ieee80211/ieee80211_softmac.c: * Instead of using netif_[stop/wake]_queue the driver
NeoLKernel/drivers/staging/rtl8192e/ieee80211/ieee80211_softmac.c: * to the driver later, when it wakes the queue.
NeoLKernel/drivers/staging/rtl8192e/ieee80211/ieee80211_softmac.c:	ieee80211_sta_wakeup(ieee,0);
NeoLKernel/drivers/staging/rtl8192e/ieee80211/ieee80211_softmac.c:void ieee80211_wake_queue(struct ieee80211_device *ieee)
NeoLKernel/drivers/staging/rtl8192e/ieee80211/ieee80211_softmac.c:		ieee->softmac_stats.swtxawake++;
NeoLKernel/drivers/staging/rtl8192e/ieee80211/ieee80211_softmac.c:		netif_wake_queue(ieee->dev);
NeoLKernel/drivers/staging/rtl8192e/ieee80211/ieee80211_softmac.c://EXPORT_SYMBOL(ieee80211_wake_queue);
NeoLKernel/drivers/staging/rtl8192e/ieee80211/ieee80211_softmac.c:EXPORT_SYMBOL_NOVERS(ieee80211_wake_queue);
NeoLKernel/drivers/staging/rtl8192e/ieee80211/ieee80211_softmac_wx.c:		(!ieee->sta_wake_up) ||
NeoLKernel/drivers/staging/rtl8192e/ieee80211.h:#define ieee80211_wake_queue		ieee80211_wake_queue_rsl
NeoLKernel/drivers/staging/rtl8192e/ieee80211.h:	unsigned int swtxawake;
NeoLKernel/drivers/staging/rtl8192e/ieee80211.h:	 struct delayed_work hw_wakeup_wq;
NeoLKernel/drivers/staging/rtl8192e/ieee80211.h:	void (*sta_wake_up) (struct net_device *dev);
NeoLKernel/drivers/staging/rtl8192e/ieee80211.h: * wake/stop for the driver, taking care of 802.11
NeoLKernel/drivers/staging/rtl8192e/ieee80211.h:extern void ieee80211_wake_queue(struct ieee80211_device *ieee);
NeoLKernel/drivers/staging/rtl8192e/r8190_rtl8256.c:	// Schedule an workitem to wake up for ps mode, 070109, by rcnjko.
NeoLKernel/drivers/staging/rtl8192e/r8190_rtl8256.c:	if(pMgntInfo->mPss != eAwake)
NeoLKernel/drivers/staging/rtl8192e/r8190_rtl8256.c:		// PlatformScheduleWorkItem( &(pMgntInfo->AwakeWorkItem) );
NeoLKernel/drivers/staging/rtl8192e/r8190_rtl8256.c:		PlatformSetTimer( Adapter, &(pMgntInfo->AwakeTimer), 0 );
NeoLKernel/drivers/staging/rtl8192e/r8192E.h:void rtl8192_hw_wakeup_wq (struct work_struct *work);
NeoLKernel/drivers/staging/rtl8192e/r8192E_core.c:void rtl8192_try_wake_queue(struct net_device *dev, int pri);
NeoLKernel/drivers/staging/rtl8192e/r8192E_core.c:static void rtl8192_hw_wakeup(struct net_device* dev)
NeoLKernel/drivers/staging/rtl8192e/r8192E_core.c:	RT_TRACE(COMP_POWER, "%s()============>come to wake up\n", __FUNCTION__);
NeoLKernel/drivers/staging/rtl8192e/r8192E_core.c:void rtl8192_hw_wakeup_wq (struct work_struct *work)
NeoLKernel/drivers/staging/rtl8192e/r8192E_core.c:	struct ieee80211_device *ieee = container_of(dwork,struct ieee80211_device,hw_wakeup_wq);
NeoLKernel/drivers/staging/rtl8192e/r8192E_core.c:	rtl8192_hw_wakeup(dev);
NeoLKernel/drivers/staging/rtl8192e/r8192E_core.c:	 * short then give up and remain awake
NeoLKernel/drivers/staging/rtl8192e/r8192E_core.c:		queue_delayed_work(priv->ieee80211->wq, &priv->ieee80211->hw_wakeup_wq, tmp); //as tl may be less than rb
NeoLKernel/drivers/staging/rtl8192e/r8192E_core.c:	priv->ieee80211->sta_wake_up = rtl8192_hw_wakeup;
NeoLKernel/drivers/staging/rtl8192e/r8192E_core.c:	INIT_DELAYED_WORK(&priv->ieee80211->hw_wakeup_wq,(void*) rtl8192_hw_wakeup_wq);
NeoLKernel/drivers/staging/rtl8192e/r8192E_core.c:		netif_wake_queue(dev);
NeoLKernel/drivers/staging/rtl8192e/r8192E_core.c:	cancel_delayed_work(&priv->ieee80211->hw_wakeup_wq);
NeoLKernel/drivers/staging/rtl8192e/r8192E_core.c:        //		rtl8180_hw_wakeup(dev);
NeoLKernel/drivers/staging/rtl8192e/r8192E_core.c:        rtl8192_try_wake_queue(dev, BK_QUEUE);
NeoLKernel/drivers/staging/rtl8192e/r8192E_core.c:        rtl8192_try_wake_queue(dev, BE_QUEUE);
NeoLKernel/drivers/staging/rtl8192e/r8192E_core.c:        rtl8192_try_wake_queue(dev, VI_QUEUE);
NeoLKernel/drivers/staging/rtl8192e/r8192E_core.c:        rtl8192_try_wake_queue(dev, VO_QUEUE);
NeoLKernel/drivers/staging/rtl8192e/r8192E_core.c:void rtl8192_try_wake_queue(struct net_device *dev, int pri)
NeoLKernel/drivers/staging/rtl8192e/r8192E_core.c:		ieee80211_wake_queue(priv->ieee80211);
NeoLKernel/drivers/staging/rtl8192e/r8192_pm.c:	pci_enable_wake(pdev, pci_choose_state(pdev,state),\
NeoLKernel/drivers/staging/rtl8192e/r8192_pm.c:	pci_enable_wake(pdev, PCI_D0, 0);
NeoLKernel/drivers/staging/rtl8192e/r8192_pm.c:int rtl8192E_enable_wake (struct pci_dev *dev, pm_message_t state, int enable)
NeoLKernel/drivers/staging/rtl8192e/r8192_pm.c:        printk(KERN_NOTICE "r8192E enable wake call (state %u, enable %d).\n",
NeoLKernel/drivers/staging/rtl8192e/r8192_pm.h:int rtl8192E_enable_wake (struct pci_dev *dev, pm_message_t state, int enable);
NeoLKernel/drivers/staging/rtl8192su/ieee80211/ieee80211.h:	unsigned int swtxawake;
NeoLKernel/drivers/staging/rtl8192su/ieee80211/ieee80211.h:	struct delayed_work hw_wakeup_wq;
NeoLKernel/drivers/staging/rtl8192su/ieee80211/ieee80211.h:	void (*sta_wake_up) (struct net_device *dev);
NeoLKernel/drivers/staging/rtl8192su/ieee80211/ieee80211.h: * wake/stop for the driver, taking care of 802.11
NeoLKernel/drivers/staging/rtl8192su/ieee80211/ieee80211.h:extern void ieee80211_wake_queue(struct ieee80211_device *ieee);
NeoLKernel/drivers/staging/rtl8192su/ieee80211/ieee80211_r8192s.h:	u8			RegMaxLPSAwakeIntvl;
NeoLKernel/drivers/staging/rtl8192su/ieee80211/ieee80211_r8192s.h:	u8			LPSAwakeIntvl;
NeoLKernel/drivers/staging/rtl8192su/ieee80211/ieee80211_softmac.c:void ieee80211_sta_wakeup(struct ieee80211_device *ieee, short nl);
NeoLKernel/drivers/staging/rtl8192su/ieee80211/ieee80211_softmac.c:	ieee80211_sta_wakeup(ieee,0);
NeoLKernel/drivers/staging/rtl8192su/ieee80211/ieee80211_softmac.c:		ieee80211_sta_wakeup(ieee, 1);
NeoLKernel/drivers/staging/rtl8192su/ieee80211/ieee80211_softmac.c:	/* 2 wake, 1 sleep, 0 do nothing */
NeoLKernel/drivers/staging/rtl8192su/ieee80211/ieee80211_softmac.c:		ieee80211_sta_wakeup(ieee,1);
NeoLKernel/drivers/staging/rtl8192su/ieee80211/ieee80211_softmac.c:void ieee80211_sta_wakeup(struct ieee80211_device *ieee, short nl)
NeoLKernel/drivers/staging/rtl8192su/ieee80211/ieee80211_softmac.c:		ieee->sta_wake_up(ieee->dev);
NeoLKernel/drivers/staging/rtl8192su/ieee80211/ieee80211_softmac.c:		 * has not RXed so we can't assume the AP believe us awake
NeoLKernel/drivers/staging/rtl8192su/ieee80211/ieee80211_softmac.c: * Instead of using netif_[stop/wake]_queue the driver
NeoLKernel/drivers/staging/rtl8192su/ieee80211/ieee80211_softmac.c: * to the driver later, when it wakes the queue.
NeoLKernel/drivers/staging/rtl8192su/ieee80211/ieee80211_softmac.c:	ieee80211_sta_wakeup(ieee,0);
NeoLKernel/drivers/staging/rtl8192su/ieee80211/ieee80211_softmac.c:void ieee80211_wake_queue(struct ieee80211_device *ieee)
NeoLKernel/drivers/staging/rtl8192su/ieee80211/ieee80211_softmac.c:		ieee->softmac_stats.swtxawake++;
NeoLKernel/drivers/staging/rtl8192su/ieee80211/ieee80211_softmac.c:		netif_wake_queue(ieee->dev);
NeoLKernel/drivers/staging/rtl8192su/ieee80211/ieee80211_softmac_wx.c:		(!ieee->sta_wake_up) ||
NeoLKernel/drivers/staging/rtl8192su/ieee80211/readme:- Optionally provide an alterantive mechanism for netif queue stop/wake,
NeoLKernel/drivers/staging/rtl8192su/ieee80211/readme:ieee80211_wake_queue             - this is similar to netif_wake_queue
NeoLKernel/drivers/staging/rtl8192su/r8192U_core.c:void rtl8192_try_wake_queue(struct net_device *dev, int pri);
NeoLKernel/drivers/staging/rtl8192su/r8192U_core.c:void rtl8192_hw_wakeup(struct net_device* dev)
NeoLKernel/drivers/staging/rtl8192su/r8192U_core.c:	RT_TRACE(COMP_POWER, "%s()============>come to wake up\n", __FUNCTION__);
NeoLKernel/drivers/staging/rtl8192su/r8192U_core.c:void rtl8192_hw_wakeup_wq (struct work_struct *work)
NeoLKernel/drivers/staging/rtl8192su/r8192U_core.c:	struct ieee80211_device *ieee = container_of(dwork,struct ieee80211_device,hw_wakeup_wq);
NeoLKernel/drivers/staging/rtl8192su/r8192U_core.c:	rtl8192_hw_wakeup(dev);
NeoLKernel/drivers/staging/rtl8192su/r8192U_core.c:	 * short then give up and remain awake
NeoLKernel/drivers/staging/rtl8192su/r8192U_core.c:		queue_delayed_work(priv->ieee80211->wq, &priv->ieee80211->hw_wakeup_wq, tmp); //as tl may be less than rb
NeoLKernel/drivers/staging/rtl8192su/r8192U_core.c:	priv->ieee80211->sta_wake_up = rtl8192_hw_wakeup;
NeoLKernel/drivers/staging/rtl8192su/r8192U_core.c:	INIT_DELAYED_WORK(&priv->ieee80211->hw_wakeup_wq,(void*) rtl8192_hw_wakeup_wq);
NeoLKernel/drivers/staging/rtl8192su/r8192U_core.c:		netif_wake_queue(dev);
NeoLKernel/drivers/staging/rtl8192su/r8192U_core.c:	cancel_delayed_work(&priv->ieee80211->hw_wakeup_wq);
NeoLKernel/drivers/staging/rtl8192su/r8192U_core.c:void rtl8192_try_wake_queue(struct net_device *dev, int pri)
NeoLKernel/drivers/staging/rtl8192su/r8192U_core.c:		ieee80211_wake_queue(priv->ieee80211);
NeoLKernel/drivers/staging/rtl8192su/r8192U_pm.c:int rtl8192U_enable_wake (struct pci_dev *dev, u32 state, int enable)
NeoLKernel/drivers/staging/rtl8192su/r8192U_pm.c:	printk(KERN_NOTICE "r8192U enable wake call (state %u, enable %d).\n",
NeoLKernel/drivers/staging/rtl8192su/r8192U_pm.h:int rtl8192U_enable_wake (struct pci_dev *dev, u32 state, int enable);
NeoLKernel/drivers/staging/sep/sep_driver.c:	wake_up(&sep_event);
NeoLKernel/drivers/staging/sep/sep_driver.c:			/* wake up the waiting process */
NeoLKernel/drivers/staging/sep/sep_driver.c:			wake_up(&sep_event);
NeoLKernel/drivers/staging/serqt_usb2/serqt_usb2.c:	wake_up_interruptible(&qt_port->wait);
NeoLKernel/drivers/staging/serqt_usb2/serqt_usb2.c:		tty_wakeup(tty);
NeoLKernel/drivers/staging/slicoss/slichw.h:struct inicpm_wakepattern {
NeoLKernel/drivers/staging/slicoss/slichw.h:	u32 wake_linkstatus;
NeoLKernel/drivers/staging/slicoss/slichw.h:	u32 wake_magicpacket;
NeoLKernel/drivers/staging/slicoss/slichw.h:	u32 wake_framepattern;
NeoLKernel/drivers/staging/slicoss/slichw.h:	struct inicpm_wakepattern wakepattern[SLIC_PM_MAXPATTERNS];
NeoLKernel/drivers/staging/slicoss/slichw.h:struct slicpm_wakeup_capabilities {
NeoLKernel/drivers/staging/slicoss/slichw.h:	enum slicpm_power_state min_magic_packet_wakeup;
NeoLKernel/drivers/staging/slicoss/slichw.h:	enum slicpm_power_state min_pattern_wakeup;
NeoLKernel/drivers/staging/slicoss/slichw.h:	enum slicpm_power_state min_link_change_wakeup;
NeoLKernel/drivers/staging/slicoss/slichw.h:	struct slicpm_wakeup_capabilities wakeup_capabilities;
NeoLKernel/drivers/staging/slicoss/slicoss.c:		netif_wake_queue(adapter->netdev);
NeoLKernel/drivers/staging/usbip/stub_tx.c:	/* wake up tx_thread */
NeoLKernel/drivers/staging/usbip/stub_tx.c:	wake_up(&sdev->tx_waitq);
NeoLKernel/drivers/staging/usbip/usbip_event.c:		usbip_dbg_eh("wakeup\n");
NeoLKernel/drivers/staging/usbip/usbip_event.c:	wake_up(&ud->eh_waitq);
NeoLKernel/drivers/staging/usbip/vhci_hcd.c:	wake_up(&vdev->waitq_tx);
NeoLKernel/drivers/staging/usbip/vhci_hcd.c:		wake_up(&vdev->waitq_tx);
NeoLKernel/drivers/staging/usbip/vhci_tx.c:		usbip_dbg_vhci_tx("pending urbs ?, now wake up\n");
NeoLKernel/drivers/staging/vme/bridges/vme_ca91cx42.c:	wake_up(&dma_queue);
NeoLKernel/drivers/staging/vme/bridges/vme_ca91cx42.c:	wake_up(&mbox_queue);
NeoLKernel/drivers/staging/vme/bridges/vme_ca91cx42.c:	wake_up(&iack_queue);
NeoLKernel/drivers/staging/vme/bridges/vme_tsi148.c:		wake_up(&dma_queue[0]);
NeoLKernel/drivers/staging/vme/bridges/vme_tsi148.c:		wake_up(&dma_queue[1]);
NeoLKernel/drivers/staging/vme/bridges/vme_tsi148.c:	wake_up(&iack_queue);
NeoLKernel/drivers/staging/vt6655/device_main.c:            netif_wake_queue(pDevice->dev);
NeoLKernel/drivers/staging/vt6655/device_main.c:    power_status = pci_enable_wake(pcid, 0, 0);
NeoLKernel/drivers/staging/vt6655/tether.h:#define TYPE_PKT_WOL_M_REQ  0x8033      // WOL waker request
NeoLKernel/drivers/staging/vt6655/tether.h:#define TYPE_PKT_WOL_M_REQ  0x3380      // WOL waker request
NeoLKernel/drivers/staging/vt6655/wcmd.c:                        netif_wake_queue(pDevice->dev);
NeoLKernel/drivers/staging/vt6655/wcmd.c:                        netif_wake_queue(pDevice->dev);
NeoLKernel/drivers/staging/vt6655/wcmd.c:                    netif_wake_queue(pDevice->dev);
NeoLKernel/drivers/staging/vt6655/wcmd.c:                    netif_wake_queue(pDevice->dev);
NeoLKernel/drivers/staging/vt6655/wmgr.c:                    netif_wake_queue(pDevice->dev);
NeoLKernel/drivers/staging/vt6655/power.c: *      PSbIsNextTBTTWakeUp - Decide if we need to wake up at next Beacon
NeoLKernel/drivers/staging/vt6655/power.c:        // check if in TIM wake period
NeoLKernel/drivers/staging/vt6655/power.c: * Check if Next TBTT must wake up
NeoLKernel/drivers/staging/vt6655/power.c:            // Turn on wake up to listen next beacon
NeoLKernel/drivers/staging/vt6656/bssdb.c:            netif_wake_queue(pDevice->dev);
NeoLKernel/drivers/staging/vt6656/power.c: *      PSbIsNextTBTTWakeUp - Decide if we need to wake up at next Beacon
NeoLKernel/drivers/staging/vt6656/power.c:        // check if in TIM wake period
NeoLKernel/drivers/staging/vt6656/power.c: * Check if Next TBTT must wake up
NeoLKernel/drivers/staging/vt6656/power.c:            // Turn on wake up to listen next beacon
NeoLKernel/drivers/staging/vt6656/tether.h:#define TYPE_PKT_WOL_M_REQ  0x8033      // WOL waker request
NeoLKernel/drivers/staging/vt6656/tether.h:#define TYPE_PKT_WOL_M_REQ  0x3380      // WOL waker request
NeoLKernel/drivers/staging/vt6656/usbpipe.c:            netif_wake_queue(pDevice->dev);
NeoLKernel/drivers/staging/vt6656/wcmd.c:                        netif_wake_queue(pDevice->dev);
NeoLKernel/drivers/staging/vt6656/wcmd.c:                        netif_wake_queue(pDevice->dev);
NeoLKernel/drivers/staging/vt6656/wcmd.c:                    netif_wake_queue(pDevice->dev);
NeoLKernel/drivers/staging/vt6656/wcmd.c:                    netif_wake_queue(pDevice->dev);
NeoLKernel/drivers/staging/vt6656/wmgr.c:                    netif_wake_queue(pDevice->dev);
NeoLKernel/drivers/staging/vt6656/main_usb.c:              netif_wake_queue(pDevice->dev);
NeoLKernel/drivers/staging/winbond/wbhal_f.h:void hal_set_power_save_mode(  struct hw_data * pHwData,  unsigned char power_save,  unsigned char wakeup,  unsigned char dtim );
NeoLKernel/drivers/staging/wlan-ng/hfa384x_usb.c:		netif_wake_queue(hw->wlandev->netdev);
NeoLKernel/drivers/staging/wlan-ng/hfa384x_usb.c:*	-ERESTARTSYS	Awakened on signal
NeoLKernel/drivers/staging/wlan-ng/hfa384x_usb.c:*	-ERESTARTSYS	Awakened on signal
NeoLKernel/drivers/staging/wlan-ng/p80211netdev.c:		netif_wake_queue(wlandev->netdev);
NeoLKernel/drivers/staging/wlan-ng/p80211netdev.c:*		-EintR	sleeping on cmd, awakened by signal, cmd cancelled.
NeoLKernel/drivers/staging/wlan-ng/p80211netdev.c:		netif_wake_queue(wlandev->netdev);
NeoLKernel/drivers/staging/wlan-ng/prism2sta.c:	/* Notify/wake the sleeping caller. */
NeoLKernel/drivers/staging/wlan-ng/prism2sta.c:	wake_up_interruptible(&hw->cmdq);
NeoLKernel/drivers/staging/wlan-ng/prism2sta.c:	netif_wake_queue(wlandev->netdev);
NeoLKernel/drivers/staging/wlan-ng/prism2usb.c:		 * is "wake up", so that's easy.
NeoLKernel/drivers/telephony/ixj.c:			wake_up_interruptible(&j->poll_q);	/* Wake any blocked selects */
NeoLKernel/drivers/telephony/ixj.c:			wake_up_interruptible(&j->read_q);	/* Wake any blocked readers */
NeoLKernel/drivers/telephony/ixj.c:			wake_up_interruptible(&j->poll_q);	/* Wake any blocked selects */
NeoLKernel/drivers/telephony/ixj.c:		wake_up_interruptible(&j->write_q);	/* Wake any blocked writers */
NeoLKernel/drivers/telephony/ixj.c:			wake_up_interruptible(&j->write_q);	/* Wake any blocked readers */
NeoLKernel/drivers/telephony/ixj.c:			wake_up_interruptible(&j->write_q);	/* Wake any blocked writers */
NeoLKernel/drivers/telephony/ixj.c:			wake_up_interruptible(&j->poll_q);	/* Wake any blocked selects */
NeoLKernel/drivers/telephony/ixj.c:			wake_up_interruptible(&j->write_q);	/* Wake any blocked writers */
NeoLKernel/drivers/telephony/ixj.c:			wake_up_interruptible(&j->poll_q);	/* Wake any blocked selects */
NeoLKernel/drivers/telephony/ixj.c:		wake_up_interruptible(&j->read_q);      /* Wake any blocked readers */
NeoLKernel/drivers/telephony/ixj.c:		wake_up_interruptible(&j->write_q);     /* Wake any blocked writers */
NeoLKernel/drivers/telephony/ixj.c:		wake_up_interruptible(&j->poll_q);      /* Wake any blocked selects */
NeoLKernel/drivers/uio/uio.c:	wake_up_interruptible(&idev->wait);
NeoLKernel/drivers/usb/atm/ueagle-atm.c:static inline void wake_up_cmv_ack(struct uea_softc *sc)
NeoLKernel/drivers/usb/atm/ueagle-atm.c:	wake_up(&sc->sync_q);
NeoLKernel/drivers/usb/atm/ueagle-atm.c:	/* wake up processes waiting for synchronization */
NeoLKernel/drivers/usb/atm/ueagle-atm.c:	wake_up(&sc->sync_q);
NeoLKernel/drivers/usb/atm/ueagle-atm.c:	/* wake up processes waiting for synchronization */
NeoLKernel/drivers/usb/atm/ueagle-atm.c:	wake_up(&sc->sync_q);
NeoLKernel/drivers/usb/atm/ueagle-atm.c:		wake_up_cmv_ack(sc);
NeoLKernel/drivers/usb/atm/ueagle-atm.c:	wake_up_cmv_ack(sc);
NeoLKernel/drivers/usb/atm/ueagle-atm.c:		wake_up_cmv_ack(sc);
NeoLKernel/drivers/usb/atm/ueagle-atm.c:	wake_up_cmv_ack(sc);
NeoLKernel/drivers/usb/atm/usbatm.c:	wake_up_process(t);
NeoLKernel/drivers/usb/class/cdc-acm.c:		schedule_work(&acm->waker);
NeoLKernel/drivers/usb/class/cdc-acm.c:		wake_up_interruptible(&acm->drain_wait);
NeoLKernel/drivers/usb/class/cdc-acm.c:	tty_wakeup(tty);
NeoLKernel/drivers/usb/class/cdc-acm.c:static void acm_waker(struct work_struct *waker)
NeoLKernel/drivers/usb/class/cdc-acm.c:	struct acm *acm = container_of(waker, struct acm, waker);
NeoLKernel/drivers/usb/class/cdc-acm.c:		acm->control->needs_remote_wakeup = 1;
NeoLKernel/drivers/usb/class/cdc-acm.c:		acm->control->needs_remote_wakeup = 0;
NeoLKernel/drivers/usb/class/cdc-acm.c:	INIT_WORK(&acm->waker, acm_waker);
NeoLKernel/drivers/usb/class/cdc-acm.c:	cancel_work_sync(&acm->waker);
NeoLKernel/drivers/usb/class/cdc-acm.h:	struct work_struct waker;
NeoLKernel/drivers/usb/class/cdc-wdm.c:	wake_up(&desc->wait);
NeoLKernel/drivers/usb/class/cdc-wdm.c:	wake_up(&desc->wait);
NeoLKernel/drivers/usb/class/cdc-wdm.c:	intf->needs_remote_wakeup = 1;
NeoLKernel/drivers/usb/class/cdc-wdm.c:			desc->intf->needs_remote_wakeup = 0;
NeoLKernel/drivers/usb/class/cdc-wdm.c:	wake_up_all(&desc->wait);
NeoLKernel/drivers/usb/class/usblp.c:	wake_up(&usblp->rwait);
NeoLKernel/drivers/usb/class/usblp.c:	wake_up(&usblp->wwait);
NeoLKernel/drivers/usb/class/usblp.c:			wake_up(&usblp->wwait);
NeoLKernel/drivers/usb/class/usblp.c:	wake_up(&usblp->wwait);
NeoLKernel/drivers/usb/class/usblp.c:	wake_up(&usblp->rwait);
NeoLKernel/drivers/usb/class/usblp.c:	wake_up(&usblp->wwait);
NeoLKernel/drivers/usb/class/usblp.c:	wake_up(&usblp->rwait);
NeoLKernel/drivers/usb/core/devices.c: *   Added a poll method to /proc/bus/usb/devices, to wake
NeoLKernel/drivers/usb/core/devices.c:	wake_up(&deviceconndiscwq);
NeoLKernel/drivers/usb/core/devio.c:	wait_queue_head_t wait;     /* wake up if a request completed */
NeoLKernel/drivers/usb/core/devio.c:	wake_up(&ps->wait);
NeoLKernel/drivers/usb/core/devio.c:		wake_up_all(&ps->wait);
NeoLKernel/drivers/usb/core/driver.c:	intf->needs_remote_wakeup = 0;
NeoLKernel/drivers/usb/core/driver.c:	intf->needs_remote_wakeup = 0;
NeoLKernel/drivers/usb/core/driver.c:		udev->do_remote_wakeup = 0;
NeoLKernel/drivers/usb/core/driver.c:	 * is disabled.  Also fail if any interfaces require remote wakeup
NeoLKernel/drivers/usb/core/driver.c:			if (intf->needs_remote_wakeup &&
NeoLKernel/drivers/usb/core/driver.c:					!udev->do_remote_wakeup) {
NeoLKernel/drivers/usb/core/driver.c:				dev_dbg(&udev->dev, "remote wakeup needed "
NeoLKernel/drivers/usb/core/driver.c:				    intf->needs_remote_wakeup)
NeoLKernel/drivers/usb/core/driver.c:	udev->do_remote_wakeup = device_may_wakeup(&udev->dev);
NeoLKernel/drivers/usb/core/driver.c: * driver requires remote-wakeup capability during autosuspend but remote
NeoLKernel/drivers/usb/core/driver.c: * wakeup is disabled, the autosuspend will fail.
NeoLKernel/drivers/usb/core/driver.c: * when @udev's device file in usbfs is opened or when a remote-wakeup
NeoLKernel/drivers/usb/core/driver.c: * If the driver has set @intf->needs_remote_wakeup then autosuspend will
NeoLKernel/drivers/usb/core/driver.c: * take place only if the device's remote-wakeup facility is enabled.
NeoLKernel/drivers/usb/core/driver.c: * awake).
NeoLKernel/drivers/usb/core/driver.c: * and regardless of whether or not remote wakeup is enabled.  Of course,
NeoLKernel/drivers/usb/core/driver.c: * wakeup).  @udev's usage counter is unaffected.
NeoLKernel/drivers/usb/core/driver.c:	/* Now that the device is awake, we can start trying to autosuspend
NeoLKernel/drivers/usb/core/driver.c:	 * system wakes up in order for USB-PERSIST port handover to work
NeoLKernel/drivers/usb/core/driver.c:	 * during this system wakeup.
NeoLKernel/drivers/usb/core/hcd-pci.c:	 * disallow remote wakeup.
NeoLKernel/drivers/usb/core/hcd-pci.c:		device_set_wakeup_enable(dev, 0);
NeoLKernel/drivers/usb/core/hcd-pci.c:	dev_dbg(dev, "wakeup: %d\n", device_may_wakeup(dev));
NeoLKernel/drivers/usb/core/hcd-pci.c:	/* Possibly enable remote wakeup,
NeoLKernel/drivers/usb/core/hcd-pci.c:	/* Go back to D0 and disable remote wakeup */
NeoLKernel/drivers/usb/core/hcd.c:				     5: Remote wakeup,
NeoLKernel/drivers/usb/core/hcd.c:				     5: Remote wakeup,
NeoLKernel/drivers/usb/core/hcd.c:				     5: Remote wakeup,
NeoLKernel/drivers/usb/core/hcd.c:	u8		patch_wakeup = 0;
NeoLKernel/drivers/usb/core/hcd.c:	/* The root hub's remote wakeup enable bit is implemented using
NeoLKernel/drivers/usb/core/hcd.c:	 * driver model wakeup flags.  If this system supports wakeup
NeoLKernel/drivers/usb/core/hcd.c:	 * through USB, userspace may change the default "allow wakeup"
NeoLKernel/drivers/usb/core/hcd.c:	 * Most root hubs support wakeup from downstream devices, for
NeoLKernel/drivers/usb/core/hcd.c:	 * Likewise, not all root hubs will pass wakeup events upstream,
NeoLKernel/drivers/usb/core/hcd.c:	 * to wake up the whole system.  So don't assume root hub and
NeoLKernel/drivers/usb/core/hcd.c:		tbuf [0] = (device_may_wakeup(&hcd->self.root_hub->dev)
NeoLKernel/drivers/usb/core/hcd.c:			device_set_wakeup_enable(&hcd->self.root_hub->dev, 0);
NeoLKernel/drivers/usb/core/hcd.c:		if (device_can_wakeup(&hcd->self.root_hub->dev)
NeoLKernel/drivers/usb/core/hcd.c:			device_set_wakeup_enable(&hcd->self.root_hub->dev, 1);
NeoLKernel/drivers/usb/core/hcd.c:			if (device_can_wakeup(&hcd->self.root_hub->dev))
NeoLKernel/drivers/usb/core/hcd.c:				patch_wakeup = 1;
NeoLKernel/drivers/usb/core/hcd.c:		/* report whether RH hardware supports remote wakeup */
NeoLKernel/drivers/usb/core/hcd.c:		if (patch_wakeup &&
NeoLKernel/drivers/usb/core/hcd.c:			wake_up(&usb_kill_urb_queue);
NeoLKernel/drivers/usb/core/hcd.c:		wake_up (&usb_kill_urb_queue);
NeoLKernel/drivers/usb/core/hcd.c:/* Workqueue routine for root-hub remote wakeup */
NeoLKernel/drivers/usb/core/hcd.c:	struct usb_hcd *hcd = container_of(work, struct usb_hcd, wakeup_work);
NeoLKernel/drivers/usb/core/hcd.c: * suspended (with the remote wakeup feature enabled) and a remote
NeoLKernel/drivers/usb/core/hcd.c: * wakeup request is received.  The routine submits a workqueue request
NeoLKernel/drivers/usb/core/hcd.c:		queue_work(ksuspend_usb_wq, &hcd->wakeup_work);
NeoLKernel/drivers/usb/core/hcd.c:	INIT_WORK(&hcd->wakeup_work, hcd_resume_work);
NeoLKernel/drivers/usb/core/hcd.c:	/* wakeup flag init defaults to "everything works" for root hubs,
NeoLKernel/drivers/usb/core/hcd.c:	 * recording the overall controller's system wakeup capability.
NeoLKernel/drivers/usb/core/hcd.c:	device_init_wakeup(&rhdev->dev, 1);
NeoLKernel/drivers/usb/core/hcd.c:	if (device_can_wakeup(hcd->self.controller)
NeoLKernel/drivers/usb/core/hcd.c:			&& device_can_wakeup(&hcd->self.root_hub->dev))
NeoLKernel/drivers/usb/core/hcd.c:		dev_dbg(hcd->self.controller, "supports USB remote wakeup\n");
NeoLKernel/drivers/usb/core/hcd.c:	cancel_work_sync(&hcd->wakeup_work);
NeoLKernel/drivers/usb/core/hcd.h:	struct work_struct	wakeup_work;	/* for remote wakeup */
NeoLKernel/drivers/usb/core/hub.c:		wake_up(&khubd_wait);
NeoLKernel/drivers/usb/core/hub.c:			 * (i.e., remote wakeup request), have khubd
NeoLKernel/drivers/usb/core/hub.c:	intf->needs_remote_wakeup = 1;
NeoLKernel/drivers/usb/core/hub.c:		/* root hub wakeup capabilities are managed out-of-band
NeoLKernel/drivers/usb/core/hub.c:				;	/* No change to wakeup settings */
NeoLKernel/drivers/usb/core/hub.c:				device_init_wakeup(&udev->dev,
NeoLKernel/drivers/usb/core/hub.c:				device_init_wakeup(&udev->dev, 0);
NeoLKernel/drivers/usb/core/hub.c:	 * to wake us after we've powered off VBUS; and HNP, switching roles
NeoLKernel/drivers/usb/core/hub.c: * Devices may wake out of a suspend, if anything important happens,
NeoLKernel/drivers/usb/core/hub.c: * using the remote wakeup mechanism.  They may also be taken out of
NeoLKernel/drivers/usb/core/hub.c: * less than 500 uA.  It's also used in OTG, along with remote wakeup.
NeoLKernel/drivers/usb/core/hub.c: * Devices leave suspend state when the host wakes them up.  Some devices
NeoLKernel/drivers/usb/core/hub.c: * also support "remote wakeup", where the device can activate the USB
NeoLKernel/drivers/usb/core/hub.c: * some cases, this wakes the USB host.
NeoLKernel/drivers/usb/core/hub.c:	/* enable remote wakeup when appropriate; this lets the device
NeoLKernel/drivers/usb/core/hub.c:	 * wake up the upstream hub (including maybe the root hub).
NeoLKernel/drivers/usb/core/hub.c:	 * NOTE:  OTG devices may issue remote wakeup (or SRP) even when
NeoLKernel/drivers/usb/core/hub.c:	if (udev->do_remote_wakeup) {
NeoLKernel/drivers/usb/core/hub.c:			dev_dbg(&udev->dev, "won't remote wakeup, status %d\n",
NeoLKernel/drivers/usb/core/hub.c: * resume (by host) or remote wakeup (by device) ... now see what changed
NeoLKernel/drivers/usb/core/hub.c:	 * device is enabled for remote wakeup.  Hence the reset
NeoLKernel/drivers/usb/core/hub.c:					"disable remote wakeup, status %d\n",
NeoLKernel/drivers/usb/core/hub.c: * during a system sleep or is reset when the system wakes up, all the USB
NeoLKernel/drivers/usb/core/hub.c:	/* Skip the initial Clear-Suspend step for a remote wakeup */
NeoLKernel/drivers/usb/core/hub.c:static int remote_wakeup(struct usb_device *udev)
NeoLKernel/drivers/usb/core/hub.c:		dev_dbg(&udev->dev, "usb %sresume\n", "wakeup-");
NeoLKernel/drivers/usb/core/hub.c:static inline int remote_wakeup(struct usb_device *udev)
NeoLKernel/drivers/usb/core/hub.c:static inline int remote_wakeup(struct usb_device *udev)
NeoLKernel/drivers/usb/core/hub.c:			 * remote wakeup event.
NeoLKernel/drivers/usb/core/hub.c:			status = remote_wakeup(udev);
NeoLKernel/drivers/usb/core/hub.c:					ret = remote_wakeup(hdev->
NeoLKernel/drivers/usb/core/Kconfig:	bool "USB selective suspend/resume and wakeup"
NeoLKernel/drivers/usb/core/Kconfig:	  Also, USB "remote wakeup" signaling is supported, whereby some
NeoLKernel/drivers/usb/core/Kconfig:	  USB devices (like keyboards and network adapters) can wake up
NeoLKernel/drivers/usb/core/Kconfig:	  their parent hub.  That wakeup cascades up the USB tree, and
NeoLKernel/drivers/usb/core/Kconfig:	  could wake the system from states like suspend-to-RAM.
NeoLKernel/drivers/usb/core/message.c: * remote wakeup facility; or whether a bulk or interrupt endpoint
NeoLKernel/drivers/usb/core/urb.c:		wake_up(&anchor->wait);
NeoLKernel/drivers/usb/core/usb.c:/* Workqueue for autosuspend and for remote wakeup of root hubs */
NeoLKernel/drivers/usb/early/ehci-dbgp.c:			 * ehci command to try and wake it up. */
NeoLKernel/drivers/usb/function/adb.c:	wake_up(&ctxt->write_wq);
NeoLKernel/drivers/usb/function/adb.c:	wake_up(&ctxt->read_wq);
NeoLKernel/drivers/usb/function/adb.c:	wake_up(&ctxt->read_wq);
NeoLKernel/drivers/usb/function/adb.c:	wake_up(&ctxt->read_wq);
NeoLKernel/drivers/usb/function/ether_cdc_ecm.c:		netif_wake_queue(dev->net);
NeoLKernel/drivers/usb/function/ether_cdc_ecm.c:	netif_wake_queue(dev->net);
NeoLKernel/drivers/usb/function/mass_storage.c:#include <linux/wakelock.h>
NeoLKernel/drivers/usb/function/mass_storage.c:	int			thread_wakeup_needed;
NeoLKernel/drivers/usb/function/mass_storage.c:	struct wake_lock wake_lock, wake_lock_idle;
NeoLKernel/drivers/usb/function/mass_storage.c:static void wakeup_thread(struct fsg_dev *fsg)
NeoLKernel/drivers/usb/function/mass_storage.c:	fsg->thread_wakeup_needed = 1;
NeoLKernel/drivers/usb/function/mass_storage.c:		wake_up_process(fsg->thread_task);
NeoLKernel/drivers/usb/function/mass_storage.c:		wakeup_thread(fsg);
NeoLKernel/drivers/usb/function/mass_storage.c:		wakeup_thread(fsg);
NeoLKernel/drivers/usb/function/mass_storage.c:		if (fsg->thread_wakeup_needed)
NeoLKernel/drivers/usb/function/mass_storage.c:	fsg->thread_wakeup_needed = 0;
NeoLKernel/drivers/usb/function/mass_storage.c:static void adjust_wake_lock(struct fsg_dev *fsg)
NeoLKernel/drivers/usb/function/mass_storage.c:		wake_lock(&fsg->wake_lock);
NeoLKernel/drivers/usb/function/mass_storage.c:		wake_unlock(&fsg->wake_lock);
NeoLKernel/drivers/usb/function/mass_storage.c:	adjust_wake_lock(fsg);
NeoLKernel/drivers/usb/function/mass_storage.c:	adjust_wake_lock(fsg);
NeoLKernel/drivers/usb/function/mass_storage.c:		adjust_wake_lock(fsg);
NeoLKernel/drivers/usb/function/mass_storage.c:	wake_up_process(fsg->thread_task);
NeoLKernel/drivers/usb/function/mass_storage.c:		wake_lock(&fsg->wake_lock_idle);
NeoLKernel/drivers/usb/function/mass_storage.c:		wake_unlock(&fsg->wake_lock_idle);
NeoLKernel/drivers/usb/function/mass_storage.c:	wake_lock_destroy(&fsg->wake_lock_idle);
NeoLKernel/drivers/usb/function/mass_storage.c:	wake_lock_init(&the_fsg->wake_lock, WAKE_LOCK_SUSPEND,
NeoLKernel/drivers/usb/function/mass_storage.c:	wake_lock_init(&the_fsg->wake_lock_idle, WAKE_LOCK_IDLE,
NeoLKernel/drivers/usb/function/msm_hsusb.c:#include <linux/wakelock.h>
NeoLKernel/drivers/usb/function/msm_hsusb.c:static void usb_lpm_wakeup_phy(struct work_struct *);
NeoLKernel/drivers/usb/function/msm_hsusb.c:	struct work_struct wakeup_phy;
NeoLKernel/drivers/usb/function/msm_hsusb.c:	unsigned remote_wakeup:1;
NeoLKernel/drivers/usb/function/msm_hsusb.c:	struct wake_lock wlock;
NeoLKernel/drivers/usb/function/msm_hsusb.c:	 * wakelock, set driver latency to default and act as if we are
NeoLKernel/drivers/usb/function/msm_hsusb.c:	 * in low power mode so that, driver will re-acquire wakelocks
NeoLKernel/drivers/usb/function/msm_hsusb.c:static inline int usb_msm_get_remotewakeup(void)
NeoLKernel/drivers/usb/function/msm_hsusb.c:	return ui->remote_wakeup;
NeoLKernel/drivers/usb/function/msm_hsusb.c:		wake_lock(&ui->wlock);
NeoLKernel/drivers/usb/function/msm_hsusb.c:		wake_lock_timeout(&ui->wlock, HZ / 2);
NeoLKernel/drivers/usb/function/msm_hsusb.c:		wake_lock_init(&ui->wlock, WAKE_LOCK_SUSPEND,
NeoLKernel/drivers/usb/function/msm_hsusb.c:		wake_lock_destroy(&ui->wlock);
NeoLKernel/drivers/usb/function/msm_hsusb.c:		req->req.status = usb_remote_wakeup();
NeoLKernel/drivers/usb/function/msm_hsusb.c:int usb_remote_wakeup(void)
NeoLKernel/drivers/usb/function/msm_hsusb.c:	if (!ui->remote_wakeup) {
NeoLKernel/drivers/usb/function/msm_hsusb.c:		pr_err("%s: remote wakeup not supported\n", __func__);
NeoLKernel/drivers/usb/function/msm_hsusb.c:	if (cancel_work_sync(&ui->li.wakeup_phy))
NeoLKernel/drivers/usb/function/msm_hsusb.c:		usb_lpm_wakeup_phy(NULL);
NeoLKernel/drivers/usb/function/msm_hsusb.c:EXPORT_SYMBOL(usb_remote_wakeup);
NeoLKernel/drivers/usb/function/msm_hsusb.c:			if (usb_msm_get_remotewakeup())
NeoLKernel/drivers/usb/function/msm_hsusb.c:				ui->remote_wakeup = 1;
NeoLKernel/drivers/usb/function/msm_hsusb.c:			ui->remote_wakeup = 0;
NeoLKernel/drivers/usb/function/msm_hsusb.c:	INIT_WORK(&ui->li.wakeup_phy, usb_lpm_wakeup_phy);
NeoLKernel/drivers/usb/function/msm_hsusb.c:static int usb_wakeup_phy(struct usb_info *ui)
NeoLKernel/drivers/usb/function/msm_hsusb.c:		usb_wakeup_phy(ui);
NeoLKernel/drivers/usb/function/msm_hsusb.c:			if (cancel_work_sync(&ui->li.wakeup_phy))
NeoLKernel/drivers/usb/function/msm_hsusb.c:				usb_lpm_wakeup_phy(NULL);
NeoLKernel/drivers/usb/function/msm_hsusb.c:	disable_irq_wake(ui->irq);
NeoLKernel/drivers/usb/function/msm_hsusb.c:					/* re-acquire wakelock and restore axi
NeoLKernel/drivers/usb/function/msm_hsusb.c:				wake_unlock(&ui->wlock);
NeoLKernel/drivers/usb/function/msm_hsusb.c:	wake_lock(&ui->wlock);
NeoLKernel/drivers/usb/function/msm_hsusb.c:		schedule_work(&ui->li.wakeup_phy);
NeoLKernel/drivers/usb/function/msm_hsusb.c:		usb_wakeup_phy(ui);
NeoLKernel/drivers/usb/function/msm_hsusb.c:		usb_wakeup_phy(ui);
NeoLKernel/drivers/usb/function/msm_hsusb.c:		usb_wakeup_phy(ui);
NeoLKernel/drivers/usb/function/msm_hsusb.c:static void usb_lpm_wakeup_phy(struct work_struct *w)
NeoLKernel/drivers/usb/function/msm_hsusb.c:	if (usb_wakeup_phy(ui)) {
NeoLKernel/drivers/usb/function/msm_hsusb.c:	usb_remote_wakeup();
NeoLKernel/drivers/usb/function/msm_hsusb.c:	ui->remote_wakeup = 0;
NeoLKernel/drivers/usb/function/msm_hsusb.c:	enable_irq_wake(irq);
NeoLKernel/drivers/usb/function/msm_hsusb.c:	cancel_work_sync(&ui->li.wakeup_phy);
NeoLKernel/drivers/usb/function/msm_hsusb.c:			if (cancel_work_sync(&ui->li.wakeup_phy))
NeoLKernel/drivers/usb/function/msm_hsusb.c:				usb_lpm_wakeup_phy(NULL);
NeoLKernel/drivers/usb/function/msm_otg.c:	wake_lock_timeout(&xceiv->wlock, HZ/2);
NeoLKernel/drivers/usb/function/msm_otg.c:	wake_lock_timeout(&xceiv->wlock, HZ/2);
NeoLKernel/drivers/usb/function/msm_otg.c:		wake_lock(&xceiv->wlock);
NeoLKernel/drivers/usb/function/msm_otg.c:	wake_lock_init(&xceiv->wlock, WAKE_LOCK_SUSPEND, "usb_otg");
NeoLKernel/drivers/usb/function/msm_otg.c:	wake_lock(&xceiv->wlock);
NeoLKernel/drivers/usb/function/rmnet.c:		 * are opened. wake up worker thread to continue
NeoLKernel/drivers/usb/function/rmnet.c:		wake_up(&smd_info->wait);
NeoLKernel/drivers/usb/function/serial.c:	bool do_tty_wake = false;
NeoLKernel/drivers/usb/function/serial.c:			wake_up_interruptible(&port->port_write_wait);
NeoLKernel/drivers/usb/function/serial.c:		do_tty_wake = true;
NeoLKernel/drivers/usb/function/serial.c:	if (do_tty_wake && port->port_tty)
NeoLKernel/drivers/usb/function/serial.c:		tty_wakeup(port->port_tty);
NeoLKernel/drivers/usb/function/serial.c:		tty_wakeup(port->port_tty);
NeoLKernel/drivers/usb/function/serial.c:		wake_up_interruptible(&tty->read_wait);
NeoLKernel/drivers/usb/function/serial.c:		wake_up_interruptible(&port->port_write_wait);
NeoLKernel/drivers/usb/function/serial.c:			wake_up_interruptible(&port->port_tty->read_wait);
NeoLKernel/drivers/usb/function/serial.c:			wake_up_interruptible(&port->port_tty->write_wait);
NeoLKernel/drivers/usb/function/serial.c:			tty_wakeup(port->port_tty);
NeoLKernel/drivers/usb/function/serial.c:				wake_up_interruptible(&port->port_write_wait);
NeoLKernel/drivers/usb/function/serial.c:					wake_up_interruptible
NeoLKernel/drivers/usb/function/serial.c:					wake_up_interruptible
NeoLKernel/drivers/usb/function/ums.c:	wake_up(&ctxt->write_wq);
NeoLKernel/drivers/usb/function/ums.c:	wake_up(&ctxt->read_wq);
NeoLKernel/drivers/usb/function/ums.c:	wake_up(&ctxt->read_wq);
NeoLKernel/drivers/usb/function/usb_function.h:#define USB_CONFIG_ATT_WAKEUP_POS	(5)	/* can wakeup */
NeoLKernel/drivers/usb/function/usb_function.h:int usb_remote_wakeup(void);
NeoLKernel/drivers/usb/function/usb_function.h:int usb_remote_wakeup(void);
NeoLKernel/drivers/usb/gadget/f_accessory.c:	wake_up(&dev->write_wq);
NeoLKernel/drivers/usb/gadget/f_accessory.c:	wake_up(&dev->read_wq);
NeoLKernel/drivers/usb/gadget/f_accessory.c:	wake_up(&dev->read_wq);
NeoLKernel/drivers/usb/gadget/f_accessory.c:	wake_up(&dev->read_wq);
NeoLKernel/drivers/usb/gadget/Kconfig:	boolean "USB remote wakeup support"
NeoLKernel/drivers/usb/gadget/Kconfig:	  USB remote wakeup support.
NeoLKernel/drivers/usb/gadget/pxa27x_udc.c: * pxa_udc_wakeup - Force udc device out of suspend
NeoLKernel/drivers/usb/gadget/pxa27x_udc.c:static int pxa_udc_wakeup(struct usb_gadget *_gadget)
NeoLKernel/drivers/usb/gadget/pxa27x_udc.c:	/* host may not have enabled remote wakeup */
NeoLKernel/drivers/usb/gadget/pxa27x_udc.c:	.wakeup		= pxa_udc_wakeup,
NeoLKernel/drivers/usb/gadget/amd5536udc.c:static int udc_remote_wakeup(struct udc *dev);
NeoLKernel/drivers/usb/gadget/amd5536udc.c:/* Remote wakeup gadget interface */
NeoLKernel/drivers/usb/gadget/amd5536udc.c:static int udc_wakeup(struct usb_gadget *gadget)
NeoLKernel/drivers/usb/gadget/amd5536udc.c:	udc_remote_wakeup(dev);
NeoLKernel/drivers/usb/gadget/amd5536udc.c:	.wakeup		= udc_wakeup,
NeoLKernel/drivers/usb/gadget/amd5536udc.c:	/* set remote wakeupable */
NeoLKernel/drivers/usb/gadget/amd5536udc.c:/* Initiates a remote wakeup */
NeoLKernel/drivers/usb/gadget/amd5536udc.c:static int udc_remote_wakeup(struct udc *dev)
NeoLKernel/drivers/usb/gadget/amd5536udc.c:	DBG(dev, "UDC initiates remote wakeup\n");
NeoLKernel/drivers/usb/gadget/at91_udc.c:		(mask & (1 << 13)) ? " wakeup" : "",
NeoLKernel/drivers/usb/gadget/at91_udc.c:static int at91_wakeup(struct usb_gadget *gadget)
NeoLKernel/drivers/usb/gadget/at91_udc.c:	.wakeup			= at91_wakeup,
NeoLKernel/drivers/usb/gadget/at91_udc.c:	 * Hosts may set or clear remote wakeup status, and
NeoLKernel/drivers/usb/gadget/at91_udc.c:	device_init_wakeup(dev, 1);
NeoLKernel/drivers/usb/gadget/at91_udc.c:	device_init_wakeup(&pdev->dev, 0);
NeoLKernel/drivers/usb/gadget/at91_udc.c:	int		wake = udc->driver && device_may_wakeup(&pdev->dev);
NeoLKernel/drivers/usb/gadget/at91_udc.c:	/* Unless we can act normally to the host (letting it wake us up
NeoLKernel/drivers/usb/gadget/at91_udc.c:	 * PLLB for USB events (signaling for reset, wakeup, or incoming
NeoLKernel/drivers/usb/gadget/at91_udc.c:			|| !wake
NeoLKernel/drivers/usb/gadget/at91_udc.c:		wake = 0;
NeoLKernel/drivers/usb/gadget/at91_udc.c:		enable_irq_wake(udc->udp_irq);
NeoLKernel/drivers/usb/gadget/at91_udc.c:	udc->active_suspend = wake;
NeoLKernel/drivers/usb/gadget/at91_udc.c:	if (udc->board.vbus_pin > 0 && wake)
NeoLKernel/drivers/usb/gadget/at91_udc.c:		enable_irq_wake(udc->board.vbus_pin);
NeoLKernel/drivers/usb/gadget/at91_udc.c:		disable_irq_wake(udc->board.vbus_pin);
NeoLKernel/drivers/usb/gadget/at91_udc.c:		disable_irq_wake(udc->udp_irq);
NeoLKernel/drivers/usb/gadget/atmel_usba_udc.c:static int usba_udc_wakeup(struct usb_gadget *gadget)
NeoLKernel/drivers/usb/gadget/atmel_usba_udc.c:	.wakeup			= usba_udc_wakeup,
NeoLKernel/drivers/usb/gadget/atmel_usba_udc.c:static inline bool feature_is_dev_remote_wakeup(struct usb_ctrlrequest *crq)
NeoLKernel/drivers/usb/gadget/atmel_usba_udc.c:			if (feature_is_dev_remote_wakeup(crq))
NeoLKernel/drivers/usb/gadget/atmel_usba_udc.c:			} else if (feature_is_dev_remote_wakeup(crq)) {
NeoLKernel/drivers/usb/gadget/diag.c:		wake_up(&ctxt->write_wq);
NeoLKernel/drivers/usb/gadget/diag.c:	wake_up(&ctxt->write_wq);
NeoLKernel/drivers/usb/gadget/diag.c:			wake_up(&ctxt->read_wq);
NeoLKernel/drivers/usb/gadget/diag.c:	wake_up(&ctxt->read_wq);
NeoLKernel/drivers/usb/gadget/diag.c:	wake_up(&ctxt->write_wq);
NeoLKernel/drivers/usb/gadget/diag.c:	wake_up(&ctxt->read_wq);
NeoLKernel/drivers/usb/gadget/diag.c:	wake_up(&ctxt->write_wq);
NeoLKernel/drivers/usb/gadget/dummy_hcd.c:static int dummy_wakeup (struct usb_gadget *_gadget)
NeoLKernel/drivers/usb/gadget/dummy_hcd.c:	.wakeup		= dummy_wakeup,
NeoLKernel/drivers/usb/gadget/dummy_hcd.c:					// device: remote wakeup, selfpowered
NeoLKernel/drivers/usb/gadget/file_storage.c: * Completion events are passed to the main thread by wakeup calls.  Many
NeoLKernel/drivers/usb/gadget/file_storage.c: * trigger remote wakeup.  It uses autoconfiguration to select endpoints
NeoLKernel/drivers/usb/gadget/file_storage.c:	int			thread_wakeup_needed;
NeoLKernel/drivers/usb/gadget/file_storage.c:static void wakeup_thread(struct fsg_dev *fsg)
NeoLKernel/drivers/usb/gadget/file_storage.c:	fsg->thread_wakeup_needed = 1;
NeoLKernel/drivers/usb/gadget/file_storage.c:		wake_up_process(fsg->thread_task);
NeoLKernel/drivers/usb/gadget/file_storage.c:	wakeup_thread(fsg);
NeoLKernel/drivers/usb/gadget/file_storage.c:	wakeup_thread(fsg);
NeoLKernel/drivers/usb/gadget/file_storage.c:	wakeup_thread(fsg);
NeoLKernel/drivers/usb/gadget/file_storage.c:	wakeup_thread(fsg);
NeoLKernel/drivers/usb/gadget/file_storage.c:		if (fsg->thread_wakeup_needed)
NeoLKernel/drivers/usb/gadget/file_storage.c:	fsg->thread_wakeup_needed = 0;
NeoLKernel/drivers/usb/gadget/file_storage.c:	wake_up_process(fsg->thread_task);
NeoLKernel/drivers/usb/gadget/fsl_qe_udc.c:/* Tries to wake up the host connected to this gadget
NeoLKernel/drivers/usb/gadget/fsl_qe_udc.c:static int qe_wakeup(struct usb_gadget *gadget)
NeoLKernel/drivers/usb/gadget/fsl_qe_udc.c:	.wakeup = qe_wakeup,
NeoLKernel/drivers/usb/gadget/fsl_udc_core.c: * Tries to wake up the host connected to this gadget
NeoLKernel/drivers/usb/gadget/fsl_udc_core.c:static int fsl_wakeup(struct usb_gadget *gadget)
NeoLKernel/drivers/usb/gadget/fsl_udc_core.c:	/* Remote wakeup feature not enabled by host */
NeoLKernel/drivers/usb/gadget/fsl_udc_core.c:	if (!udc->remote_wakeup)
NeoLKernel/drivers/usb/gadget/fsl_udc_core.c:	.wakeup = fsl_wakeup,
NeoLKernel/drivers/usb/gadget/fsl_udc_core.c:		tmp |= udc->remote_wakeup << USB_DEVICE_REMOTE_WAKEUP;
NeoLKernel/drivers/usb/gadget/fsl_udc_core.c:	udc->remote_wakeup = 0;	/* default to 0 on reset */
NeoLKernel/drivers/usb/gadget/fsl_udc_core.c:	udc->remote_wakeup = 0;	/* default to 0 on reset */
NeoLKernel/drivers/usb/gadget/fsl_usb2_udc.c: * Tries to wake up the host connected to this gadget
NeoLKernel/drivers/usb/gadget/fsl_usb2_udc.c:static int fsl_wakeup(struct usb_gadget *gadget)
NeoLKernel/drivers/usb/gadget/fsl_usb2_udc.c:	/* Remote wakeup feature not enabled by host */
NeoLKernel/drivers/usb/gadget/fsl_usb2_udc.c:	if (!udc->remote_wakeup)
NeoLKernel/drivers/usb/gadget/fsl_usb2_udc.c:	.wakeup = fsl_wakeup,
NeoLKernel/drivers/usb/gadget/fsl_usb2_udc.c:		tmp |= udc->remote_wakeup << USB_DEVICE_REMOTE_WAKEUP;
NeoLKernel/drivers/usb/gadget/fsl_usb2_udc.c:	udc->remote_wakeup = 0;	/* default to 0 on reset */
NeoLKernel/drivers/usb/gadget/fsl_usb2_udc.c:	udc->remote_wakeup = 0;	/* default to 0 on reset */
NeoLKernel/drivers/usb/gadget/fsl_usb2_udc.h:	unsigned remote_wakeup:1;
NeoLKernel/drivers/usb/gadget/langwell_udc.c:/* tries to wake up the host connected to this gadget */
NeoLKernel/drivers/usb/gadget/langwell_udc.c:static int langwell_wakeup(struct usb_gadget *_gadget)
NeoLKernel/drivers/usb/gadget/langwell_udc.c:	if (!dev->remote_wakeup)
NeoLKernel/drivers/usb/gadget/langwell_udc.c:	/* LPM L1 to L0, remote wakeup */
NeoLKernel/drivers/usb/gadget/langwell_udc.c:	/* tries to wake up the host connected to this gadget */
NeoLKernel/drivers/usb/gadget/langwell_udc.c:	.wakeup		= langwell_wakeup,
NeoLKernel/drivers/usb/gadget/langwell_udc.c:		status_data |= dev->remote_wakeup << USB_DEVICE_REMOTE_WAKEUP;
NeoLKernel/drivers/usb/gadget/langwell_udc.c:	/* LPM L1 to L0, force resume or remote wakeup finished */
NeoLKernel/drivers/usb/gadget/langwell_udc.c:				INFO(dev, "LPM L1 to L0, remote wakeup\n");
NeoLKernel/drivers/usb/gadget/langwell_udc.c:	dev->remote_wakeup = 0;		/* default to 0 on reset */
NeoLKernel/drivers/usb/gadget/langwell_udc.c:	dev->remote_wakeup = 0;	/* default to 0 on reset */
NeoLKernel/drivers/usb/gadget/langwell_udc.h:				remote_wakeup:1,
NeoLKernel/drivers/usb/gadget/lh7a40x_udc.c:		/*val |= (1<<1); *//* Remote wakeup */
NeoLKernel/drivers/usb/gadget/lh7a40x_udc.c:static int lh7a40x_udc_wakeup(struct usb_gadget *_gadget)
NeoLKernel/drivers/usb/gadget/lh7a40x_udc.c:	/* host may not have enabled remote wakeup */
NeoLKernel/drivers/usb/gadget/lh7a40x_udc.c:	.wakeup = lh7a40x_udc_wakeup,
NeoLKernel/drivers/usb/gadget/m66592-udc.h:#define M66592_WKUP		0x0100	/* b8: Remote wakeup */
NeoLKernel/drivers/usb/gadget/m66592-udc.h:#define M66592_RWUPE		0x0080	/* b7: Remote wakeup sense */
NeoLKernel/drivers/usb/gadget/marlin_scsi_ext.c:	wake_up_interruptible(&the_marlin.mldd_wq);
NeoLKernel/drivers/usb/gadget/marlin_scsi_ext.c:	wake_up(&the_marlin.mldd_wq);
NeoLKernel/drivers/usb/gadget/marlin_scsi_ext.c:	wake_up(&the_marlin.mldd_wq);
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:#include <linux/wakelock.h>
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:/*To release the wakelock from debugfs*/
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:static void usb_do_remote_wakeup(struct work_struct *w);
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:	atomic_t remote_wakeup;
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:	struct wake_lock	wlock;
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:static int msm72k_wakeup(struct usb_gadget *_gadget);
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:		wake_lock(&ui->wlock);
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:		if (!atomic_read(&ui->remote_wakeup)) {
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:		wake_lock(&ui->wlock);
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:					temp |= (atomic_read(&ui->remote_wakeup)
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:				atomic_set(&ui->remote_wakeup, 1);
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:			atomic_set(&ui->remote_wakeup, 0);
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:			wake_lock(&ui->wlock);
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:			wake_lock(&ui->wlock);
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:		atomic_set(&ui->remote_wakeup, 0);
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:		wake_lock(&ui->wlock);
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:	INIT_DELAYED_WORK(&ui->rw_work, usb_do_remote_wakeup);
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:				atomic_set(&ui->remote_wakeup, 0);
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:				wake_unlock(&ui->wlock);
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:					wake_unlock(&ui->wlock);
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:				enable_irq_wake(otg->irq);
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:static int debug_wake_lock_open(struct inode *inode, struct file *file)
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:	.open = debug_wake_lock_open,
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:		wake_lock(&ui->wlock);
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:static int msm72k_wakeup(struct usb_gadget *_gadget)
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:	if (!atomic_read(&ui->remote_wakeup)) {
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:			"%s: remote wakeup not supported\n", __func__);
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:	.wakeup		= msm72k_wakeup,
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:static void usb_do_remote_wakeup(struct work_struct *w)
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:	msm72k_wakeup(&ui->gadget);
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:static ssize_t usb_remote_wakeup(struct device *dev,
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:	msm72k_wakeup(&ui->gadget);
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:static DEVICE_ATTR(wakeup, S_IWUSR, 0, usb_remote_wakeup);
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:	wake_lock_init(&ui->wlock,
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:		wake_lock_destroy(&ui->wlock);
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:	retval = device_create_file(&ui->gadget.dev, &dev_attr_wakeup);
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:			"(wakeup) error: (%d)\n", retval);
NeoLKernel/drivers/usb/gadget/msm72k_udc.c:	device_remove_file(&dev->gadget.dev, &dev_attr_wakeup);
NeoLKernel/drivers/usb/gadget/net2280.c:static int net2280_wakeup (struct usb_gadget *_gadget)
NeoLKernel/drivers/usb/gadget/net2280.c:	.wakeup		= net2280_wakeup,
NeoLKernel/drivers/usb/gadget/omap_udc.c:static int omap_wakeup(struct usb_gadget *gadget)
NeoLKernel/drivers/usb/gadget/omap_udc.c:		 * issue wakeups without host enable.
NeoLKernel/drivers/usb/gadget/omap_udc.c:			DBG("remote wakeup...\n");
NeoLKernel/drivers/usb/gadget/omap_udc.c:	.wakeup			= omap_wakeup,
NeoLKernel/drivers/usb/gadget/omap_udc.c:/* suspend/resume/wakeup from sysfs (echo > power/state) or when the
NeoLKernel/drivers/usb/gadget/omap_udc.c: * make host resumes and VBUS detection trigger OMAP wakeup events; that
NeoLKernel/drivers/usb/gadget/omap_udc.c:	DBG("resume + wakeup/SRP\n");
NeoLKernel/drivers/usb/gadget/omap_udc.c:	return omap_wakeup(&udc->gadget);
NeoLKernel/drivers/usb/gadget/printer.c:	wake_up_interruptible(&dev->rx_wait);
NeoLKernel/drivers/usb/gadget/printer.c:	wake_up_interruptible(&dev->tx_wait);
NeoLKernel/drivers/usb/gadget/printer.c:		wake_up_interruptible(&dev->tx_flush_wait);
NeoLKernel/drivers/usb/gadget/printer.c:	wake_up_interruptible(&dev->rx_wait);
NeoLKernel/drivers/usb/gadget/printer.c:	wake_up_interruptible(&dev->tx_wait);
NeoLKernel/drivers/usb/gadget/printer.c:	wake_up_interruptible(&dev->tx_flush_wait);
NeoLKernel/drivers/usb/gadget/pxa25x_udc.c:static int pxa25x_udc_wakeup(struct usb_gadget *_gadget)
NeoLKernel/drivers/usb/gadget/pxa25x_udc.c:	/* host may not have enabled remote wakeup */
NeoLKernel/drivers/usb/gadget/pxa25x_udc.c:	.wakeup		= pxa25x_udc_wakeup,
NeoLKernel/drivers/usb/gadget/f_adb.c:	wake_up(&dev->write_wq);
NeoLKernel/drivers/usb/gadget/f_adb.c:	wake_up(&dev->read_wq);
NeoLKernel/drivers/usb/gadget/f_adb.c:	wake_up(&dev->read_wq);
NeoLKernel/drivers/usb/gadget/f_adb.c:	wake_up(&dev->read_wq);
NeoLKernel/drivers/usb/gadget/f_adb.c:	wake_up(&dev->read_wq);
NeoLKernel/drivers/usb/gadget/f_loopback.c:	/* support autoresume for remote wakeup testing */
NeoLKernel/drivers/usb/gadget/f_mass_storage.c: * Completion events are passed to the main thread by wakeup calls.  Many
NeoLKernel/drivers/usb/gadget/f_mass_storage.c:	int			thread_wakeup_needed;
NeoLKernel/drivers/usb/gadget/f_mass_storage.c:static void wakeup_thread(struct fsg_common *common)
NeoLKernel/drivers/usb/gadget/f_mass_storage.c:	common->thread_wakeup_needed = 1;
NeoLKernel/drivers/usb/gadget/f_mass_storage.c:		wake_up_process(common->thread_task);
NeoLKernel/drivers/usb/gadget/f_mass_storage.c:	wakeup_thread(common);
NeoLKernel/drivers/usb/gadget/f_mass_storage.c:	wakeup_thread(common);
NeoLKernel/drivers/usb/gadget/f_mass_storage.c:		if (common->thread_wakeup_needed)
NeoLKernel/drivers/usb/gadget/f_mass_storage.c:	common->thread_wakeup_needed = 0;
NeoLKernel/drivers/usb/gadget/f_mass_storage.c:		wake_up(&common->fsg_wait);
NeoLKernel/drivers/usb/gadget/f_mass_storage.c:	wake_up_process(common->thread_task);
NeoLKernel/drivers/usb/gadget/f_mtp.c:	wake_up(&dev->write_wq);
NeoLKernel/drivers/usb/gadget/f_mtp.c:	wake_up(&dev->read_wq);
NeoLKernel/drivers/usb/gadget/f_mtp.c:	wake_up(&dev->intr_wq);
NeoLKernel/drivers/usb/gadget/f_mtp.c:				wake_up(&dev->read_wq);
NeoLKernel/drivers/usb/gadget/f_mtp.c:				wake_up(&dev->write_wq);
NeoLKernel/drivers/usb/gadget/f_mtp.c:			wake_up(&dev->read_wq);
NeoLKernel/drivers/usb/gadget/f_mtp.c:			wake_up(&dev->write_wq);
NeoLKernel/drivers/usb/gadget/f_mtp.c:	wake_up(&dev->read_wq);
NeoLKernel/drivers/usb/gadget/f_mtp.c:	wake_up(&dev->read_wq);
NeoLKernel/drivers/usb/gadget/f_phonet.c:	netif_wake_queue(dev);
NeoLKernel/drivers/usb/gadget/f_phonet.c:	netif_wake_queue(dev);
NeoLKernel/drivers/usb/gadget/f_rmnet.c:		 * are opened. wake up worker thread to continue
NeoLKernel/drivers/usb/gadget/f_rmnet.c:		wake_up(&smd_info->wait);
NeoLKernel/drivers/usb/gadget/f_sourcesink.c:	/* support autoresume for remote wakeup testing */
NeoLKernel/drivers/usb/gadget/goku_udc.c:	// no remote wakeup
NeoLKernel/drivers/usb/gadget/goku_udc.c:				/* device remote wakeup: always clear */
NeoLKernel/drivers/usb/gadget/goku_udc.c:				VDBG(dev, "clear dev remote wakeup\n");
NeoLKernel/drivers/usb/gadget/imx_udc.c:static int imx_udc_wakeup(struct usb_gadget *_gadget)
NeoLKernel/drivers/usb/gadget/imx_udc.c:	.wakeup		 = imx_udc_wakeup,
NeoLKernel/drivers/usb/gadget/imx_udc.h:			(irqreg & INTR_WAKEUP) ? " wake" : "",
NeoLKernel/drivers/usb/gadget/inode.c:	wake_up (&dev->wait);
NeoLKernel/drivers/usb/gadget/inode.c:		wake_up (&ep->wait);
NeoLKernel/drivers/usb/gadget/rndis.c:	/* PM and wakeup are "mandatory" for USB, but the RNDIS specs
NeoLKernel/drivers/usb/gadget/rndis.c:	/* wake up host */
NeoLKernel/drivers/usb/gadget/rndis.c:				netif_wake_queue (params->dev);
NeoLKernel/drivers/usb/gadget/s3c-hsotg.c:					 * bit 1 => remote wakeup */
NeoLKernel/drivers/usb/gadget/s3c2410_udc.c: *	s3c2410_udc_wakeup
NeoLKernel/drivers/usb/gadget/s3c2410_udc.c:static int s3c2410_udc_wakeup(struct usb_gadget *_gadget)
NeoLKernel/drivers/usb/gadget/s3c2410_udc.c:	.wakeup			= s3c2410_udc_wakeup,
NeoLKernel/drivers/usb/gadget/u_ether.c: *   - WOL (by tracking suspends and issuing remote wakeup)
NeoLKernel/drivers/usb/gadget/u_ether.c:		netif_wake_queue(dev->net);
NeoLKernel/drivers/usb/gadget/u_ether.c:	netif_wake_queue(dev->net);
NeoLKernel/drivers/usb/gadget/u_serial.c:	bool			do_tty_wake = false;
NeoLKernel/drivers/usb/gadget/u_serial.c:			wake_up_interruptible(&port->drain_wait);
NeoLKernel/drivers/usb/gadget/u_serial.c:		do_tty_wake = true;
NeoLKernel/drivers/usb/gadget/u_serial.c:	if (do_tty_wake && port->port_tty)
NeoLKernel/drivers/usb/gadget/u_serial.c:		tty_wakeup(port->port_tty);
NeoLKernel/drivers/usb/gadget/u_serial.c:		wake_up_interruptible(&tty->read_wait);
NeoLKernel/drivers/usb/gadget/u_serial.c:		tty_wakeup(port->port_tty);
NeoLKernel/drivers/usb/gadget/u_serial.c:	wake_up(&port->close_wait);
NeoLKernel/drivers/usb/gadget/u_serial.c:		wake_up_interruptible(&port->drain_wait);
NeoLKernel/drivers/usb/gadget/zero.c: * has no way for users to trigger remote wakeup.
NeoLKernel/drivers/usb/gadget/zero.c:MODULE_PARM_DESC(autoresume, "zero, or seconds before remote wakeup");
NeoLKernel/drivers/usb/gadget/zero.c:	/* unconfigured devices can't issue wakeups */
NeoLKernel/drivers/usb/gadget/zero.c:		int status = usb_gadget_wakeup(g);
NeoLKernel/drivers/usb/gadget/zero.c:		DBG(cdev, "suspend, wakeup in %d seconds\n", autoresume);
NeoLKernel/drivers/usb/host/r8a66597-hcd.c:		if (rh->dev->udev->do_remote_wakeup) {
NeoLKernel/drivers/usb/host/ehci-au1xxx.c:		if (!hcd->self.root_hub->do_remote_wakeup)
NeoLKernel/drivers/usb/host/ehci-fsl.c:/* called after powerup, by probe or system-pm "wakeup" */
NeoLKernel/drivers/usb/host/ehci-hcd.c:/* On some systems, leaving remote wakeup enabled prevents system shutdown.
NeoLKernel/drivers/usb/host/ehci-hcd.c: * The firmware seems to think that powering off is a wakeup event!
NeoLKernel/drivers/usb/host/ehci-hcd.c: * This routine turns off remote wakeup and everything else, on all ports.
NeoLKernel/drivers/usb/host/ehci-hcd.c:	/* remote wakeup [4.3.1] */
NeoLKernel/drivers/usb/host/ehci-hcd.c:			ehci_dbg (ehci, "port %d remote wakeup\n", i + 1);
NeoLKernel/drivers/usb/host/ehci-hub.c:	 * in progress won't complete.  Hence if remote wakeup is enabled
NeoLKernel/drivers/usb/host/ehci-hub.c:	 * remote wakeup, we must fail the suspend.
NeoLKernel/drivers/usb/host/ehci-hub.c:	if (hcd->self.root_hub->do_remote_wakeup) {
NeoLKernel/drivers/usb/host/ehci-hub.c:		/* enable remote wakeup on all ports */
NeoLKernel/drivers/usb/host/ehci-hub.c:		if (hcd->self.root_hub->do_remote_wakeup) {
NeoLKernel/drivers/usb/host/ehci-hub.c:			/* only enable appropriate wake bits, otherwise the
NeoLKernel/drivers/usb/host/ehci-hub.c:	/* allow remote wakeup */
NeoLKernel/drivers/usb/host/ehci-hub.c:	if (!hcd->self.root_hub->do_remote_wakeup)
NeoLKernel/drivers/usb/host/ehci-msm.c:#include <linux/wakelock.h>
NeoLKernel/drivers/usb/host/ehci-msm.c:	struct wake_lock wlock;
NeoLKernel/drivers/usb/host/ehci-msm.c:static int usb_wakeup_phy(struct usb_hcd *hcd)
NeoLKernel/drivers/usb/host/ehci-msm.c:		ret = msm_fsusb_set_remote_wakeup();
NeoLKernel/drivers/usb/host/ehci-msm.c:	if (device_may_wakeup(dev))
NeoLKernel/drivers/usb/host/ehci-msm.c:		enable_irq_wake(hcd->irq);
NeoLKernel/drivers/usb/host/ehci-msm.c:	if (usb_wakeup_phy(hcd)) {
NeoLKernel/drivers/usb/host/ehci-msm.c:	if (device_may_wakeup(dev))
NeoLKernel/drivers/usb/host/ehci-msm.c:		disable_irq_wake(hcd->irq);
NeoLKernel/drivers/usb/host/ehci-msm.c:	wake_unlock(&mhcd->wlock);
NeoLKernel/drivers/usb/host/ehci-msm.c:	wake_lock(&mhcd->wlock);
NeoLKernel/drivers/usb/host/ehci-msm.c:		wake_lock(&mhcd->wlock);
NeoLKernel/drivers/usb/host/ehci-msm.c:		wake_lock_timeout(&mhcd->wlock, HZ/2);
NeoLKernel/drivers/usb/host/ehci-msm.c:	device_init_wakeup(&pdev->dev, 1);
NeoLKernel/drivers/usb/host/ehci-msm.c:	wake_lock_init(&mhcd->wlock, WAKE_LOCK_SUSPEND, dev_name(&pdev->dev));
NeoLKernel/drivers/usb/host/ehci-msm.c:		wake_lock_destroy(&mhcd->wlock);
NeoLKernel/drivers/usb/host/ehci-msm.c:	device_init_wakeup(&pdev->dev, 0);
NeoLKernel/drivers/usb/host/ehci-msm.c:	wake_lock_destroy(&mhcd->wlock);
NeoLKernel/drivers/usb/host/ehci-pci.c:/* called after powerup, by probe or system-pm "wakeup" */
NeoLKernel/drivers/usb/host/ehci-pci.c:	if (!device_can_wakeup(&pdev->dev)) {
NeoLKernel/drivers/usb/host/ehci-pci.c:		u16	port_wake;
NeoLKernel/drivers/usb/host/ehci-pci.c:		pci_read_config_word(pdev, 0x62, &port_wake);
NeoLKernel/drivers/usb/host/ehci-pci.c:		if (port_wake & 0x0001) {
NeoLKernel/drivers/usb/host/ehci-pci.c:			device_set_wakeup_capable(&pdev->dev, 1);
NeoLKernel/drivers/usb/host/ehci-pci.c:	/* REVISIT: the controller works fine for wakeup iff the root hub
NeoLKernel/drivers/usb/host/ehci-pci.c:	 * PM scenarios with selective suspend and remote wakeup...
NeoLKernel/drivers/usb/host/ehci-pci.c:	if (ehci->no_selective_suspend && device_can_wakeup(&pdev->dev))
NeoLKernel/drivers/usb/host/ehci-pci.c:		ehci_warn(ehci, "selective suspend/wakeup unavailable\n");
NeoLKernel/drivers/usb/host/ehci-pci.c: * to handle powerdown and wakeup, and currently also on
NeoLKernel/drivers/usb/host/ehci-pci.c: * the right sort of wakeup.
NeoLKernel/drivers/usb/host/ehci-pci.c:		if (!hcd->self.root_hub->do_remote_wakeup)
NeoLKernel/drivers/usb/host/ohci-pci.c:	device_init_wakeup(&hcd->self.root_hub->dev, 0);
NeoLKernel/drivers/usb/host/ohci-pci.c:		 * PM wakeup capabilities.
NeoLKernel/drivers/usb/host/ohci-pci.c:		if (device_can_wakeup(&pdev->dev))
NeoLKernel/drivers/usb/host/ohci.h:#define OHCI_CTRL_RWC	(1 << 9)	/* remote wakeup connected */
NeoLKernel/drivers/usb/host/ohci.h:#define OHCI_CTRL_RWE	(1 << 10)	/* remote wakeup enable */
NeoLKernel/drivers/usb/host/ohci.h:#define RH_HS_DRWE	     0x00008000		/* device remote wakeup enable */
NeoLKernel/drivers/usb/host/ohci.h:#define RH_HS_CRWE	     0x80000000		/* clear remote wakeup enable */
NeoLKernel/drivers/usb/host/oxu210hp-hcd.c:/* On some systems, leaving remote wakeup enabled prevents system shutdown.
NeoLKernel/drivers/usb/host/oxu210hp-hcd.c: * The firmware seems to think that powering off is a wakeup event!
NeoLKernel/drivers/usb/host/oxu210hp-hcd.c: * This routine turns off remote wakeup and everything else, on all ports.
NeoLKernel/drivers/usb/host/oxu210hp-hcd.c:	/* remote wakeup [4.3.1] */
NeoLKernel/drivers/usb/host/oxu210hp-hcd.c:			oxu_dbg(oxu, "port %d remote wakeup\n", i + 1);
NeoLKernel/drivers/usb/host/oxu210hp-hcd.c:			if (device_may_wakeup(&hcd->self.root_hub->dev))
NeoLKernel/drivers/usb/host/oxu210hp-hcd.c:		/* enable remote wakeup on all ports */
NeoLKernel/drivers/usb/host/oxu210hp-hcd.c:		if (device_may_wakeup(&hcd->self.root_hub->dev))
NeoLKernel/drivers/usb/host/oxu210hp-hcd.c:	/* allow remote wakeup */
NeoLKernel/drivers/usb/host/oxu210hp-hcd.c:	if (!device_may_wakeup(&hcd->self.root_hub->dev))
NeoLKernel/drivers/usb/host/oxu210hp.h:#define PORT_WKOC_E	(1<<22)		/* wake on overcurrent (enable) */
NeoLKernel/drivers/usb/host/oxu210hp.h:#define PORT_WKDISC_E	(1<<21)		/* wake on disconnect (enable) */
NeoLKernel/drivers/usb/host/oxu210hp.h:#define PORT_WKCONN_E	(1<<20)		/* wake on connect (enable) */
NeoLKernel/drivers/usb/host/pci-quirks.c:#define OHCI_CTRL_RWC		(1 << 9)	/* remote wakeup connected */
NeoLKernel/drivers/usb/host/isp116x-hcd.c: * Suspending/resuming of root hub via sysfs works. Remote wakeup works too.
NeoLKernel/drivers/usb/host/isp116x-hcd.c:			DBG("---- remote wakeup\n");
NeoLKernel/drivers/usb/host/isp116x-hcd.c:	/* Remote wakeup won't work without working clock */
NeoLKernel/drivers/usb/host/isp116x-hcd.c:	if (board->remote_wakeup_enable)
NeoLKernel/drivers/usb/host/isp116x-hcd.c:	if (board->remote_wakeup_enable) {
NeoLKernel/drivers/usb/host/isp116x-hcd.c:		if (!device_can_wakeup(hcd->self.controller))
NeoLKernel/drivers/usb/host/isp116x-hcd.c:			device_init_wakeup(hcd->self.controller, 1);
NeoLKernel/drivers/usb/host/isp116x-hcd.c:	if (board->remote_wakeup_enable)
NeoLKernel/drivers/usb/host/isp116x-hcd.c:	if (board->remote_wakeup_enable)
NeoLKernel/drivers/usb/host/isp116x-hcd.c:		if (hcd->self.root_hub->do_remote_wakeup)
NeoLKernel/drivers/usb/host/isp116x.h:#define		HCCONTROL_RWC	(1 << 9)	/* remote wakeup connected */
NeoLKernel/drivers/usb/host/isp116x.h:#define		HCCONTROL_RWE	(1 << 10)	/* remote wakeup enable */
NeoLKernel/drivers/usb/host/isp116x.h:#define		RH_HS_DRWE	(1 << 15)	/* device remote wakeup
NeoLKernel/drivers/usb/host/isp116x.h:#define		RH_HS_CRWE	(1 << 31)	/* clear remote wakeup
NeoLKernel/drivers/usb/host/isp1362-hcd.c:			DBG(0, "%s: remote wakeup\n", __func__);
NeoLKernel/drivers/usb/host/isp1362.h:#define OHCI_CTRL_RWC	(1 << 9)	/* remote wakeup connected */
NeoLKernel/drivers/usb/host/isp1362.h:#define OHCI_CTRL_RWE	(1 << 10)	/* remote wakeup enable */
NeoLKernel/drivers/usb/host/isp1362.h:#define RH_HS_DRWE	     0x00008000		/* device remote wakeup enable */
NeoLKernel/drivers/usb/host/isp1362.h:#define RH_HS_CRWE	     0x80000000		/* clear remote wakeup enable */
NeoLKernel/drivers/usb/host/ohci-at91.c:	device_init_wakeup(&pdev->dev, 1);
NeoLKernel/drivers/usb/host/ohci-at91.c:	device_init_wakeup(&pdev->dev, 0);
NeoLKernel/drivers/usb/host/ohci-at91.c:	if (device_may_wakeup(&pdev->dev))
NeoLKernel/drivers/usb/host/ohci-at91.c:		enable_irq_wake(hcd->irq);
NeoLKernel/drivers/usb/host/ohci-at91.c:	 * reconnect, or wakeup without the 48 MHz clock active.  so for
NeoLKernel/drivers/usb/host/ohci-at91.c:	if (device_may_wakeup(&pdev->dev))
NeoLKernel/drivers/usb/host/ohci-at91.c:		disable_irq_wake(hcd->irq);
NeoLKernel/drivers/usb/host/ohci-hcd.c:	 * wakeup in a way the bus isn't aware of (e.g., legacy PCI PM).
NeoLKernel/drivers/usb/host/ohci-hcd.c:	 * If the bus glue detected wakeup capability then it should
NeoLKernel/drivers/usb/host/ohci-hcd.c:		device_set_wakeup_capable(hcd->self.controller, 1);
NeoLKernel/drivers/usb/host/ohci-hcd.c:	/* wake on ConnectStatusChange, matching external hubs */
NeoLKernel/drivers/usb/host/ohci-hcd.c:	 * to turn on RHSC along with RD.  But for remote wakeup events
NeoLKernel/drivers/usb/host/ohci-hub.c:	/* maybe resume can wake root hub */
NeoLKernel/drivers/usb/host/ohci-hub.c:	if (ohci_to_hcd(ohci)->self.root_hub->do_remote_wakeup || autostop) {
NeoLKernel/drivers/usb/host/ohci-hub.c:		ohci_dbg(ohci, "%swakeup root hub\n",
NeoLKernel/drivers/usb/host/ohci-hub.c:					!device_may_wakeup(&ohci_to_hcd(ohci)
NeoLKernel/drivers/usb/host/ohci-hub.c:		/* If remote wakeup is disabled, stop polling */
NeoLKernel/drivers/usb/host/ohci-hub.c:					do_remote_wakeup) {
NeoLKernel/drivers/usb/host/sl811-hcd.c:	/* khubd manages debouncing and wakeup */
NeoLKernel/drivers/usb/host/sl811-hcd.c:		sl811->stat_wake = 0;
NeoLKernel/drivers/usb/host/sl811-hcd.c:			DBG("wakeup\n");
NeoLKernel/drivers/usb/host/sl811-hcd.c:			sl811->stat_wake++;
NeoLKernel/drivers/usb/host/sl811-hcd.c:			"wake %ld sof %ld overrun %ld lost %ld\n\n",
NeoLKernel/drivers/usb/host/sl811-hcd.c:		sl811->stat_wake, sl811->stat_sof,
NeoLKernel/drivers/usb/host/sl811-hcd.c:		if (!device_can_wakeup(hcd->self.controller))
NeoLKernel/drivers/usb/host/sl811-hcd.c:			device_init_wakeup(hcd->self.controller,
NeoLKernel/drivers/usb/host/sl811-hcd.c:				sl811->board->can_wakeup);
NeoLKernel/drivers/usb/host/sl811-hcd.c:	 * let's assume it'd only be powered to enable remote wakeup.
NeoLKernel/drivers/usb/host/sl811-hcd.c:	if (!sl811->port1 || !device_can_wakeup(&hcd->self.root_hub->dev)) {
NeoLKernel/drivers/usb/host/sl811.h:	unsigned long		stat_wake;
NeoLKernel/drivers/usb/host/u132-hcd.c:		unsigned long wakeup = 0;
NeoLKernel/drivers/usb/host/u132-hcd.c:				if (delta > wakeup)
NeoLKernel/drivers/usb/host/u132-hcd.c:					wakeup = delta;
NeoLKernel/drivers/usb/host/u132-hcd.c:			if (delta > wakeup)
NeoLKernel/drivers/usb/host/u132-hcd.c:				wakeup = delta;
NeoLKernel/drivers/usb/host/u132-hcd.c:		if (wakeup > 0) {
NeoLKernel/drivers/usb/host/u132-hcd.c:			u132_ring_requeue_work(u132, ring, wakeup);
NeoLKernel/drivers/usb/host/uhci-hcd.c:static void wakeup_rh(struct uhci_hcd *uhci);
NeoLKernel/drivers/usb/host/uhci-hcd.c:	 * wake up immediately from suspend-to-RAM if any of the ports
NeoLKernel/drivers/usb/host/uhci-hcd.c:	int int_enable, egsm_enable, wakeup_enable;
NeoLKernel/drivers/usb/host/uhci-hcd.c:	 * and that remote wakeups should be enabled.
NeoLKernel/drivers/usb/host/uhci-hcd.c:	wakeup_enable = 1;
NeoLKernel/drivers/usb/host/uhci-hcd.c:	/* In auto-stop mode wakeups must always be detected, but
NeoLKernel/drivers/usb/host/uhci-hcd.c:		if (!device_may_wakeup(&rhdev->dev))
NeoLKernel/drivers/usb/host/uhci-hcd.c:	/* In bus-suspend mode wakeups may be disabled, but if they are
NeoLKernel/drivers/usb/host/uhci-hcd.c:		if (!rhdev->do_remote_wakeup)
NeoLKernel/drivers/usb/host/uhci-hcd.c:			wakeup_enable = 0;
NeoLKernel/drivers/usb/host/uhci-hcd.c:	 * port which requests a remote wakeup.  According to the USB spec,
NeoLKernel/drivers/usb/host/uhci-hcd.c:	 * remote-wakeup requests anyway then there's no point to it.
NeoLKernel/drivers/usb/host/uhci-hcd.c:	if (!wakeup_enable || global_suspend_mode_is_broken(uhci))
NeoLKernel/drivers/usb/host/uhci-hcd.c:	/* If we're ignoring wakeup events then there's no reason to
NeoLKernel/drivers/usb/host/uhci-hcd.c:	if (!wakeup_enable || resume_detect_interrupts_are_broken(uhci) ||
NeoLKernel/drivers/usb/host/uhci-hcd.c:	/* If interrupts don't work and remote wakeup is enabled then
NeoLKernel/drivers/usb/host/uhci-hcd.c:	uhci_to_hcd(uhci)->poll_rh = (!int_enable && wakeup_enable);
NeoLKernel/drivers/usb/host/uhci-hcd.c:static void wakeup_rh(struct uhci_hcd *uhci)
NeoLKernel/drivers/usb/host/uhci-hcd.c:	 * no need for wakeup signals.  Otherwise we send Global Resume
NeoLKernel/drivers/usb/host/uhci-hcd.c:	 * in progress won't complete.  Hence if remote wakeup is enabled
NeoLKernel/drivers/usb/host/uhci-hcd.c:	 * remote wakeup, we must fail the suspend.
NeoLKernel/drivers/usb/host/uhci-hcd.c:	else if (hcd->self.root_hub->do_remote_wakeup &&
NeoLKernel/drivers/usb/host/uhci-hcd.c:		wakeup_rh(uhci);
NeoLKernel/drivers/usb/host/uhci-hcd.c:	/* FIXME: Enable non-PME# remote wakeup? */
NeoLKernel/drivers/usb/host/uhci-hcd.c:	/* FIXME: Disable non-PME# remote wakeup? */
NeoLKernel/drivers/usb/host/uhci-hcd.c:	 * settings during a system wakeup.  Check it and reconfigure
NeoLKernel/drivers/usb/host/uhci-hcd.c:	/* If interrupts don't work and remote wakeup is enabled then
NeoLKernel/drivers/usb/host/uhci-hcd.c:	if (!uhci->RD_enable && hcd->self.root_hub->do_remote_wakeup) {
NeoLKernel/drivers/usb/host/uhci-hub.c:				/* Port received a wakeup request */
NeoLKernel/drivers/usb/host/uhci-hub.c:			wakeup_rh(uhci);
NeoLKernel/drivers/usb/host/uhci-q.c:	/* If anyone is waiting for a QH to become idle, wake them up */
NeoLKernel/drivers/usb/host/uhci-q.c:		wake_up_all(&uhci->waitqh);
NeoLKernel/drivers/usb/host/whci/int.c:		wake_up(&whc->cmd_wq);
NeoLKernel/drivers/usb/host/whci/int.c:		wake_up(&whc->async_list_wq);
NeoLKernel/drivers/usb/host/whci/int.c:		wake_up(&whc->periodic_list_wq);
NeoLKernel/drivers/usb/host/xhci-hub.c: * link state, port power, port indicator state, "wake on" enable state
NeoLKernel/drivers/usb/host/xhci-pci.c:/* called after powerup, by probe or system-pm "wakeup" */
NeoLKernel/drivers/usb/host/xhci.h: * SW does need to pay attention to function wake notifications.
NeoLKernel/drivers/usb/host/xhci.h:/* wake on connect (enable) */
NeoLKernel/drivers/usb/host/xhci.h:/* wake on disconnect (enable) */
NeoLKernel/drivers/usb/host/xhci.h:/* wake on over-current (enable) */
NeoLKernel/drivers/usb/host/xhci.h:/* Max Exit Latency (ms) - worst case time to wake up all links in dev path */
NeoLKernel/drivers/usb/host/xhci.h:/* Device Notification Event - device sent function wake notification */
NeoLKernel/drivers/usb/image/mdc800.c:	int data_received=0, wake_up;
NeoLKernel/drivers/usb/image/mdc800.c:	wake_up= ( mdc800->camera_request_ready > 0 )
NeoLKernel/drivers/usb/image/mdc800.c:	if (wake_up)
NeoLKernel/drivers/usb/image/mdc800.c:		wake_up (&mdc800->irq_wait);
NeoLKernel/drivers/usb/image/mdc800.c:	wake_up (&mdc800->write_wait);
NeoLKernel/drivers/usb/image/mdc800.c:	wake_up (&mdc800->download_wait);
NeoLKernel/drivers/usb/misc/adutux.c:	/* always wake up so we recover from errors */
NeoLKernel/drivers/usb/misc/adutux.c:	wake_up_interruptible(&dev->read_wait);
NeoLKernel/drivers/usb/misc/adutux.c:	wake_up(&dev->write_wait);
NeoLKernel/drivers/usb/misc/iowarrior.c:	wake_up_interruptible(&dev->read_wait);
NeoLKernel/drivers/usb/misc/iowarrior.c:	wake_up_interruptible(&dev->write_wait);
NeoLKernel/drivers/usb/misc/iowarrior.c:	wake_up_interruptible(&dev->write_wait);
NeoLKernel/drivers/usb/misc/iowarrior.c:			wake_up_interruptible(&dev->read_wait);
NeoLKernel/drivers/usb/misc/iowarrior.c:			wake_up_interruptible(&dev->write_wait);
NeoLKernel/drivers/usb/misc/iowarrior.c:		wake_up_interruptible(&dev->read_wait);
NeoLKernel/drivers/usb/misc/iowarrior.c:		wake_up_interruptible(&dev->write_wait);
NeoLKernel/drivers/usb/misc/ldusb.c:	wake_up_interruptible(&dev->read_wait);
NeoLKernel/drivers/usb/misc/ldusb.c:	wake_up_interruptible(&dev->write_wait);
NeoLKernel/drivers/usb/misc/ldusb.c:		/* wake up pollers */
NeoLKernel/drivers/usb/misc/ldusb.c:		wake_up_interruptible_all(&dev->read_wait);
NeoLKernel/drivers/usb/misc/ldusb.c:		wake_up_interruptible_all(&dev->write_wait);
NeoLKernel/drivers/usb/misc/legousbtower.c: *   - changed wake_up to wake_up_interruptible
NeoLKernel/drivers/usb/misc/legousbtower.c:	wake_up_interruptible (&dev->read_wait);
NeoLKernel/drivers/usb/misc/legousbtower.c:	wake_up_interruptible(&dev->write_wait);
NeoLKernel/drivers/usb/misc/legousbtower.c:		/* wake up pollers */
NeoLKernel/drivers/usb/misc/legousbtower.c:		wake_up_interruptible_all(&dev->read_wait);
NeoLKernel/drivers/usb/misc/legousbtower.c:		wake_up_interruptible_all(&dev->write_wait);
NeoLKernel/drivers/usb/misc/sisusbvga/sisusb.c:	wake_up(&sisusb->wait_q);
NeoLKernel/drivers/usb/misc/sisusbvga/sisusb.c:	wake_up(&sisusb->wait_q);
NeoLKernel/drivers/usb/misc/usbtest.c: * or remote wakeup (which needs human interaction).
NeoLKernel/drivers/usb/misc/usbtest.c:	// the device's remote wakeup feature ... if we can, test that here
NeoLKernel/drivers/usb/mon/mon_bin.c:	wake_up(&rp->b_wait);
NeoLKernel/drivers/usb/mon/mon_bin.c:	wake_up(&rp->b_wait);
NeoLKernel/drivers/usb/mon/mon_text.c:	wake_up(&rp->wait);
NeoLKernel/drivers/usb/mon/mon_text.c:	wake_up(&rp->wait);
NeoLKernel/drivers/usb/musb/musb_core.c:	/* in host mode, the peripheral may issue remote wakeup.
NeoLKernel/drivers/usb/musb/musb_core.c:				/* remote wakeup?  later, GetPortStatus
NeoLKernel/drivers/usb/musb/musb_core.c:		musb_g_wakeup(musb);
NeoLKernel/drivers/usb/musb/musb_core.c:		if (musb->irq_wake)
NeoLKernel/drivers/usb/musb/musb_core.c:			disable_irq_wake(musb->nIrq);
NeoLKernel/drivers/usb/musb/musb_core.c:/* FIXME this handles wakeup irqs wrong */
NeoLKernel/drivers/usb/musb/musb_core.c:	if (enable_irq_wake(nIrq) == 0) {
NeoLKernel/drivers/usb/musb/musb_core.c:		musb->irq_wake = 1;
NeoLKernel/drivers/usb/musb/musb_core.c:		device_init_wakeup(dev, 1);
NeoLKernel/drivers/usb/musb/musb_core.c:		musb->irq_wake = 0;
NeoLKernel/drivers/usb/musb/musb_core.c:	device_init_wakeup(dev, 0);
NeoLKernel/drivers/usb/musb/musb_core.c:	device_init_wakeup(&pdev->dev, 0);
NeoLKernel/drivers/usb/musb/musb_core.c:		/* FIXME force disconnect unless we know USB will wake
NeoLKernel/drivers/usb/musb/musb_core.c:		 * they will even be wakeup-enabled.
NeoLKernel/drivers/usb/musb/musb_core.h:extern void musb_g_wakeup(struct musb *);
NeoLKernel/drivers/usb/musb/musb_core.h:static inline void musb_g_wakeup(struct musb *m) {}
NeoLKernel/drivers/usb/musb/musb_core.h:	unsigned		irq_wake:1;
NeoLKernel/drivers/usb/musb/musb_core.h:	/* may_wakeup means remote wakeup is enabled */
NeoLKernel/drivers/usb/musb/musb_core.h:	unsigned		may_wakeup:1;
NeoLKernel/drivers/usb/musb/musb_gadget.c: *     + remote wakeup to Linux hosts work, but saw USBCV failures;
NeoLKernel/drivers/usb/musb/musb_gadget.c:static int musb_gadget_wakeup(struct usb_gadget *gadget)
NeoLKernel/drivers/usb/musb/musb_gadget.c:		if (musb->may_wakeup && musb->is_suspended)
NeoLKernel/drivers/usb/musb/musb_gadget.c:		DBG(2, "Unhandled wake: %s\n", otg_state_string(musb));
NeoLKernel/drivers/usb/musb/musb_gadget.c:	DBG(2, "issue wakeup\n");
NeoLKernel/drivers/usb/musb/musb_gadget.c:	.wakeup			= musb_gadget_wakeup,
NeoLKernel/drivers/usb/musb/musb_gadget.c:void musb_g_wakeup(struct musb *musb)
NeoLKernel/drivers/usb/musb/musb_gadget.c:	musb_gadget_wakeup(&musb->g);
NeoLKernel/drivers/usb/musb/musb_gadget.c:	musb->may_wakeup = 0;
NeoLKernel/drivers/usb/musb/musb_gadget_ep0.c:		result[0] |= musb->may_wakeup << USB_DEVICE_REMOTE_WAKEUP;
NeoLKernel/drivers/usb/musb/musb_gadget_ep0.c:				musb->may_wakeup = 0;
NeoLKernel/drivers/usb/musb/musb_gadget_ep0.c:					musb->may_wakeup = 1;
NeoLKernel/drivers/usb/musb/musb_virthub.c:	 * SE0 changing to connect (J) or wakeup (K) states.
NeoLKernel/drivers/usb/musb/omap2430.c:	l &= ~ENABLEWAKEUP;	/* disable wakeup */
NeoLKernel/drivers/usb/musb/omap2430.c:	l |= ENABLEWAKEUP;	/* enable wakeup */
NeoLKernel/drivers/usb/musb/omap2430.c:	l &= ~ENABLEWAKEUP;	/* disable wakeup */
NeoLKernel/drivers/usb/musb/tusb6010.c: * Workaround for spontaneous WBUS wake-up issue #2 for tusb3.0.
NeoLKernel/drivers/usb/musb/tusb6010.c: * Idle TUSB6010 until next wake-up event; NOR access always wakes.
NeoLKernel/drivers/usb/musb/tusb6010.c: * USB link is not suspended ... and tells us the relevant wakeup
NeoLKernel/drivers/usb/musb/tusb6010.c:void tusb_allow_idle(struct musb *musb, u32 wakeup_enables)
NeoLKernel/drivers/usb/musb/tusb6010.c:	if ((wakeup_enables & TUSB_PRCM_WBUS)
NeoLKernel/drivers/usb/musb/tusb6010.c:	wakeup_enables |= TUSB_PRCM_WNORCS;
NeoLKernel/drivers/usb/musb/tusb6010.c:	musb_writel(tbase, TUSB_PRCM_WAKEUP_MASK, ~wakeup_enables);
NeoLKernel/drivers/usb/musb/tusb6010.c:	DBG(6, "idle, wake on %02x\n", wakeup_enables);
NeoLKernel/drivers/usb/musb/tusb6010.c:		u32	wakeups;
NeoLKernel/drivers/usb/musb/tusb6010.c:			wakeups = 0;
NeoLKernel/drivers/usb/musb/tusb6010.c:			wakeups = TUSB_PRCM_WHOSTDISCON
NeoLKernel/drivers/usb/musb/tusb6010.c:				wakeups |= TUSB_PRCM_WID;
NeoLKernel/drivers/usb/musb/tusb6010.c:		wakeups = TUSB_PRCM_WHOSTDISCON | TUSB_PRCM_WBUS;
NeoLKernel/drivers/usb/musb/tusb6010.c:		tusb_allow_idle(musb, wakeups);
NeoLKernel/drivers/usb/musb/tusb6010.c: * register access to TUSB6010 because of NOR flash wake-up.
NeoLKernel/drivers/usb/musb/tusb6010.c: * we don't want to treat that full speed J as a wakeup event.
NeoLKernel/drivers/usb/musb/tusb6010.c:				/* CONNECT can wake if a_wait_bcon is set */
NeoLKernel/drivers/usb/musb/tusb6010.c:	/* Acknowledge wake-up source interrupts */
NeoLKernel/drivers/usb/musb/tusb6010.c:		/* there are issues re-locking the PLL on wakeup ... */
NeoLKernel/drivers/usb/musb/tusb6010.c:		DBG(3, "wake %sactive %02x\n",
NeoLKernel/drivers/usb/musb/tusb6010.c:	 * Don't disable GPIO[7:6] as they are needed for wake-up.
NeoLKernel/drivers/usb/otg/gpio_vbus.c:	 * if they're wake-enabled ... we don't handle that yet.
NeoLKernel/drivers/usb/otg/isp1301_omap.c:		 * remote wakeup (SRP, normal) using their own timer
NeoLKernel/drivers/usb/otg/msm72k_otg.c:	wake_lock(&dev->wlock);
NeoLKernel/drivers/usb/otg/msm72k_otg.c:		wake_lock(&dev->wlock);
NeoLKernel/drivers/usb/otg/msm72k_otg.c:	if (device_may_wakeup(dev->otg.dev)) {
NeoLKernel/drivers/usb/otg/msm72k_otg.c:		enable_irq_wake(dev->irq);
NeoLKernel/drivers/usb/otg/msm72k_otg.c:			enable_irq_wake(dev->vbus_on_irq);
NeoLKernel/drivers/usb/otg/msm72k_otg.c:	if (device_may_wakeup(dev->otg.dev)) {
NeoLKernel/drivers/usb/otg/msm72k_otg.c:		disable_irq_wake(dev->irq);
NeoLKernel/drivers/usb/otg/msm72k_otg.c:			disable_irq_wake(dev->vbus_on_irq);
NeoLKernel/drivers/usb/otg/msm72k_otg.c:	 * But don't release wake_lock, as we got async interrupt and
NeoLKernel/drivers/usb/otg/msm72k_otg.c:			wake_lock(&dev->wlock);
NeoLKernel/drivers/usb/otg/msm72k_otg.c:				wake_lock(&dev->wlock);
NeoLKernel/drivers/usb/otg/msm72k_otg.c:			/* Remote wakeup or resume */
NeoLKernel/drivers/usb/otg/msm72k_otg.c:				pr_err("%s: Unable to wakeup phy\n", __func__);
NeoLKernel/drivers/usb/otg/msm72k_otg.c:	wake_lock(&dev->wlock);
NeoLKernel/drivers/usb/otg/msm72k_otg.c:		wake_lock(&dev->wlock);
NeoLKernel/drivers/usb/otg/msm72k_otg.c:	wake_lock(&dev->wlock);
NeoLKernel/drivers/usb/otg/msm72k_otg.c:		wake_lock(&dev->wlock);
NeoLKernel/drivers/usb/otg/msm72k_otg.c:		wake_lock(&dev->wlock);
NeoLKernel/drivers/usb/otg/msm72k_otg.c:		wake_lock(&dev->wlock);
NeoLKernel/drivers/usb/otg/msm72k_otg.c:	wake_lock(&dev->wlock);
NeoLKernel/drivers/usb/otg/msm72k_otg.c:	 * we might endup releasing wakelock after it is acquired
NeoLKernel/drivers/usb/otg/msm72k_otg.c:		wake_unlock(&dev->wlock);
NeoLKernel/drivers/usb/otg/msm72k_otg.c:	wake_lock(&dev->wlock);
NeoLKernel/drivers/usb/otg/msm72k_otg.c:		wake_lock(&dev->wlock);
NeoLKernel/drivers/usb/otg/msm72k_otg.c:	wake_lock(&dev->wlock);
NeoLKernel/drivers/usb/otg/msm72k_otg.c:		wake_lock(&dev->wlock);
NeoLKernel/drivers/usb/otg/msm72k_otg.c:		wake_lock(&dev->wlock);
NeoLKernel/drivers/usb/otg/msm72k_otg.c:	wake_lock_init(&dev->wlock, WAKE_LOCK_SUSPEND, "msm_otg");
NeoLKernel/drivers/usb/otg/msm72k_otg.c:	device_init_wakeup(&pdev->dev, 1);
NeoLKernel/drivers/usb/otg/msm72k_otg.c:	wake_lock_destroy(&dev->wlock);
NeoLKernel/drivers/usb/otg/msm72k_otg.c:	wake_lock_destroy(&dev->wlock);
NeoLKernel/drivers/usb/otg/twl4030-usb.c:	 * its interrupt may be raised (may wake the system).
NeoLKernel/drivers/usb/serial/ch341.c:	wake_up_interruptible(&priv->delta_msr_wait);
NeoLKernel/drivers/usb/serial/ch341.c:		wake_up_interruptible(&priv->delta_msr_wait);
NeoLKernel/drivers/usb/serial/ChangeLog.history:	Changed generic_write_bulk_callback to not call wake_up_interruptible
NeoLKernel/drivers/usb/serial/cypress_m8.c:		wake_up_interruptible(&priv->delta_msr_wait);
NeoLKernel/drivers/usb/serial/digi_acceleport.c:*    -- Zeroed out sync field in the wakeup_task before first use;
NeoLKernel/drivers/usb/serial/digi_acceleport.c:*       the race condition where the wake up could happen after
NeoLKernel/drivers/usb/serial/digi_acceleport.c:*       asleep waiting for our wakeup call.  Even though we call
NeoLKernel/drivers/usb/serial/digi_acceleport.c:*       wake_up_interruptible() in digi_write_bulk_callback(), there is
NeoLKernel/drivers/usb/serial/digi_acceleport.c:*       a race condition that could cause the wakeup to fail: if our
NeoLKernel/drivers/usb/serial/digi_acceleport.c:*       wake_up_interruptible() call occurs between the time that our
NeoLKernel/drivers/usb/serial/digi_acceleport.c:*       to TASK_INTERRUPTIBLE, the effect of our wakeup setting the state
NeoLKernel/drivers/usb/serial/digi_acceleport.c:*       the wakeup) are called asynchronously from an interrupt, rather than
NeoLKernel/drivers/usb/serial/digi_acceleport.c:*       from the scheduler.  We can avoid the race by calling the wakeup
NeoLKernel/drivers/usb/serial/digi_acceleport.c:*       write_bulk_callback() we queue up a wakeup call on the scheduler
NeoLKernel/drivers/usb/serial/digi_acceleport.c:*       task queue.  We still also invoke the wakeup directly since that
NeoLKernel/drivers/usb/serial/digi_acceleport.c:*    -- Added timeouts to sleeps, to defend against lost wake ups.
NeoLKernel/drivers/usb/serial/digi_acceleport.c:*    variable.  Holding the port lock will prevent a wake up on the
NeoLKernel/drivers/usb/serial/digi_acceleport.c:*    the wake up is not lost in a race when dropping the lock and
NeoLKernel/drivers/usb/serial/digi_acceleport.c:*    sleeping waiting for the wakeup.
NeoLKernel/drivers/usb/serial/digi_acceleport.c:*    wake ups so they happen from the scheduler, because the tty
NeoLKernel/drivers/usb/serial/digi_acceleport.c:*    system can miss wake ups from interrupts.
NeoLKernel/drivers/usb/serial/digi_acceleport.c:*    in case a wake up is lost.
NeoLKernel/drivers/usb/serial/digi_acceleport.c:	struct work_struct dp_wakeup_work;
NeoLKernel/drivers/usb/serial/digi_acceleport.c:static void digi_wakeup_write(struct usb_serial_port *port);
NeoLKernel/drivers/usb/serial/digi_acceleport.c:static void digi_wakeup_write_lock(struct work_struct *work);
NeoLKernel/drivers/usb/serial/digi_acceleport.c: *  so that wake ups are not lost if they occur between the unlock
NeoLKernel/drivers/usb/serial/digi_acceleport.c: *  wake ups.  This is used to implement condition variables.
NeoLKernel/drivers/usb/serial/digi_acceleport.c:static void digi_wakeup_write_lock(struct work_struct *work)
NeoLKernel/drivers/usb/serial/digi_acceleport.c:			container_of(work, struct digi_port, dp_wakeup_work);
NeoLKernel/drivers/usb/serial/digi_acceleport.c:	digi_wakeup_write(port);
NeoLKernel/drivers/usb/serial/digi_acceleport.c:static void digi_wakeup_write(struct usb_serial_port *port)
NeoLKernel/drivers/usb/serial/digi_acceleport.c:	tty_wakeup(tty);
NeoLKernel/drivers/usb/serial/digi_acceleport.c:		wake_up_interruptible(&port->write_wait);
NeoLKernel/drivers/usb/serial/digi_acceleport.c:	/* wake up processes sleeping on writes immediately */
NeoLKernel/drivers/usb/serial/digi_acceleport.c:	digi_wakeup_write(port);
NeoLKernel/drivers/usb/serial/digi_acceleport.c:	/* also queue up a wakeup at scheduler time, in case we */
NeoLKernel/drivers/usb/serial/digi_acceleport.c:	schedule_work(&priv->dp_wakeup_work);
NeoLKernel/drivers/usb/serial/digi_acceleport.c:	wake_up_interruptible(&priv->dp_close_wait);
NeoLKernel/drivers/usb/serial/digi_acceleport.c:		INIT_WORK(&priv->dp_wakeup_work, digi_wakeup_write_lock);
NeoLKernel/drivers/usb/serial/digi_acceleport.c:					digi_wakeup_write(port);
NeoLKernel/drivers/usb/serial/digi_acceleport.c:			wake_up_interruptible(&priv->dp_modem_change_wait);
NeoLKernel/drivers/usb/serial/digi_acceleport.c:			wake_up_interruptible(&priv->dp_transmit_idle_wait);
NeoLKernel/drivers/usb/serial/digi_acceleport.c:			wake_up_interruptible(&priv->dp_flush_wait);
NeoLKernel/drivers/usb/serial/ftdi_sio.c:		wake_up_interruptible(&priv->delta_msr_wait);
NeoLKernel/drivers/usb/serial/io_edgeport.c:						tty_wakeup(tty);
NeoLKernel/drivers/usb/serial/io_edgeport.c:		/* let the tty driver wakeup if it has a special
NeoLKernel/drivers/usb/serial/io_edgeport.c:		   write_wakeup function */
NeoLKernel/drivers/usb/serial/io_edgeport.c:		tty_wakeup(tty);
NeoLKernel/drivers/usb/serial/io_edgeport.c:		tty_wakeup(tty);
NeoLKernel/drivers/usb/serial/io_edgeport.c:	wake_up(&edge_port->wait_command);
NeoLKernel/drivers/usb/serial/io_edgeport.c:			wake_up(&edge_port->wait_chase);
NeoLKernel/drivers/usb/serial/io_edgeport.c:		wake_up(&edge_port->wait_open);
NeoLKernel/drivers/usb/serial/io_edgeport.c:		wake_up_interruptible(&edge_port->delta_msr_wait);
NeoLKernel/drivers/usb/serial/io_ti.c:		wake_up_interruptible(&edge_port->delta_msr_wait);
NeoLKernel/drivers/usb/serial/io_ti.c:			tty_wakeup(tty);
NeoLKernel/drivers/usb/serial/io_ti.c:	/* wakeup any process waiting for writes to complete */
NeoLKernel/drivers/usb/serial/io_ti.c:		tty_wakeup(tty);
NeoLKernel/drivers/usb/serial/io_usbvend.h:#define MANUF_BOARD_REV_B		2	// Manuf Rev B, wakeup interrupt works
NeoLKernel/drivers/usb/serial/keyspan_pda.c: *	- the wakeups from keyspan_pda_write_bulk_callback are queued rather
NeoLKernel/drivers/usb/serial/keyspan_pda.c:	struct work_struct			wakeup_work;
NeoLKernel/drivers/usb/serial/keyspan_pda.c:static void keyspan_pda_wakeup_write(struct work_struct *work)
NeoLKernel/drivers/usb/serial/keyspan_pda.c:		container_of(work, struct keyspan_pda_private, wakeup_work);
NeoLKernel/drivers/usb/serial/keyspan_pda.c:	tty_wakeup(tty);
NeoLKernel/drivers/usb/serial/keyspan_pda.c:			/* queue up a wakeup at scheduler time */
NeoLKernel/drivers/usb/serial/keyspan_pda.c:			schedule_work(&priv->wakeup_work);
NeoLKernel/drivers/usb/serial/keyspan_pda.c:	/* queue up a wakeup at scheduler time */
NeoLKernel/drivers/usb/serial/keyspan_pda.c:	schedule_work(&priv->wakeup_work);
NeoLKernel/drivers/usb/serial/keyspan_pda.c:	INIT_WORK(&priv->wakeup_work, keyspan_pda_wakeup_write);
NeoLKernel/drivers/usb/serial/mos7720.c:		tty_wakeup(tty);
NeoLKernel/drivers/usb/serial/mos7840.c:		tty_wakeup(tty);
NeoLKernel/drivers/usb/serial/mos7840.c:	wake_up(&mos7840_port->delta_msr_wait);
NeoLKernel/drivers/usb/serial/option.c:	serial->interface->needs_remote_wakeup = 1;
NeoLKernel/drivers/usb/serial/option.c:		serial->interface->needs_remote_wakeup = 0;
NeoLKernel/drivers/usb/serial/oti6858.c:				wake_up_interruptible(&priv->intr_wait);
NeoLKernel/drivers/usb/serial/pl2303.c:	wake_up_interruptible(&priv->delta_msr_wait);
NeoLKernel/drivers/usb/serial/pl2303.c:	wake_up_interruptible(&priv->delta_msr_wait);
NeoLKernel/drivers/usb/serial/sierra.c:			serial->interface->needs_remote_wakeup = 0;
NeoLKernel/drivers/usb/serial/sierra.c:	serial->interface->needs_remote_wakeup = 1;
NeoLKernel/drivers/usb/serial/spcp8x5.c:	/* wake up the wait for termios */
NeoLKernel/drivers/usb/serial/spcp8x5.c:	wake_up_interruptible(&priv->delta_msr_wait);
NeoLKernel/drivers/usb/serial/spcp8x5.c:		/* wake up in bulk read */
NeoLKernel/drivers/usb/serial/ti_usb_3410_5052.c:		wake_up_interruptible(&tport->tp_write_wait);
NeoLKernel/drivers/usb/serial/ti_usb_3410_5052.c:		wake_up_interruptible(&tport->tp_write_wait);
NeoLKernel/drivers/usb/serial/ti_usb_3410_5052.c:		wake_up_interruptible(&tport->tp_write_wait);
NeoLKernel/drivers/usb/serial/ti_usb_3410_5052.c:		wake_up_interruptible(&tport->tp_write_wait);
NeoLKernel/drivers/usb/serial/ti_usb_3410_5052.c:	/* more room in the buffer for new writes, wakeup */
NeoLKernel/drivers/usb/serial/ti_usb_3410_5052.c:		tty_wakeup(tty);
NeoLKernel/drivers/usb/serial/ti_usb_3410_5052.c:	wake_up_interruptible(&tport->tp_write_wait);
NeoLKernel/drivers/usb/serial/ti_usb_3410_5052.c:		wake_up_interruptible(&tport->tp_msr_wait);
NeoLKernel/drivers/usb/serial/ti_usb_3410_5052.c:			tty_wakeup(tty);
NeoLKernel/drivers/usb/serial/usb-serial.c: * We would be calling tty_wakeup here, but unfortunately some line
NeoLKernel/drivers/usb/serial/usb-serial.c: * the write wakeup callback (e.g. n_hdlc.c).
NeoLKernel/drivers/usb/serial/usb-serial.c:	tty_wakeup(tty);
NeoLKernel/drivers/usb/serial/whiteheat.c:		wake_up(&command_info->wait_command);
NeoLKernel/drivers/usb/serial/whiteheat.c:		wake_up(&command_info->wait_command);
NeoLKernel/drivers/usb/serial/whiteheat.c:		wake_up(&command_info->wait_command);
NeoLKernel/drivers/usb/serial/whiteheat.c:		   waiting command to wakeup */
NeoLKernel/drivers/usb/serial/whiteheat.c:		wake_up(&command_info->wait_command);
NeoLKernel/drivers/usb/storage/scsiglue.c:	/* enqueue the command and wake up the control thread */
NeoLKernel/drivers/usb/storage/transport.c:/* This is the completion handler which will wake us up when an URB
NeoLKernel/drivers/usb/storage/transport.c:	/* set up data structures for the wakeup system */
NeoLKernel/drivers/usb/storage/transport.c:	 * let's wake it up.  The test_and_clear_bit() call
NeoLKernel/drivers/usb/storage/usb.c:		US_DEBUGP("*** thread awakened.\n");
NeoLKernel/drivers/usb/storage/usb.c:	wake_up(&us->delay_wait);
NeoLKernel/drivers/usb/storage/usb.c:	wake_up(&us->delay_wait);
NeoLKernel/drivers/usb/storage/usb.c:	wake_up_process(th);
NeoLKernel/drivers/uwb/i1480/i1480u-wlp/netdev.c:	netif_wake_queue(net_dev);
NeoLKernel/drivers/uwb/uwbd.c: * communicate with this daemon through an event queue. Daemon wakes
NeoLKernel/drivers/uwb/uwbd.c:		wake_up_all(&rc->uwbd.wq);
NeoLKernel/drivers/uwb/whc-rc.c:		wake_up_all(&whcrc->cmd_wq);
NeoLKernel/drivers/video/arcfb.c:                wake_up(&arcfb_waitq);
NeoLKernel/drivers/video/arcfb.c:			 * which will wake us up */
NeoLKernel/drivers/video/aty/atyfb_base.c:		wake_up_interruptible(&par->vblank.wait);
NeoLKernel/drivers/video/aty/atyfb_base.c:		 * wake up from sleep -- paulus
NeoLKernel/drivers/video/aty/radeonfb.h: * this typically happen with our special "wake up early" hook which allows us to
NeoLKernel/drivers/video/aty/radeonfb.h: * wake up the graphic chip (and thus get the console back) before everything else
NeoLKernel/drivers/video/aty/radeon_pm.c: *	some D2-state (APM-style) sleep/wakeup code for use on some PowerMacs,
NeoLKernel/drivers/video/aty/radeon_pm.c:	 * really cause any problem at this point, provided that the wakeup
NeoLKernel/drivers/video/aty/radeon_pm.c:	/* If we support wakeup from poweroff, we save all regs we can including cfg
NeoLKernel/drivers/video/aty/radeon_pm.c:		 * and we crash on wakeup),
NeoLKernel/drivers/video/aty/radeon_pm.c:		 * it, we'll restore the dynamic clocks state on wakeup
NeoLKernel/drivers/video/msm/adv7520.c:#include <linux/wakelock.h>
NeoLKernel/drivers/video/msm/adv7520.c:struct wake_lock wlock;
NeoLKernel/drivers/video/msm/adv7520.c:	wake_lock(&wlock);
NeoLKernel/drivers/video/msm/adv7520.c:	wake_unlock(&wlock);
NeoLKernel/drivers/video/msm/adv7520.c:	wake_lock_destroy(&wlock);
NeoLKernel/drivers/video/msm/adv7520.c:	wake_lock_init(&wlock, WAKE_LOCK_IDLE, "hdmi_active");
NeoLKernel/drivers/video/msm/mdp_lcdc.c:	wake_up(&lcdc->vsync_waitq);
NeoLKernel/drivers/video/msm/mddi_novatek_fwvga.c:	device_init_wakeup(&client->dev, 0);
NeoLKernel/drivers/video/msm/mddi_sharp.c:static boolean mddi_sharp_vsync_wake = TRUE;
NeoLKernel/drivers/video/msm/mddi_sharp.c:	if (mddi_sharp_vsync_wake) {
NeoLKernel/drivers/video/msm/mddi_sharp.c:		/* if detected = TRUE, client initiated wakeup was detected */
NeoLKernel/drivers/video/msm/mddi_sharp.c:		/* need to clear this vsync wakeup */
NeoLKernel/drivers/video/msm/mddi_sharp.c:		 * detect client initiated wakeup.
NeoLKernel/drivers/video/msm/mddi_sharp.c:	/* Enable the vsync wakeup */
NeoLKernel/drivers/video/msm/mddi_toshiba.c:		/* Enable the vsync wakeup */
NeoLKernel/drivers/video/msm/mddi_toshiba.c:		/* if detected = TRUE, client initiated wakeup was detected */
NeoLKernel/drivers/video/msm/mddi_toshiba.c:		/* need to disable the interrupt wakeup */
NeoLKernel/drivers/video/msm/mddi_toshiba.c:		 * detect client initiated wakeup.
NeoLKernel/drivers/video/msm/msm_fb.c:		printk(KERN_ERR "pm_runtime: fail to wake up\n");
NeoLKernel/drivers/video/msm/vidc/common/dec/vdec.c:	wake_up(&client_ctx->msg_wait);
NeoLKernel/drivers/video/msm/vidc/common/dec/vdec.c:	wake_up(&client_ctx->msg_wait);
NeoLKernel/drivers/video/msm/vidc/common/dec/vdec.c:	wake_up(&client_ctx->msg_wait);
NeoLKernel/drivers/video/msm/vidc/common/dec/vdec.c:			wake_up(&client_ctx->msg_wait);
NeoLKernel/drivers/video/msm/vidc/common/dec/vdec.c:		wake_up(&client_ctx->msg_wait);
NeoLKernel/drivers/video/msm/vidc/common/enc/venc.c:	wake_up(&client_ctx->msg_wait);
NeoLKernel/drivers/video/msm/vidc/common/enc/venc.c:	wake_up(&client_ctx->msg_wait);
NeoLKernel/drivers/video/msm/vidc/common/enc/venc.c:	wake_up(&client_ctx->msg_wait);
NeoLKernel/drivers/video/msm/vidc/common/enc/venc.c:		wake_up(&client_ctx->msg_wait);
NeoLKernel/drivers/video/msm/mddihosti.c:				 * intiated wakeup. The client specific
NeoLKernel/drivers/video/msm/mddihosti.c:			/* a rev_encap will not wake up the link, so we do that here */
NeoLKernel/drivers/video/msm/mddihosti.c:					/* need to wake up link before issuing
NeoLKernel/drivers/video/msm/mddihosti.c:					MDDI_MSG_INFO("wake up link!\n");
NeoLKernel/drivers/video/msm/mddihosti.c:				/* need to wake up link before issuing rev encap command */
NeoLKernel/drivers/video/msm/mddihosti.c:				MDDI_MSG_DEBUG("wake up link!\n");
NeoLKernel/drivers/video/msm/mddihosti.c:				/* only wake up the link if it client status is overdue */
NeoLKernel/drivers/video/msm/mddihosti.c:					/* need to wake up link before issuing rev encap command */
NeoLKernel/drivers/video/msm/mddihosti.c:					MDDI_MSG_DEBUG("wake up link!\n");
NeoLKernel/drivers/video/msm/mddihosti.c:static void mddi_process_client_initiated_wakeup(void)
NeoLKernel/drivers/video/msm/mddihosti.c:	/* Disable MDDI_INT Interrupt, we detect client initiated wakeup one
NeoLKernel/drivers/video/msm/mddihosti.c:			 * wakeup. The client specific handler can clear the
NeoLKernel/drivers/video/msm/mddihosti.c:			 * client initiated wakeups.
NeoLKernel/drivers/video/msm/mddihosti.c:		 * initiated wakeup. If the status register bit is set, as well
NeoLKernel/drivers/video/msm/mddihosti.c:		 * client initiated wakeup.
NeoLKernel/drivers/video/msm/mddihosti.c:		mddi_process_client_initiated_wakeup();
NeoLKernel/drivers/video/msm/mddihosti.c:	/* Display wakeup count register (= 0x3c) */
NeoLKernel/drivers/video/msm/mddi_client_nt35399.c:	wake_up(&nt35399_vsync_wait);
NeoLKernel/drivers/video/msm/mddi_client_toshiba.c:	wake_up(&toshiba_vsync_wait);
NeoLKernel/drivers/video/omap/dispc.c:	/* Enable smart standby/idle, autoidle and wakeup */
NeoLKernel/drivers/video/cyber2000fb.c: * We need to wake up the CyberPro, and make sure its in linear memory
NeoLKernel/drivers/video/cyber2000fb.c: * end up in the situation where the chip is in MMIO mode, but not awake
NeoLKernel/drivers/video/cyber2000fb.c:	 * we use the standard IO-based wakeup.
NeoLKernel/drivers/video/sh_mobile_lcdcfb.c:	/* wake up channel and disable clocks */
NeoLKernel/drivers/video/sh_mobile_lcdcfb.c:				wake_up(&ch->frame_end_wait);
NeoLKernel/drivers/video/tmiofb.c:		wake_up(&par->wait_acc);
NeoLKernel/drivers/video/w100fb.c:	w100_pwr_state.pwrmgt_cntl.f.pwm_wakeup_cond = 0x0;
NeoLKernel/drivers/video/w100fb.h:	u32 pwm_wakeup_cond      : 2;
NeoLKernel/drivers/video/matrox/matroxfb_base.c:		wake_up_interruptible(&minfo->crtc1.vsync.wait);
NeoLKernel/drivers/video/matrox/matroxfb_base.c:		wake_up_interruptible(&minfo->crtc2.vsync.wait);
NeoLKernel/drivers/video/intelfb/intelfbhw.c:	wake_up_interruptible(&dinfo->vsync.wait);
NeoLKernel/drivers/video/pnx4008/sdum.c:	/*setup wakeup interrupt */
NeoLKernel/drivers/video/ps3fb.c:			wake_up_process(ps3fb.task);
NeoLKernel/drivers/video/ps3fb.c:		wake_up_interruptible(&ps3fb.wait_vsync);
NeoLKernel/drivers/video/s1d13xxxfb.c:	/* awaken the chip */
NeoLKernel/drivers/video/s1d13xxxfb.c:	/* do not let go until SDRAM "wakes up" */
NeoLKernel/drivers/video/sa1100fb.c:		wake_up(&fbi->ctrlr_wait);
NeoLKernel/drivers/virtio/virtio_balloon.c:	wake_up(&vb->config_change);
NeoLKernel/drivers/w1/masters/omap_hdq.c:		/* wake up sleeping process */
NeoLKernel/drivers/w1/masters/omap_hdq.c:		wake_up(&hdq_wait_queue);
NeoLKernel/drivers/w1/slaves/w1_ds2431.c:	/* Reset the bus to wake up the EEPROM  */
NeoLKernel/drivers/w1/slaves/w1_ds2433.c:	/* Reset the bus to wake up the EEPROM (this may not be needed) */
NeoLKernel/drivers/w1/w1.c:	wake_up_process(md->thread);
NeoLKernel/drivers/w1/w1.c:	wake_up_process(md->thread);
NeoLKernel/drivers/watchdog/adx_wdt.c:	unsigned int wake;
NeoLKernel/drivers/watchdog/adx_wdt.c:	wdt->wake = (wdt->state == WDT_STATE_START) ? 1 : 0;
NeoLKernel/drivers/watchdog/adx_wdt.c:	if (wdt->wake)
NeoLKernel/drivers/xen/evtchn.c:			wake_up_interruptible(&u->evtchn_wait);
NeoLKernel/drivers/xen/xenbus/xenbus_comms.c:static irqreturn_t wake_waiting(int irq, void *unused)
NeoLKernel/drivers/xen/xenbus/xenbus_comms.c:	wake_up(&xb_waitq);
NeoLKernel/drivers/xen/xenbus/xenbus_comms.c:		err = bind_evtchn_to_irqhandler(xen_store_evtchn, wake_waiting,
NeoLKernel/drivers/xen/xenbus/xenbus_xs.c: * wakes up it acquires the xenwatch_mutex before reading the list and
NeoLKernel/drivers/xen/xenbus/xenbus_xs.c:			wake_up(&watch_events_waitq);
NeoLKernel/drivers/xen/xenbus/xenbus_xs.c:		wake_up(&xs_state.reply_waitq);
NeoLKernel/drivers/xen/xenfs/xenbus.c:		wake_up(&adap->dev_data->read_waitq);
NeoLKernel/drivers/xen/xenfs/xenbus.c:		wake_up(&u->read_waitq);
NeoLKernel/firmware/keyspan_pda/keyspan_pda.S:	;;  are we self-powered? no. can we do remote wakeup? no
NeoLKernel/firmware/keyspan_pda/keyspan_pda.S:	;; 01:	Clear_Feature (sub-switch on wValueL: stall, remote wakeup)
NeoLKernel/firmware/keyspan_pda/keyspan_pda.S:	cjne r3, #0x01, setup_Clear_Feature_not_rwake
NeoLKernel/firmware/keyspan_pda/keyspan_pda.S:	;; Clear_Feature(remote wakeup). ignored.
NeoLKernel/firmware/keyspan_pda/keyspan_pda.S:setup_Clear_Feature_not_rwake:
NeoLKernel/firmware/keyspan_pda/keyspan_pda.S:	;; 03:	Set_Feature (sub-switch on wValueL: stall, remote wakeup)
NeoLKernel/firmware/keyspan_pda/keyspan_pda.S:	cjne r3, #0x01, setup_Set_Feature_not_rwake
NeoLKernel/firmware/keyspan_pda/keyspan_pda.S:	;; Set_Feature(remote wakeup). ignored.
NeoLKernel/firmware/keyspan_pda/keyspan_pda.S:setup_Set_Feature_not_rwake:
NeoLKernel/firmware/keyspan_pda/xircom_pgs.S:	;;  are we self-powered? no. can we do remote wakeup? no
NeoLKernel/firmware/keyspan_pda/xircom_pgs.S:	;; 01:	Clear_Feature (sub-switch on wValueL: stall, remote wakeup)
NeoLKernel/firmware/keyspan_pda/xircom_pgs.S:	cjne r3, #0x01, setup_Clear_Feature_not_rwake
NeoLKernel/firmware/keyspan_pda/xircom_pgs.S:	;; Clear_Feature(remote wakeup). ignored.
NeoLKernel/firmware/keyspan_pda/xircom_pgs.S:setup_Clear_Feature_not_rwake:
NeoLKernel/firmware/keyspan_pda/xircom_pgs.S:	;; 03:	Set_Feature (sub-switch on wValueL: stall, remote wakeup)
NeoLKernel/firmware/keyspan_pda/xircom_pgs.S:	cjne r3, #0x01, setup_Set_Feature_not_rwake
NeoLKernel/firmware/keyspan_pda/xircom_pgs.S:	;; Set_Feature(remote wakeup). ignored.
NeoLKernel/firmware/keyspan_pda/xircom_pgs.S:setup_Set_Feature_not_rwake:
NeoLKernel/fs/jfs/jfs_logmgr.c:#define LOGGC_WAKEUP(tblk)	wake_up_all(&(tblk)->gcwait)
NeoLKernel/fs/jfs/jfs_logmgr.c:#define	LCACHE_WAKEUP(event)	wake_up(event)
NeoLKernel/fs/jfs/jfs_logmgr.c:	 * remove/wakeup transactions from commit queue who were
NeoLKernel/fs/jfs/jfs_logmgr.c:	 * wake her up to lead her group.
NeoLKernel/fs/jfs/jfs_logmgr.c:	wake_up(&log->free_wait);
NeoLKernel/fs/jfs/jfs_logmgr.c:	wake_up_process(jfsIOthread);
NeoLKernel/fs/jfs/jfs_logmgr.c:		/* wakeup I/O initiator */
NeoLKernel/fs/jfs/jfs_logmgr.c:		/* wakeup I/O initiator */
NeoLKernel/fs/jfs/jfs_metapage.c:	wake_up(&mp->wait);
NeoLKernel/fs/jfs/jfs_txnmgr.c: * Retry logic exist outside these macros to protect from spurrious wakeups.
NeoLKernel/fs/jfs/jfs_txnmgr.c:#define TXN_WAKEUP(event) wake_up_all(event)
NeoLKernel/fs/jfs/jfs_txnmgr.c: * greater than the high water mark, wake up the sync daemon.  This should
NeoLKernel/fs/jfs/jfs_txnmgr.c:		wake_up_process(jfsSyncThread);
NeoLKernel/fs/jfs/jfs_txnmgr.c:	 * awakened after sleeping on tblk->waitor
NeoLKernel/fs/jfs/jfs_txnmgr.c:	 * wakeup transactions waiting on the page locked
NeoLKernel/fs/jfs/jfs_txnmgr.c:			/* wakeup all waitors for logsync barrier */
NeoLKernel/fs/jfs/jfs_txnmgr.c:			goto wakeup;
NeoLKernel/fs/jfs/jfs_txnmgr.c:wakeup:
NeoLKernel/fs/jfs/jfs_txnmgr.c:	 * wakeup all waitors for a free tblock
NeoLKernel/fs/jfs/jfs_txnmgr.c:	jfs_info("txLock: awakened     tid = %d, lid = %d", tid, lid);
NeoLKernel/fs/jfs/jfs_txnmgr.c:	 * wakeup transactions waiting on a page locked
NeoLKernel/fs/jfs/jfs_txnmgr.c:	wake_up_all(&tblk->gcwait);	// LOGGC_WAKEUP
NeoLKernel/fs/jfs/jfs_txnmgr.c:		jfs_commit_thread_waking = 0;	/* OK to wake another thread */
NeoLKernel/fs/jfs/jfs_txnmgr.c:		/* In case a wakeup came while all threads were active */
NeoLKernel/fs/jfs/jfs_txnmgr.c:	 * Don't wake up a commit thread if there is already one servicing
NeoLKernel/fs/jfs/jfs_txnmgr.c:		wake_up(&jfs_commit_thread_wait);
NeoLKernel/fs/jfs/jfs_txnmgr.c: *	To be run as a kernel daemon.  This is awakened when tlocks run low.
NeoLKernel/fs/lockd/clntlock.c:		 * and wake up the caller
NeoLKernel/fs/lockd/clntlock.c:		wake_up(&block->b_wait);
NeoLKernel/fs/lockd/clntlock.c:	/* Now, wake up all processes that sleep on a blocked lock */
NeoLKernel/fs/lockd/clntlock.c:			wake_up(&block->b_wait);
NeoLKernel/fs/lockd/clntproc.c:				wake_up_all(&host->h_gracewait);
NeoLKernel/fs/lockd/svclock.c:			svc_wake_up(block->b_daemon);
NeoLKernel/fs/lockd/svclock.c:			svc_wake_up(block->b_daemon);
NeoLKernel/fs/lockd/svclock.c:	svc_wake_up(block->b_daemon);
NeoLKernel/fs/locks.c: *  Added a couple of missing wake_up() calls. Thanks to Thomas Meckel
NeoLKernel/fs/locks.c:static void locks_wake_up_blocks(struct file_lock *blocker)
NeoLKernel/fs/locks.c:			wake_up(&waiter->fl_wait);
NeoLKernel/fs/locks.c:	locks_wake_up_blocks(fl);
NeoLKernel/fs/locks.c:				locks_wake_up_blocks(fl);
NeoLKernel/fs/locks.c:		locks_wake_up_blocks(right);
NeoLKernel/fs/locks.c:		locks_wake_up_blocks(left);
NeoLKernel/fs/locks.c:	locks_wake_up_blocks(fl);
NeoLKernel/fs/mbcache.c:		wake_up_all(&mb_cache_queue);
NeoLKernel/fs/namespace.c:		wake_up_interruptible(&ns->poll);
NeoLKernel/fs/namespace.c:		wake_up_interruptible(&ns->poll);
NeoLKernel/fs/ncpfs/sock.c:	wake_up_all(&req->wq);
NeoLKernel/fs/nfs/client.c:	wake_up_all(&nfs_client_active_wq);
NeoLKernel/fs/nfs/nfs4proc.c:	rpc_wake_up_next(&tbl->slot_tbl_waitq);
NeoLKernel/fs/nfs/nfs4proc.c:		/* just wake up the next guy waiting since
NeoLKernel/fs/nfs/nfs4proc.c:		rpc_wake_up_next(&tbl->slot_tbl_waitq);
NeoLKernel/fs/nfs/nfs4proc.c:				rpc_wake_up_queued_task(&clp->cl_rpcwaitq, task);
NeoLKernel/fs/nfs/nfs4renewd.c: * Implementation of the NFSv4 "renew daemon", which wakes up periodically to
NeoLKernel/fs/nfs/nfs4renewd.c: * then it only wakes up when the request is finished.  Maybe use the
NeoLKernel/fs/nfs/nfs4state.c:		rpc_wake_up(&sequence->wait);
NeoLKernel/fs/nfs/nfs4state.c:	wake_up_bit(&clp->cl_state, NFS4CLNT_MANAGER_RUNNING);
NeoLKernel/fs/nfs/nfs4state.c:	rpc_wake_up(&clp->cl_rpcwaitq);
NeoLKernel/fs/nfs/nfs4state.c:	rpc_wake_up_next(&clp->cl_session->fc_slot_table.slot_tbl_waitq);
NeoLKernel/fs/nfs/pagelist.c: * nfs_unlock_request - Unlock request and wake up sleepers.
NeoLKernel/fs/nfs/pagelist.c:	wake_up_bit(&req->wb_flags, PG_BUSY);
NeoLKernel/fs/nfs/pagelist.c: * nfs_clear_page_tag_locked - Clear request tag and wake up sleepers
NeoLKernel/fs/nfs/unlink.c:		wake_up(&nfsi->waitqueue);
NeoLKernel/fs/nfs/write.c:	wake_up_bit(bitlock, NFS_INO_FLUSHING);
NeoLKernel/fs/nfs/fscache.c:	wake_up_bit(&nfsi->flags, NFS_INO_FSCACHE_LOCK);
NeoLKernel/fs/nfs/idmap.c:	/* If we got an error, terminate now, and wake up pending upcalls */
NeoLKernel/fs/nfs/idmap.c:		wake_up(&idmap->idmap_wq);
NeoLKernel/fs/nfs/idmap.c:			wake_up(&idmap->idmap_wq);
NeoLKernel/fs/nfs/idmap.c:			wake_up(&idmap->idmap_wq);
NeoLKernel/fs/nfs/idmap.c:	wake_up(&idmap->idmap_wq);
NeoLKernel/fs/ecryptfs/kthread.c:			wake_up(&req->wait);
NeoLKernel/fs/ecryptfs/kthread.c:		wake_up(&req->wait);
NeoLKernel/fs/ecryptfs/kthread.c:	wake_up(&ecryptfs_kthread_ctl.wait);
NeoLKernel/fs/ecryptfs/kthread.c:	wake_up(&ecryptfs_kthread_ctl.wait);
NeoLKernel/fs/ecryptfs/messaging.c:		wake_up_process(daemon->task);
NeoLKernel/fs/ecryptfs/messaging.c: * reference to. The other process is going to wake up, check to see
NeoLKernel/fs/ecryptfs/messaging.c:		goto wake_up;
NeoLKernel/fs/ecryptfs/messaging.c:		goto wake_up;
NeoLKernel/fs/ecryptfs/messaging.c:wake_up:
NeoLKernel/fs/ecryptfs/messaging.c:	wake_up_process(msg_ctx->task);
NeoLKernel/fs/ecryptfs/messaging.c: * Sleeps until awaken by ecryptfs_receive_message or until the amount
NeoLKernel/fs/ecryptfs/miscdev.c:	wake_up_interruptible(&daemon->wait);
NeoLKernel/fs/eventfd.c:	 * wakeup is performed on "wqh". A read(2) will return the "count"
NeoLKernel/fs/eventfd.c:	 * issue a wakeup.
NeoLKernel/fs/eventfd.c:		wake_up_locked_poll(&ctx->wqh, POLLIN);
NeoLKernel/fs/eventfd.c:	wake_up_poll(&ctx->wqh, POLLHUP);
NeoLKernel/fs/eventfd.c:			wake_up_locked_poll(&ctx->wqh, POLLOUT);
NeoLKernel/fs/eventfd.c:			wake_up_locked_poll(&ctx->wqh, POLLIN);
NeoLKernel/fs/eventpoll.c: * a wake_up() that in turn might be called from IRQ context.
NeoLKernel/fs/eventpoll.c:/* Used for safe wake up implementation */
NeoLKernel/fs/eventpoll.c:static struct nested_calls poll_safewake_ncalls;
NeoLKernel/fs/eventpoll.c:/* Initialize the poll safe wake up structure */
NeoLKernel/fs/eventpoll.c:	 * Try to see if the current task is already inside this wakeup call.
NeoLKernel/fs/eventpoll.c:			 * We abort this wake by breaking the cycle itself.
NeoLKernel/fs/eventpoll.c:static inline void ep_wake_up_nested(wait_queue_head_t *wqueue,
NeoLKernel/fs/eventpoll.c:	wake_up_locked_poll(wqueue, events);
NeoLKernel/fs/eventpoll.c:static inline void ep_wake_up_nested(wait_queue_head_t *wqueue,
NeoLKernel/fs/eventpoll.c:	wake_up_poll(wqueue, events);
NeoLKernel/fs/eventpoll.c:static int ep_poll_wakeup_proc(void *priv, void *cookie, int call_nests)
NeoLKernel/fs/eventpoll.c:	ep_wake_up_nested((wait_queue_head_t *) cookie, POLLIN,
NeoLKernel/fs/eventpoll.c: * Perform a safe wake up of the poll wait list. The problem is that
NeoLKernel/fs/eventpoll.c: * with the new callback'd wake up system, it is possible that the
NeoLKernel/fs/eventpoll.c: * poll callback is reentered from inside the call to wake_up() done
NeoLKernel/fs/eventpoll.c: * wake up code from the same task more than EP_MAX_NESTS times,
NeoLKernel/fs/eventpoll.c:static void ep_poll_safewake(wait_queue_head_t *wq)
NeoLKernel/fs/eventpoll.c:	ep_call_nested(&poll_safewake_ncalls, EP_MAX_NESTS,
NeoLKernel/fs/eventpoll.c:		       ep_poll_wakeup_proc, NULL, wq, (void *) (long) this_cpu);
NeoLKernel/fs/eventpoll.c:	int error, pwake = 0;
NeoLKernel/fs/eventpoll.c:			wake_up_locked(&ep->wq);
NeoLKernel/fs/eventpoll.c:			pwake++;
NeoLKernel/fs/eventpoll.c:	if (pwake)
NeoLKernel/fs/eventpoll.c:		ep_poll_safewake(&ep->poll_wait);
NeoLKernel/fs/eventpoll.c:	 * queue head lock when unregistering the wait queue. The wakeup callback
NeoLKernel/fs/eventpoll.c:		ep_poll_safewake(&ep->poll_wait);
NeoLKernel/fs/eventpoll.c: * This is the callback that is passed to the wait queue wakeup
NeoLKernel/fs/eventpoll.c:	int pwake = 0;
NeoLKernel/fs/eventpoll.c:		wake_up_locked(&ep->wq);
NeoLKernel/fs/eventpoll.c:		pwake++;
NeoLKernel/fs/eventpoll.c:	if (pwak